// 
// 
// 

// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// ----------------------------------------------------------------------------
// <autogenerated>
//   This file was generated automatically from a .tt file that included
//   the CslTreeGenerator.t4 file.
//   Do not modify this file by hand -- modify the original .tt file.
//   Do not check-in this file!
// </autogenerated>

// Disable pragma warnings for auto-generated code
#pragma warning disable 472,429 

using System;
using System.Collections.Generic;
using CompletionKind=Kusto.Language.Editor.CompletionKind;
using CompletionHint=Kusto.Language.Editor.CompletionHint;

namespace Kusto.Language.Syntax
{
    #region SyntaxNodes
    #region class DirectiveBlock
    public sealed partial class DirectiveBlock : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.DirectiveBlock;
        
        public SyntaxList<Directive> Directives { get; }
        
        public SyntaxList<SyntaxToken> SkippedTokens { get; }
        
        public SyntaxToken EndOfText { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="DirectiveBlock"/>.
        /// </summary>
        internal DirectiveBlock(SyntaxList<Directive> directives, SyntaxList<SyntaxToken> skippedTokens, SyntaxToken endOfText, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Directives = Attach(directives);
            this.SkippedTokens = Attach(skippedTokens);
            this.EndOfText = Attach(endOfText, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Directives;
                case 1: return SkippedTokens;
                case 2: return EndOfText;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Directives);
                case 1: return nameof(SkippedTokens);
                case 2: return nameof(EndOfText);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 2:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.None;
                case 1: return CompletionHint.None;
                case 2: return CompletionHint.None;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitDirectiveBlock(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitDirectiveBlock(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new DirectiveBlock((SyntaxList<Directive>)Directives?.Clone(includeDiagnostics), (SyntaxList<SyntaxToken>)SkippedTokens?.Clone(includeDiagnostics), (SyntaxToken)EndOfText?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class DirectiveBlock */
    
    #region class Directive
    public sealed partial class Directive : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.Directive;
        
        public SyntaxToken Token { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="Directive"/>.
        /// </summary>
        internal Directive(SyntaxToken token, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Token = Attach(token);
            this.Init();
        }
        
        public override int ChildCount => 1;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Token;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Token);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.None;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitDirective(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitDirective(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new Directive((SyntaxToken)Token?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class Directive */
    
    #region class SkippedTokens
    public sealed partial class SkippedTokens : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.SkippedTokens;
        
        public SyntaxList<SyntaxToken> Tokens { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="SkippedTokens"/>.
        /// </summary>
        internal SkippedTokens(SyntaxList<SyntaxToken> tokens, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Tokens = Attach(tokens);
            this.Init();
        }
        
        public override int ChildCount => 1;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Tokens;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Tokens);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.None;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitSkippedTokens(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitSkippedTokens(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new SkippedTokens((SyntaxList<SyntaxToken>)Tokens?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class SkippedTokens */
    
    #region class QueryBlock
    public sealed partial class QueryBlock : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.QueryBlock;
        
        public SyntaxList<Directive> Directives { get; }
        
        public SyntaxList<SeparatedElement<Statement>> Statements { get; }
        
        public SkippedTokens SkippedTokens { get; }
        
        public SyntaxToken EndOfQuery { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="QueryBlock"/>.
        /// </summary>
        internal QueryBlock(SyntaxList<Directive> directives, SyntaxList<SeparatedElement<Statement>> statements, SkippedTokens skippedTokens, SyntaxToken endOfQuery, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Directives = Attach(directives);
            this.Statements = Attach(statements);
            this.SkippedTokens = Attach(skippedTokens, optional: true);
            this.EndOfQuery = Attach(endOfQuery, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 4;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Directives;
                case 1: return Statements;
                case 2: return SkippedTokens;
                case 3: return EndOfQuery;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Directives);
                case 1: return nameof(Statements);
                case 2: return nameof(SkippedTokens);
                case 3: return nameof(EndOfQuery);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 2:
                case 3:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.None;
                case 1: return CompletionHint.NonScalar;
                case 2: return CompletionHint.None;
                case 3: return CompletionHint.None;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitQueryBlock(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitQueryBlock(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new QueryBlock((SyntaxList<Directive>)Directives?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Statement>>)Statements?.Clone(includeDiagnostics), (SkippedTokens)SkippedTokens?.Clone(includeDiagnostics), (SyntaxToken)EndOfQuery?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class QueryBlock */
    
    #region class Expression
    /// <summary>
    /// A node in the Kusto syntax that represents an expression
    /// </summary>
    public abstract partial class Expression : SyntaxNode
    {
        /// <summary>
        /// Constructs a new instance of <see cref="Expression"/>.
        /// </summary>
        internal Expression(IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
        }
    }
    #endregion /* class Expression */
    
    #region class Clause
    /// <summary>
    /// A node in the Kusto syntax that represents a clause
    /// </summary>
    public abstract partial class Clause : SyntaxNode
    {
        /// <summary>
        /// Constructs a new instance of <see cref="Clause"/>.
        /// </summary>
        internal Clause(IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
        }
    }
    #endregion /* class Clause */
    
    #region class TypeOfLiteralExpression
    /// <summary>
    /// A node in the Kusto syntax that represents a typeof expression
    /// </summary>
    public sealed partial class TypeOfLiteralExpression : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.TypeOfLiteralExpression;
        
        public SyntaxToken TypeOfKeyword { get; }
        
        public SyntaxToken OpenParen { get; }
        
        public SyntaxList<SeparatedElement<Expression>> Types { get; }
        
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="TypeOfLiteralExpression"/>.
        /// </summary>
        internal TypeOfLiteralExpression(SyntaxToken typeOfKeyword, SyntaxToken openParen, SyntaxList<SeparatedElement<Expression>> types, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.TypeOfKeyword = Attach(typeOfKeyword);
            this.OpenParen = Attach(openParen);
            this.Types = Attach(types);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 4;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return TypeOfKeyword;
                case 1: return OpenParen;
                case 2: return Types;
                case 3: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(TypeOfKeyword);
                case 1: return nameof(OpenParen);
                case 2: return nameof(Types);
                case 3: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.None;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Declaration;
                case 3: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitTypeOfLiteralExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitTypeOfLiteralExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new TypeOfLiteralExpression((SyntaxToken)TypeOfKeyword?.Clone(includeDiagnostics), (SyntaxToken)OpenParen?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Expression>>)Types?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class TypeOfLiteralExpression */
    
    #region class QueryOperator
    /// <summary>
    /// A node in the Kusto syntax that represents a query operator
    /// </summary>
    public abstract partial class QueryOperator : Expression
    {
        /// <summary>
        /// Constructs a new instance of <see cref="QueryOperator"/>.
        /// </summary>
        internal QueryOperator(IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
        }
    }
    #endregion /* class QueryOperator */
    
    #region class BadQueryOperator
    public sealed partial class BadQueryOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.BadQueryOperator;
        
        public SyntaxToken Keyword { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="BadQueryOperator"/>.
        /// </summary>
        internal BadQueryOperator(SyntaxToken keyword, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Keyword = Attach(keyword);
            this.Init();
        }
        
        public override int ChildCount => 1;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Keyword;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Keyword);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitBadQueryOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitBadQueryOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new BadQueryOperator((SyntaxToken)Keyword?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class BadQueryOperator */
    
    #region class Statement
    /// <summary>
    /// A node in the Kusto syntax that represents a statement.
    /// </summary>
    public abstract partial class Statement : SyntaxNode
    {
        /// <summary>
        /// Constructs a new instance of <see cref="Statement"/>.
        /// </summary>
        internal Statement(IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
        }
    }
    #endregion /* class Statement */
    
    #region class CompoundStringLiteralExpression
    /// <summary>
    /// A node in the kusto syntax that name expression.
    /// </summary>
    public sealed partial class CompoundStringLiteralExpression : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.CompoundStringLiteralExpression;
        
        /// <summary>
        /// One or more tokens that comprise the string literal value.
        /// </summary>
        public SyntaxList<SyntaxToken> Tokens { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="CompoundStringLiteralExpression"/>.
        /// </summary>
        internal CompoundStringLiteralExpression(SyntaxList<SyntaxToken> tokens, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Tokens = Attach(tokens);
            this.Init();
        }
        
        public override int ChildCount => 1;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Tokens;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Tokens);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitCompoundStringLiteralExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitCompoundStringLiteralExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new CompoundStringLiteralExpression((SyntaxList<SyntaxToken>)Tokens?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class CompoundStringLiteralExpression */
    
    #region class Name
    /// <summary>
    /// A node in the Kusto syntax that represents a name.
    /// </summary>
    public abstract partial class Name : SyntaxNode
    {
        /// <summary>
        /// Constructs a new instance of <see cref="Name"/>.
        /// </summary>
        internal Name(IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
        }
    }
    #endregion /* class Name */
    
    #region class TokenName
    /// <summary>
    /// A node in the kusto syntax that represents a single identifier name.
    /// </summary>
    public sealed partial class TokenName : Name
    {
        public override SyntaxKind Kind => SyntaxKind.TokenName;
        
        /// <summary>
        /// The token that is the name.
        /// </summary>
        public SyntaxToken Name { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="TokenName"/>.
        /// </summary>
        internal TokenName(SyntaxToken name, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Name = Attach(name);
            this.Init();
        }
        
        public override int ChildCount => 1;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Name;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Name);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitTokenName(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitTokenName(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new TokenName((SyntaxToken)Name?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class TokenName */
    
    #region class BracketedName
    /// <summary>
    /// A node in the kusto syntax that represents a bracketed name.
    /// </summary>
    public sealed partial class BracketedName : Name
    {
        public override SyntaxKind Kind => SyntaxKind.BracketedName;
        
        /// <summary>
        /// The open bracket token.
        /// </summary>
        public SyntaxToken OpenBracket { get; }
        
        /// <summary>
        /// The string literal expression that comprises the name.
        /// </summary>
        public Expression Name { get; }
        
        /// <summary>
        /// The close bracket token.
        /// </summary>
        public SyntaxToken CloseBracket { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="BracketedName"/>.
        /// </summary>
        internal BracketedName(SyntaxToken openBracket, Expression name, SyntaxToken closeBracket, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.OpenBracket = Attach(openBracket);
            this.Name = Attach(name);
            this.CloseBracket = Attach(closeBracket);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return OpenBracket;
                case 1: return Name;
                case 2: return CloseBracket;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(OpenBracket);
                case 1: return nameof(Name);
                case 2: return nameof(CloseBracket);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.Literal;
                case 2: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitBracketedName(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitBracketedName(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new BracketedName((SyntaxToken)OpenBracket?.Clone(includeDiagnostics), (Expression)Name?.Clone(includeDiagnostics), (SyntaxToken)CloseBracket?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class BracketedName */
    
    #region class BracedName
    /// <summary>
    /// A node in the kusto syntax that represents a client parameter.
    /// </summary>
    public sealed partial class BracedName : Name
    {
        public override SyntaxKind Kind => SyntaxKind.BracedName;
        
        public SyntaxToken OpenBrace { get; }
        
        public SyntaxToken Name { get; }
        
        public SyntaxToken CloseBrace { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="BracedName"/>.
        /// </summary>
        internal BracedName(SyntaxToken openBrace, SyntaxToken name, SyntaxToken closeBrace, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.OpenBrace = Attach(openBrace);
            this.Name = Attach(name);
            this.CloseBrace = Attach(closeBrace);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return OpenBrace;
                case 1: return Name;
                case 2: return CloseBrace;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(OpenBrace);
                case 1: return nameof(Name);
                case 2: return nameof(CloseBrace);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitBracedName(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitBracedName(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new BracedName((SyntaxToken)OpenBrace?.Clone(includeDiagnostics), (SyntaxToken)Name?.Clone(includeDiagnostics), (SyntaxToken)CloseBrace?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class BracedName */
    
    #region class WildcardedName
    public sealed partial class WildcardedName : Name
    {
        public override SyntaxKind Kind => SyntaxKind.WildcardedName;
        
        public SyntaxToken Pattern { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="WildcardedName"/>.
        /// </summary>
        internal WildcardedName(SyntaxToken pattern, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Pattern = Attach(pattern);
            this.Init();
        }
        
        public override int ChildCount => 1;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Pattern;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Pattern);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitWildcardedName(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitWildcardedName(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new WildcardedName((SyntaxToken)Pattern?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class WildcardedName */
    
    #region class BracketedWildcardedName
    public sealed partial class BracketedWildcardedName : Name
    {
        public override SyntaxKind Kind => SyntaxKind.BracketedWildcardedName;
        
        /// <summary>
        /// The open bracket token.
        /// </summary>
        public SyntaxToken OpenBracket { get; }
        
        public SyntaxToken Pattern { get; }
        
        /// <summary>
        /// The close bracket token.
        /// </summary>
        public SyntaxToken CloseBracket { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="BracketedWildcardedName"/>.
        /// </summary>
        internal BracketedWildcardedName(SyntaxToken openBracket, SyntaxToken pattern, SyntaxToken closeBracket, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.OpenBracket = Attach(openBracket);
            this.Pattern = Attach(pattern);
            this.CloseBracket = Attach(closeBracket);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return OpenBracket;
                case 1: return Pattern;
                case 2: return CloseBracket;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(OpenBracket);
                case 1: return nameof(Pattern);
                case 2: return nameof(CloseBracket);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitBracketedWildcardedName(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitBracketedWildcardedName(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new BracketedWildcardedName((SyntaxToken)OpenBracket?.Clone(includeDiagnostics), (SyntaxToken)Pattern?.Clone(includeDiagnostics), (SyntaxToken)CloseBracket?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class BracketedWildcardedName */
    
    #region class NameDeclaration
    /// <summary>
    /// A node in the Kusto syntax that represents a name declaration.
    /// </summary>
    public sealed partial class NameDeclaration : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.NameDeclaration;
        
        /// <summary>
        /// The table name
        /// </summary>
        public Name Name { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="NameDeclaration"/>.
        /// </summary>
        internal NameDeclaration(Name name, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Name = Attach(name);
            this.Init();
        }
        
        public override int ChildCount => 1;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Name;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Name);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitNameDeclaration(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitNameDeclaration(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new NameDeclaration((Name)Name?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class NameDeclaration */
    
    #region class NameReference
    /// <summary>
    /// A node in the Kusto syntax that represents a name reference.
    /// </summary>
    public sealed partial class NameReference : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.NameReference;
        
        /// <summary>
        /// The table name
        /// </summary>
        public Name Name { get; }
        
        public Kusto.Language.Symbols.SymbolMatch Match { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="NameReference"/>.
        /// </summary>
        internal NameReference(Name name, Kusto.Language.Symbols.SymbolMatch match, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Name = Attach(name);
            this.Match = match;
            this.Init();
        }
        
        public override int ChildCount => 1;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Name;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Name);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitNameReference(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitNameReference(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new NameReference((Name)Name?.Clone(includeDiagnostics), Match, (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class NameReference */
    
    #region class LiteralExpression
    /// <summary>
    /// A node in the kusto syntax that represents a literal expression.
    /// </summary>
    public sealed partial class LiteralExpression : Expression
    {
        private readonly SyntaxKind kind;
        public override SyntaxKind Kind => this.kind;
        
        /// <summary>
        /// The token with the literal value.
        /// </summary>
        public SyntaxToken Token { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="LiteralExpression"/>.
        /// </summary>
        internal LiteralExpression(SyntaxKind kind, SyntaxToken token, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.kind = kind;
            this.Token = Attach(token);
            this.Init();
        }
        
        public override int ChildCount => 1;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Token;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Token);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Literal;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitLiteralExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitLiteralExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new LiteralExpression(this.Kind, (SyntaxToken)Token?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class LiteralExpression */
    
    #region class StarExpression
    /// <summary>
    /// A node in the kusto syntax that represents an expression comprised of a single token.
    /// </summary>
    public sealed partial class StarExpression : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.StarExpression;
        
        /// <summary>
        /// The token.
        /// </summary>
        public SyntaxToken AsteriskToken { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="StarExpression"/>.
        /// </summary>
        internal StarExpression(SyntaxToken asteriskToken, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.AsteriskToken = Attach(asteriskToken);
            this.Init();
        }
        
        public override int ChildCount => 1;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return AsteriskToken;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(AsteriskToken);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitStarExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitStarExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new StarExpression((SyntaxToken)AsteriskToken?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class StarExpression */
    
    #region class AtExpression
    /// <summary>
    /// A node in the kusto syntax that represents an expression comprised of a single token.
    /// </summary>
    public sealed partial class AtExpression : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.AtExpression;
        
        /// <summary>
        /// The token.
        /// </summary>
        public SyntaxToken AtToken { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="AtExpression"/>.
        /// </summary>
        internal AtExpression(SyntaxToken atToken, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.AtToken = Attach(atToken);
            this.Init();
        }
        
        public override int ChildCount => 1;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return AtToken;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(AtToken);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitAtExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitAtExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new AtExpression((SyntaxToken)AtToken?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class AtExpression */
    
    #region class JsonExpression
    /// <summary>
    /// A node in the Kusto syntax that represents a json expression
    /// </summary>
    public abstract partial class JsonExpression : Expression
    {
        /// <summary>
        /// Constructs a new instance of <see cref="JsonExpression"/>.
        /// </summary>
        internal JsonExpression(IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
        }
    }
    #endregion /* class JsonExpression */
    
    #region class JsonPair
    /// <summary>
    /// A node in the kusto syntax that represents a JSON scalar expression.
    /// </summary>
    public sealed partial class JsonPair : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.JsonPair;
        
        /// <summary>
        /// The token with the name of the JSON element.
        /// </summary>
        public SyntaxToken Name { get; }
        
        /// <summary>
        /// The colon token.
        /// </summary>
        public SyntaxToken Colon { get; }
        
        /// <summary>
        /// The value of the JSON element.
        /// </summary>
        public Expression Value { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="JsonPair"/>.
        /// </summary>
        internal JsonPair(SyntaxToken name, SyntaxToken colon, Expression value, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Name = Attach(name);
            this.Colon = Attach(colon);
            this.Value = Attach(value);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Name;
                case 1: return Colon;
                case 2: return Value;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Name);
                case 1: return nameof(Colon);
                case 2: return nameof(Value);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Declaration;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Literal;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitJsonPair(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitJsonPair(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new JsonPair((SyntaxToken)Name?.Clone(includeDiagnostics), (SyntaxToken)Colon?.Clone(includeDiagnostics), (Expression)Value?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class JsonPair */
    
    #region class JsonObjectExpression
    /// <summary>
    /// A node in the kusto syntax that represents a JSON object expression.
    /// </summary>
    public sealed partial class JsonObjectExpression : JsonExpression
    {
        public override SyntaxKind Kind => SyntaxKind.JsonObjectExpression;
        
        /// <summary>
        /// The open brace token.
        /// </summary>
        public SyntaxToken OpenBrace { get; }
        
        /// <summary>
        /// The list of name value pairs.
        /// </summary>
        public SyntaxList<SeparatedElement<JsonPair>> Pairs { get; }
        
        /// <summary>
        /// The close brace token.
        /// </summary>
        public SyntaxToken CloseBrace { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="JsonObjectExpression"/>.
        /// </summary>
        internal JsonObjectExpression(SyntaxToken openBrace, SyntaxList<SeparatedElement<JsonPair>> pairs, SyntaxToken closeBrace, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.OpenBrace = Attach(openBrace);
            this.Pairs = Attach(pairs);
            this.CloseBrace = Attach(closeBrace);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return OpenBrace;
                case 1: return Pairs;
                case 2: return CloseBrace;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(OpenBrace);
                case 1: return nameof(Pairs);
                case 2: return nameof(CloseBrace);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitJsonObjectExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitJsonObjectExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new JsonObjectExpression((SyntaxToken)OpenBrace?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<JsonPair>>)Pairs?.Clone(includeDiagnostics), (SyntaxToken)CloseBrace?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class JsonObjectExpression */
    
    #region class JsonArrayExpression
    /// <summary>
    /// A node in the kusto syntax that represents a JSON array expression.
    /// </summary>
    public sealed partial class JsonArrayExpression : JsonExpression
    {
        public override SyntaxKind Kind => SyntaxKind.JsonArrayExpression;
        
        /// <summary>
        /// The open bracket token.
        /// </summary>
        public SyntaxToken OpenBracket { get; }
        
        /// <summary>
        /// The list of values.
        /// </summary>
        public SyntaxList<SeparatedElement<Expression>> Values { get; }
        
        /// <summary>
        /// The close bracket token.
        /// </summary>
        public SyntaxToken CloseBracket { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="JsonArrayExpression"/>.
        /// </summary>
        internal JsonArrayExpression(SyntaxToken openBracket, SyntaxList<SeparatedElement<Expression>> values, SyntaxToken closeBracket, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.OpenBracket = Attach(openBracket);
            this.Values = Attach(values);
            this.CloseBracket = Attach(closeBracket);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return OpenBracket;
                case 1: return Values;
                case 2: return CloseBracket;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(OpenBracket);
                case 1: return nameof(Values);
                case 2: return nameof(CloseBracket);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.Literal;
                case 2: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitJsonArrayExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitJsonArrayExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new JsonArrayExpression((SyntaxToken)OpenBracket?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Expression>>)Values?.Clone(includeDiagnostics), (SyntaxToken)CloseBracket?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class JsonArrayExpression */
    
    #region class DynamicExpression
    /// <summary>
    /// A node in the kusto syntax that represents a dynamic expression.
    /// </summary>
    public sealed partial class DynamicExpression : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.DynamicExpression;
        
        /// <summary>
        /// The dynamic keyword.
        /// </summary>
        public SyntaxToken Dynamic { get; }
        
        /// <summary>
        /// The open bracket token.
        /// </summary>
        public SyntaxToken OpenParen { get; }
        
        /// <summary>
        /// The body of the dynamic expression.
        /// </summary>
        public Expression Expression { get; }
        
        /// <summary>
        /// The close bracket token.
        /// </summary>
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="DynamicExpression"/>.
        /// </summary>
        internal DynamicExpression(SyntaxToken dynamic, SyntaxToken openParen, Expression expression, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Dynamic = Attach(dynamic);
            this.OpenParen = Attach(openParen);
            this.Expression = Attach(expression);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 4;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Dynamic;
                case 1: return OpenParen;
                case 2: return Expression;
                case 3: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Dynamic);
                case 1: return nameof(OpenParen);
                case 2: return nameof(Expression);
                case 3: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Syntax;
                case 3: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitDynamicExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitDynamicExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new DynamicExpression((SyntaxToken)Dynamic?.Clone(includeDiagnostics), (SyntaxToken)OpenParen?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class DynamicExpression */
    
    #region class ParenthesizedExpression
    /// <summary>
    /// A node in the kusto syntax that represents a parenthesized expression.
    /// </summary>
    public sealed partial class ParenthesizedExpression : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.ParenthesizedExpression;
        
        /// <summary>
        /// The open parenthesis token.
        /// </summary>
        public SyntaxToken OpenParen { get; }
        
        /// <summary>
        /// The parenthesized expression.
        /// </summary>
        public Expression Expression { get; }
        
        /// <summary>
        /// The close parenthesis token.
        /// </summary>
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ParenthesizedExpression"/>.
        /// </summary>
        internal ParenthesizedExpression(SyntaxToken openParen, Expression expression, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.OpenParen = Attach(openParen);
            this.Expression = Attach(expression);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return OpenParen;
                case 1: return Expression;
                case 2: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(OpenParen);
                case 1: return nameof(Expression);
                case 2: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 2: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitParenthesizedExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitParenthesizedExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ParenthesizedExpression((SyntaxToken)OpenParen?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ParenthesizedExpression */
    
    #region class ExpressionList
    /// <summary>
    /// A node in the kusto syntax that represents a parenthesized list of expressions.
    /// </summary>
    public sealed partial class ExpressionList : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.ExpressionList;
        
        /// <summary>
        /// The open parenthesis token.
        /// </summary>
        public SyntaxToken OpenParen { get; }
        
        /// <summary>
        /// The list of expressions.
        /// </summary>
        public SyntaxList<SeparatedElement<Expression>> Expressions { get; }
        
        /// <summary>
        /// The close parenthesis token.
        /// </summary>
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ExpressionList"/>.
        /// </summary>
        internal ExpressionList(SyntaxToken openParen, SyntaxList<SeparatedElement<Expression>> expressions, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.OpenParen = Attach(openParen);
            this.Expressions = Attach(expressions);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return OpenParen;
                case 1: return Expressions;
                case 2: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(OpenParen);
                case 1: return nameof(Expressions);
                case 2: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.Scalar;
                case 2: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitExpressionList(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitExpressionList(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ExpressionList((SyntaxToken)OpenParen?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Expression>>)Expressions?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ExpressionList */
    
    #region class ExpressionCouple
    /// <summary>
    /// A node in the kusto syntax that represents a parenthesized pair of expressions.
    /// </summary>
    public sealed partial class ExpressionCouple : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.ExpressionCouple;
        
        /// <summary>
        /// The open parenthesis token.
        /// </summary>
        public SyntaxToken OpenParen { get; }
        
        /// <summary>
        /// The first expression.
        /// </summary>
        public Expression First { get; }
        
        /// <summary>
        /// The .. token.
        /// </summary>
        public SyntaxToken DotDot { get; }
        
        /// <summary>
        /// The second expression.
        /// </summary>
        public Expression Second { get; }
        
        /// <summary>
        /// The close parenthesis token.
        /// </summary>
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ExpressionCouple"/>.
        /// </summary>
        internal ExpressionCouple(SyntaxToken openParen, Expression first, SyntaxToken dotDot, Expression second, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.OpenParen = Attach(openParen);
            this.First = Attach(first);
            this.DotDot = Attach(dotDot);
            this.Second = Attach(second);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 5;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return OpenParen;
                case 1: return First;
                case 2: return DotDot;
                case 3: return Second;
                case 4: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(OpenParen);
                case 1: return nameof(First);
                case 2: return nameof(DotDot);
                case 3: return nameof(Second);
                case 4: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.Scalar;
                case 2: return CompletionHint.Syntax;
                case 3: return CompletionHint.Scalar;
                case 4: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitExpressionCouple(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitExpressionCouple(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ExpressionCouple((SyntaxToken)OpenParen?.Clone(includeDiagnostics), (Expression)First?.Clone(includeDiagnostics), (SyntaxToken)DotDot?.Clone(includeDiagnostics), (Expression)Second?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ExpressionCouple */
    
    #region class PrefixUnaryExpression
    /// <summary>
    /// A node in the kusto syntax that represents a prefix unary expression.
    /// </summary>
    public sealed partial class PrefixUnaryExpression : Expression
    {
        private readonly SyntaxKind kind;
        public override SyntaxKind Kind => this.kind;
        
        /// <summary>
        /// The operator token.
        /// </summary>
        public SyntaxToken Operator { get; }
        
        /// <summary>
        /// The expression.
        /// </summary>
        public Expression Expression { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="PrefixUnaryExpression"/>.
        /// </summary>
        internal PrefixUnaryExpression(SyntaxKind kind, SyntaxToken @operator, Expression expression, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.kind = kind;
            this.Operator = Attach(@operator);
            this.Expression = Attach(expression);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Operator;
                case 1: return Expression;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Operator);
                case 1: return nameof(Expression);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitPrefixUnaryExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitPrefixUnaryExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new PrefixUnaryExpression(this.Kind, (SyntaxToken)Operator?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class PrefixUnaryExpression */
    
    #region class BinaryExpression
    /// <summary>
    /// A node in the kusto syntax that represents a binary expression.
    /// </summary>
    public sealed partial class BinaryExpression : Expression
    {
        private readonly SyntaxKind kind;
        public override SyntaxKind Kind => this.kind;
        
        /// <summary>
        /// The left side expression.
        /// </summary>
        public Expression Left { get; }
        
        /// <summary>
        /// The operator token.
        /// </summary>
        public SyntaxToken Operator { get; }
        
        /// <summary>
        /// The right side expression.
        /// </summary>
        public Expression Right { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="BinaryExpression"/>.
        /// </summary>
        internal BinaryExpression(SyntaxKind kind, Expression left, SyntaxToken @operator, Expression right, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.kind = kind;
            this.Left = Attach(left);
            this.Operator = Attach(@operator);
            this.Right = Attach(right);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Left;
                case 1: return Operator;
                case 2: return Right;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Left);
                case 1: return nameof(Operator);
                case 2: return nameof(Right);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 1: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitBinaryExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitBinaryExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new BinaryExpression(this.Kind, (Expression)Left?.Clone(includeDiagnostics), (SyntaxToken)Operator?.Clone(includeDiagnostics), (Expression)Right?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class BinaryExpression */
    
    #region class InExpression
    /// <summary>
    /// A node in the kusto syntax that represents an in expression.
    /// </summary>
    public sealed partial class InExpression : Expression
    {
        private readonly SyntaxKind kind;
        public override SyntaxKind Kind => this.kind;
        
        /// <summary>
        /// The left side expression.
        /// </summary>
        public Expression Left { get; }
        
        /// <summary>
        /// The in or !in keyword.
        /// </summary>
        public SyntaxToken Operator { get; }
        
        /// <summary>
        /// The list of expressions.
        /// </summary>
        public ExpressionList Right { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="InExpression"/>.
        /// </summary>
        internal InExpression(SyntaxKind kind, Expression left, SyntaxToken @operator, ExpressionList right, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.kind = kind;
            this.Left = Attach(left);
            this.Operator = Attach(@operator);
            this.Right = Attach(right);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Left;
                case 1: return Operator;
                case 2: return Right;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Left);
                case 1: return nameof(Operator);
                case 2: return nameof(Right);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitInExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitInExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new InExpression(this.Kind, (Expression)Left?.Clone(includeDiagnostics), (SyntaxToken)Operator?.Clone(includeDiagnostics), (ExpressionList)Right?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class InExpression */
    
    #region class HasAnyExpression
    /// <summary>
    /// A node in the kusto syntax that represents a has_any expression.
    /// </summary>
    public sealed partial class HasAnyExpression : Expression
    {
        private readonly SyntaxKind kind;
        public override SyntaxKind Kind => this.kind;
        
        /// <summary>
        /// The left side expression.
        /// </summary>
        public Expression Left { get; }
        
        /// <summary>
        /// The has_any keyword.
        /// </summary>
        public SyntaxToken Operator { get; }
        
        /// <summary>
        /// The list of expressions.
        /// </summary>
        public ExpressionList Right { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="HasAnyExpression"/>.
        /// </summary>
        internal HasAnyExpression(SyntaxKind kind, Expression left, SyntaxToken @operator, ExpressionList right, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.kind = kind;
            this.Left = Attach(left);
            this.Operator = Attach(@operator);
            this.Right = Attach(right);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Left;
                case 1: return Operator;
                case 2: return Right;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Left);
                case 1: return nameof(Operator);
                case 2: return nameof(Right);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitHasAnyExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitHasAnyExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new HasAnyExpression(this.Kind, (Expression)Left?.Clone(includeDiagnostics), (SyntaxToken)Operator?.Clone(includeDiagnostics), (ExpressionList)Right?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class HasAnyExpression */
    
    #region class HasAllExpression
    /// <summary>
    /// A node in the kusto syntax that represents a has_all expression.
    /// </summary>
    public sealed partial class HasAllExpression : Expression
    {
        private readonly SyntaxKind kind;
        public override SyntaxKind Kind => this.kind;
        
        /// <summary>
        /// The left side expression.
        /// </summary>
        public Expression Left { get; }
        
        /// <summary>
        /// The has_all keyword.
        /// </summary>
        public SyntaxToken Operator { get; }
        
        /// <summary>
        /// The list of expressions.
        /// </summary>
        public ExpressionList Right { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="HasAllExpression"/>.
        /// </summary>
        internal HasAllExpression(SyntaxKind kind, Expression left, SyntaxToken @operator, ExpressionList right, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.kind = kind;
            this.Left = Attach(left);
            this.Operator = Attach(@operator);
            this.Right = Attach(right);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Left;
                case 1: return Operator;
                case 2: return Right;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Left);
                case 1: return nameof(Operator);
                case 2: return nameof(Right);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitHasAllExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitHasAllExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new HasAllExpression(this.Kind, (Expression)Left?.Clone(includeDiagnostics), (SyntaxToken)Operator?.Clone(includeDiagnostics), (ExpressionList)Right?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class HasAllExpression */
    
    #region class BetweenExpression
    /// <summary>
    /// A node in the kusto syntax that represents a between expression.
    /// </summary>
    public sealed partial class BetweenExpression : Expression
    {
        private readonly SyntaxKind kind;
        public override SyntaxKind Kind => this.kind;
        
        /// <summary>
        /// The left side expression.
        /// </summary>
        public Expression Left { get; }
        
        /// <summary>
        /// The between or !between keyword.
        /// </summary>
        public SyntaxToken Operator { get; }
        
        /// <summary>
        /// The list of expressions.
        /// </summary>
        public ExpressionCouple Right { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="BetweenExpression"/>.
        /// </summary>
        internal BetweenExpression(SyntaxKind kind, Expression left, SyntaxToken @operator, ExpressionCouple right, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.kind = kind;
            this.Left = Attach(left);
            this.Operator = Attach(@operator);
            this.Right = Attach(right);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Left;
                case 1: return Operator;
                case 2: return Right;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Left);
                case 1: return nameof(Operator);
                case 2: return nameof(Right);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 1: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitBetweenExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitBetweenExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new BetweenExpression(this.Kind, (Expression)Left?.Clone(includeDiagnostics), (SyntaxToken)Operator?.Clone(includeDiagnostics), (ExpressionCouple)Right?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class BetweenExpression */
    
    #region class FunctionCallExpression
    /// <summary>
    /// A node in the kusto syntax that represents a function call expression.
    /// </summary>
    public sealed partial class FunctionCallExpression : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.FunctionCallExpression;
        
        /// <summary>
        /// The name of the function call.
        /// </summary>
        public NameReference Name { get; }
        
        /// <summary>
        /// The arguments
        /// </summary>
        public ExpressionList ArgumentList { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="FunctionCallExpression"/>.
        /// </summary>
        internal FunctionCallExpression(NameReference name, ExpressionList argumentList, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Name = Attach(name);
            this.ArgumentList = Attach(argumentList);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Name;
                case 1: return ArgumentList;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Name);
                case 1: return nameof(ArgumentList);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Function;
                case 1: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitFunctionCallExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitFunctionCallExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new FunctionCallExpression((NameReference)Name?.Clone(includeDiagnostics), (ExpressionList)ArgumentList?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class FunctionCallExpression */
    
    #region class ToScalarExpression
    /// <summary>
    /// A node in the Kusto syntax that represents the toscalar operation.
    /// </summary>
    public sealed partial class ToScalarExpression : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.ToScalarExpression;
        
        public SyntaxToken ToScalar { get; }
        
        public NamedParameter KindParameter { get; }
        
        public SyntaxToken OpenParen { get; }
        
        public Expression Expression { get; }
        
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ToScalarExpression"/>.
        /// </summary>
        internal ToScalarExpression(SyntaxToken toScalar, NamedParameter kindParameter, SyntaxToken openParen, Expression expression, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.ToScalar = Attach(toScalar);
            this.KindParameter = Attach(kindParameter, optional: true);
            this.OpenParen = Attach(openParen);
            this.Expression = Attach(expression);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 5;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return ToScalar;
                case 1: return KindParameter;
                case 2: return OpenParen;
                case 3: return Expression;
                case 4: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(ToScalar);
                case 1: return nameof(KindParameter);
                case 2: return nameof(OpenParen);
                case 3: return nameof(Expression);
                case 4: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 1:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 1: return CompletionHint.Clause;
                case 2: return CompletionHint.Syntax;
                case 3: return CompletionHint.NonScalar;
                case 4: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitToScalarExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitToScalarExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ToScalarExpression((SyntaxToken)ToScalar?.Clone(includeDiagnostics), (NamedParameter)KindParameter?.Clone(includeDiagnostics), (SyntaxToken)OpenParen?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ToScalarExpression */
    
    #region class ToTableExpression
    /// <summary>
    /// A node in the Kusto syntax that represents the totable operation.
    /// </summary>
    public sealed partial class ToTableExpression : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.ToTableExpression;
        
        public SyntaxToken ToTable { get; }
        
        public NamedParameter KindParameter { get; }
        
        public SyntaxToken OpenParen { get; }
        
        public Expression Expression { get; }
        
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ToTableExpression"/>.
        /// </summary>
        internal ToTableExpression(SyntaxToken toTable, NamedParameter kindParameter, SyntaxToken openParen, Expression expression, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.ToTable = Attach(toTable);
            this.KindParameter = Attach(kindParameter, optional: true);
            this.OpenParen = Attach(openParen);
            this.Expression = Attach(expression);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 5;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return ToTable;
                case 1: return KindParameter;
                case 2: return OpenParen;
                case 3: return Expression;
                case 4: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(ToTable);
                case 1: return nameof(KindParameter);
                case 2: return nameof(OpenParen);
                case 3: return nameof(Expression);
                case 4: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 1:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 1: return CompletionHint.Clause;
                case 2: return CompletionHint.Syntax;
                case 3: return CompletionHint.Scalar;
                case 4: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitToTableExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitToTableExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ToTableExpression((SyntaxToken)ToTable?.Clone(includeDiagnostics), (NamedParameter)KindParameter?.Clone(includeDiagnostics), (SyntaxToken)OpenParen?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ToTableExpression */
    
    #region class MaterializedViewCombineExpression
    /// <summary>
    /// A node in the Kusto syntax that represents the materilized-view-combine expression.
    /// </summary>
    public sealed partial class MaterializedViewCombineExpression : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.MaterializedViewCombineExpression;
        
        public SyntaxToken MaterializedViewCombineKeyword { get; }
        
        public MaterializedViewCombineNameClause ViewName { get; }
        
        public MaterializedViewCombineClause BaseClause { get; }
        
        public MaterializedViewCombineClause DeltaClause { get; }
        
        public MaterializedViewCombineClause AggregationsClause { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="MaterializedViewCombineExpression"/>.
        /// </summary>
        internal MaterializedViewCombineExpression(SyntaxToken materializedViewCombineKeyword, MaterializedViewCombineNameClause viewName, MaterializedViewCombineClause baseClause, MaterializedViewCombineClause deltaClause, MaterializedViewCombineClause aggregationsClause, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.MaterializedViewCombineKeyword = Attach(materializedViewCombineKeyword);
            this.ViewName = Attach(viewName);
            this.BaseClause = Attach(baseClause);
            this.DeltaClause = Attach(deltaClause);
            this.AggregationsClause = Attach(aggregationsClause);
            this.Init();
        }
        
        public override int ChildCount => 5;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return MaterializedViewCombineKeyword;
                case 1: return ViewName;
                case 2: return BaseClause;
                case 3: return DeltaClause;
                case 4: return AggregationsClause;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(MaterializedViewCombineKeyword);
                case 1: return nameof(ViewName);
                case 2: return nameof(BaseClause);
                case 3: return nameof(DeltaClause);
                case 4: return nameof(AggregationsClause);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Syntax;
                case 3: return CompletionHint.Syntax;
                case 4: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitMaterializedViewCombineExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitMaterializedViewCombineExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new MaterializedViewCombineExpression((SyntaxToken)MaterializedViewCombineKeyword?.Clone(includeDiagnostics), (MaterializedViewCombineNameClause)ViewName?.Clone(includeDiagnostics), (MaterializedViewCombineClause)BaseClause?.Clone(includeDiagnostics), (MaterializedViewCombineClause)DeltaClause?.Clone(includeDiagnostics), (MaterializedViewCombineClause)AggregationsClause?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class MaterializedViewCombineExpression */
    
    #region class MaterializedViewCombineNameClause
    /// <summary>
    /// A node in the Kusto syntax that represents the materilized-view-combine view name part.
    /// </summary>
    public sealed partial class MaterializedViewCombineNameClause : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.MaterializedViewCombineExpression;
        
        public SyntaxToken OpenParen { get; }
        
        public Expression Value { get; }
        
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="MaterializedViewCombineNameClause"/>.
        /// </summary>
        internal MaterializedViewCombineNameClause(SyntaxToken openParen, Expression value, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.OpenParen = Attach(openParen);
            this.Value = Attach(value);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return OpenParen;
                case 1: return Value;
                case 2: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(OpenParen);
                case 1: return nameof(Value);
                case 2: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.Literal;
                case 2: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitMaterializedViewCombineNameClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitMaterializedViewCombineNameClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new MaterializedViewCombineNameClause((SyntaxToken)OpenParen?.Clone(includeDiagnostics), (Expression)Value?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class MaterializedViewCombineNameClause */
    
    #region class MaterializedViewCombineClause
    /// <summary>
    /// A node in the Kusto syntax that represents the materilized-view-combine clause.
    /// </summary>
    public sealed partial class MaterializedViewCombineClause : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.MaterializedViewCombineClause;
        
        public SyntaxToken Keyword { get; }
        
        public SyntaxToken OpenParen { get; }
        
        public Expression Expression { get; }
        
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="MaterializedViewCombineClause"/>.
        /// </summary>
        internal MaterializedViewCombineClause(SyntaxToken keyword, SyntaxToken openParen, Expression expression, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Keyword = Attach(keyword);
            this.OpenParen = Attach(openParen);
            this.Expression = Attach(expression);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 4;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Keyword;
                case 1: return OpenParen;
                case 2: return Expression;
                case 3: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Keyword);
                case 1: return nameof(OpenParen);
                case 2: return nameof(Expression);
                case 3: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Syntax;
                case 3: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitMaterializedViewCombineClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitMaterializedViewCombineClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new MaterializedViewCombineClause((SyntaxToken)Keyword?.Clone(includeDiagnostics), (SyntaxToken)OpenParen?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class MaterializedViewCombineClause */
    
    #region class NamedExpression
    /// <summary>
    /// A node in the Kusto syntax that represents a named expression.
    /// </summary>
    public abstract partial class NamedExpression : Expression
    {
        /// <summary>
        /// Constructs a new instance of <see cref="NamedExpression"/>.
        /// </summary>
        internal NamedExpression(IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
        }
    }
    #endregion /* class NamedExpression */
    
    #region class SimpleNamedExpression
    /// <summary>
    /// A node in the kusto syntax that represents a named expression.
    /// </summary>
    public sealed partial class SimpleNamedExpression : NamedExpression
    {
        public override SyntaxKind Kind => SyntaxKind.SimpleNamedExpression;
        
        /// <summary>
        /// The name of the expression.
        /// </summary>
        public NameDeclaration Name { get; }
        
        /// <summary>
        /// The equal token.
        /// </summary>
        public SyntaxToken EqualToken { get; }
        
        /// <summary>
        /// The named expression.
        /// </summary>
        public Expression Expression { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="SimpleNamedExpression"/>.
        /// </summary>
        internal SimpleNamedExpression(NameDeclaration name, SyntaxToken equalToken, Expression expression, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Name = Attach(name);
            this.EqualToken = Attach(equalToken);
            this.Expression = Attach(expression);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Name;
                case 1: return EqualToken;
                case 2: return Expression;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Name);
                case 1: return nameof(EqualToken);
                case 2: return nameof(Expression);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Declaration;
                case 1: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitSimpleNamedExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitSimpleNamedExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new SimpleNamedExpression((NameDeclaration)Name?.Clone(includeDiagnostics), (SyntaxToken)EqualToken?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class SimpleNamedExpression */
    
    #region class RenameList
    /// <summary>
    /// A node in the kusto syntax that represents a parenthesized list of names.
    /// </summary>
    public sealed partial class RenameList : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.RenameList;
        
        /// <summary>
        /// The open parenthesis token.
        /// </summary>
        public SyntaxToken OpenParen { get; }
        
        /// <summary>
        /// The list of name declarations.
        /// </summary>
        public SyntaxList<SeparatedElement<NameDeclaration>> Names { get; }
        
        /// <summary>
        /// The close parenthesis token.
        /// </summary>
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="RenameList"/>.
        /// </summary>
        internal RenameList(SyntaxToken openParen, SyntaxList<SeparatedElement<NameDeclaration>> names, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.OpenParen = Attach(openParen);
            this.Names = Attach(names);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return OpenParen;
                case 1: return Names;
                case 2: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(OpenParen);
                case 1: return nameof(Names);
                case 2: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.Declaration;
                case 2: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitRenameList(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitRenameList(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new RenameList((SyntaxToken)OpenParen?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<NameDeclaration>>)Names?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class RenameList */
    
    #region class CompoundNamedExpression
    /// <summary>
    /// A node in the kusto syntax that represents a compound named expression.
    /// </summary>
    public sealed partial class CompoundNamedExpression : NamedExpression
    {
        public override SyntaxKind Kind => SyntaxKind.CompoundNamedExpression;
        
        /// <summary>
        /// The set of names or keywords.
        /// </summary>
        public RenameList Names { get; }
        
        /// <summary>
        /// The equal token.
        /// </summary>
        public SyntaxToken EqualToken { get; }
        
        /// <summary>
        /// The named expression.
        /// </summary>
        public Expression Expression { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="CompoundNamedExpression"/>.
        /// </summary>
        internal CompoundNamedExpression(RenameList names, SyntaxToken equalToken, Expression expression, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Names = Attach(names);
            this.EqualToken = Attach(equalToken);
            this.Expression = Attach(expression);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Names;
                case 1: return EqualToken;
                case 2: return Expression;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Names);
                case 1: return nameof(EqualToken);
                case 2: return nameof(Expression);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitCompoundNamedExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitCompoundNamedExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new CompoundNamedExpression((RenameList)Names?.Clone(includeDiagnostics), (SyntaxToken)EqualToken?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class CompoundNamedExpression */
    
    #region class BracketedExpression
    public sealed partial class BracketedExpression : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.BracketedExpression;
        
        public SyntaxToken OpenBracket { get; }
        
        public Expression Expression { get; }
        
        public SyntaxToken CloseBracket { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="BracketedExpression"/>.
        /// </summary>
        internal BracketedExpression(SyntaxToken openBracket, Expression expression, SyntaxToken closeBracket, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.OpenBracket = Attach(openBracket);
            this.Expression = Attach(expression);
            this.CloseBracket = Attach(closeBracket);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return OpenBracket;
                case 1: return Expression;
                case 2: return CloseBracket;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(OpenBracket);
                case 1: return nameof(Expression);
                case 2: return nameof(CloseBracket);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.Literal;
                case 2: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitBracketedExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitBracketedExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new BracketedExpression((SyntaxToken)OpenBracket?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (SyntaxToken)CloseBracket?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class BracketedExpression */
    
    #region class PathExpression
    public sealed partial class PathExpression : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.PathExpression;
        
        public Expression Expression { get; }
        
        public SyntaxToken Dot { get; }
        
        public Expression Selector { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="PathExpression"/>.
        /// </summary>
        internal PathExpression(Expression expression, SyntaxToken dot, Expression selector, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Expression = Attach(expression);
            this.Dot = Attach(dot, optional: true);
            this.Selector = Attach(selector);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Expression;
                case 1: return Dot;
                case 2: return Selector;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Expression);
                case 1: return nameof(Dot);
                case 2: return nameof(Selector);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 1:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Expression;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitPathExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitPathExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new PathExpression((Expression)Expression?.Clone(includeDiagnostics), (SyntaxToken)Dot?.Clone(includeDiagnostics), (Expression)Selector?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class PathExpression */
    
    #region class ElementExpression
    public sealed partial class ElementExpression : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.ElementExpression;
        
        public Expression Expression { get; }
        
        public Expression Selector { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ElementExpression"/>.
        /// </summary>
        internal ElementExpression(Expression expression, Expression selector, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Expression = Attach(expression);
            this.Selector = Attach(selector);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Expression;
                case 1: return Selector;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Expression);
                case 1: return nameof(Selector);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 1: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitElementExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitElementExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ElementExpression((Expression)Expression?.Clone(includeDiagnostics), (Expression)Selector?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ElementExpression */
    
    #region class PipeExpression
    public sealed partial class PipeExpression : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.PipeExpression;
        
        public Expression Expression { get; }
        
        public SyntaxToken Bar { get; }
        
        public QueryOperator Operator { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="PipeExpression"/>.
        /// </summary>
        internal PipeExpression(Expression expression, SyntaxToken bar, QueryOperator @operator, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Expression = Attach(expression);
            this.Bar = Attach(bar);
            this.Operator = Attach(@operator);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Expression;
                case 1: return Bar;
                case 2: return Operator;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Expression);
                case 1: return nameof(Bar);
                case 2: return nameof(Operator);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.NonScalar;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Query;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitPipeExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitPipeExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new PipeExpression((Expression)Expression?.Clone(includeDiagnostics), (SyntaxToken)Bar?.Clone(includeDiagnostics), (QueryOperator)Operator?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class PipeExpression */
    
    #region class RangeOperator
    public sealed partial class RangeOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.RangeOperator;
        
        public SyntaxToken RangeToken { get; }
        
        public NameDeclaration Name { get; }
        
        public SyntaxToken FromToken { get; }
        
        public Expression From { get; }
        
        public SyntaxToken ToToken { get; }
        
        public Expression To { get; }
        
        public SyntaxToken StepToken { get; }
        
        public Expression Step { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="RangeOperator"/>.
        /// </summary>
        internal RangeOperator(SyntaxToken rangeToken, NameDeclaration name, SyntaxToken fromToken, Expression from, SyntaxToken toToken, Expression to, SyntaxToken stepToken, Expression step, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.RangeToken = Attach(rangeToken);
            this.Name = Attach(name);
            this.FromToken = Attach(fromToken);
            this.From = Attach(from);
            this.ToToken = Attach(toToken);
            this.To = Attach(to);
            this.StepToken = Attach(stepToken);
            this.Step = Attach(step);
            this.Init();
        }
        
        public override int ChildCount => 8;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return RangeToken;
                case 1: return Name;
                case 2: return FromToken;
                case 3: return From;
                case 4: return ToToken;
                case 5: return To;
                case 6: return StepToken;
                case 7: return Step;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(RangeToken);
                case 1: return nameof(Name);
                case 2: return nameof(FromToken);
                case 3: return nameof(From);
                case 4: return nameof(ToToken);
                case 5: return nameof(To);
                case 6: return nameof(StepToken);
                case 7: return nameof(Step);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Declaration;
                case 2: return CompletionHint.Keyword;
                case 3: return CompletionHint.Scalar;
                case 4: return CompletionHint.Keyword;
                case 5: return CompletionHint.Scalar;
                case 6: return CompletionHint.Keyword;
                case 7: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitRangeOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitRangeOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new RangeOperator((SyntaxToken)RangeToken?.Clone(includeDiagnostics), (NameDeclaration)Name?.Clone(includeDiagnostics), (SyntaxToken)FromToken?.Clone(includeDiagnostics), (Expression)From?.Clone(includeDiagnostics), (SyntaxToken)ToToken?.Clone(includeDiagnostics), (Expression)To?.Clone(includeDiagnostics), (SyntaxToken)StepToken?.Clone(includeDiagnostics), (Expression)Step?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class RangeOperator */
    
    #region class NamedParameter
    public sealed partial class NamedParameter : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.NamedParameter;
        
        public NameDeclaration Name { get; }
        
        public SyntaxToken EqualToken { get; }
        
        public Expression Expression { get; }
        
        public CompletionHint ExpressionHint { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="NamedParameter"/>.
        /// </summary>
        internal NamedParameter(NameDeclaration name, SyntaxToken equalToken, Expression expression, CompletionHint expressionHint = CompletionHint.None, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Name = Attach(name);
            this.EqualToken = Attach(equalToken);
            this.Expression = Attach(expression);
            this.ExpressionHint = expressionHint;
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Name;
                case 1: return EqualToken;
                case 2: return Expression;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Name);
                case 1: return nameof(EqualToken);
                case 2: return nameof(Expression);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Declaration;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.None;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitNamedParameter(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitNamedParameter(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new NamedParameter((NameDeclaration)Name?.Clone(includeDiagnostics), (SyntaxToken)EqualToken?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), ExpressionHint, (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class NamedParameter */
    
    #region class ConsumeOperator
    public sealed partial class ConsumeOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.ConsumeOperator;
        
        public SyntaxToken ConsumeKeyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ConsumeOperator"/>.
        /// </summary>
        internal ConsumeOperator(SyntaxToken consumeKeyword, SyntaxList<NamedParameter> parameters, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.ConsumeKeyword = Attach(consumeKeyword);
            this.Parameters = Attach(parameters);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return ConsumeKeyword;
                case 1: return Parameters;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(ConsumeKeyword);
                case 1: return nameof(Parameters);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.None;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitConsumeOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitConsumeOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ConsumeOperator((SyntaxToken)ConsumeKeyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ConsumeOperator */
    
    #region class CountOperator
    public sealed partial class CountOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.CountOperator;
        
        public SyntaxToken CountKeyword { get; }
        
        public CountAsIdentifierClause AsIdentifier { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="CountOperator"/>.
        /// </summary>
        internal CountOperator(SyntaxToken countKeyword, CountAsIdentifierClause asIdentifier, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.CountKeyword = Attach(countKeyword);
            this.AsIdentifier = Attach(asIdentifier, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return CountKeyword;
                case 1: return AsIdentifier;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(CountKeyword);
                case 1: return nameof(AsIdentifier);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 1:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Clause;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitCountOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitCountOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new CountOperator((SyntaxToken)CountKeyword?.Clone(includeDiagnostics), (CountAsIdentifierClause)AsIdentifier?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class CountOperator */
    
    #region class CountAsIdentifierClause
    public sealed partial class CountAsIdentifierClause : Clause
    {
        public override SyntaxKind Kind => SyntaxKind.CountAsIdentifierClause;
        
        public SyntaxToken AsKeyword { get; }
        
        public SyntaxToken Identifier { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="CountAsIdentifierClause"/>.
        /// </summary>
        internal CountAsIdentifierClause(SyntaxToken asKeyword, SyntaxToken identifier, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.AsKeyword = Attach(asKeyword);
            this.Identifier = Attach(identifier);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return AsKeyword;
                case 1: return Identifier;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(AsKeyword);
                case 1: return nameof(Identifier);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Declaration;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitCountAsIdentifierClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitCountAsIdentifierClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new CountAsIdentifierClause((SyntaxToken)AsKeyword?.Clone(includeDiagnostics), (SyntaxToken)Identifier?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class CountAsIdentifierClause */
    
    #region class ExecuteAndCacheOperator
    public sealed partial class ExecuteAndCacheOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.ExecuteAndCacheOperator;
        
        public SyntaxToken ExecuteAndCacheKeyword { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ExecuteAndCacheOperator"/>.
        /// </summary>
        internal ExecuteAndCacheOperator(SyntaxToken executeAndCacheKeyword, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.ExecuteAndCacheKeyword = Attach(executeAndCacheKeyword);
            this.Init();
        }
        
        public override int ChildCount => 1;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return ExecuteAndCacheKeyword;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(ExecuteAndCacheKeyword);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitExecuteAndCacheOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitExecuteAndCacheOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ExecuteAndCacheOperator((SyntaxToken)ExecuteAndCacheKeyword?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ExecuteAndCacheOperator */
    
    #region class ExtendOperator
    public sealed partial class ExtendOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.ExtendOperator;
        
        public SyntaxToken ExtendKeyword { get; }
        
        public SyntaxList<SeparatedElement<Expression>> Expressions { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ExtendOperator"/>.
        /// </summary>
        internal ExtendOperator(SyntaxToken extendKeyword, SyntaxList<SeparatedElement<Expression>> expressions, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.ExtendKeyword = Attach(extendKeyword);
            this.Expressions = Attach(expressions);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return ExtendKeyword;
                case 1: return Expressions;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(ExtendKeyword);
                case 1: return nameof(Expressions);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitExtendOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitExtendOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ExtendOperator((SyntaxToken)ExtendKeyword?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Expression>>)Expressions?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ExtendOperator */
    
    #region class FacetOperator
    public sealed partial class FacetOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.FacetOperator;
        
        public SyntaxToken FacetKeyword { get; }
        
        public SyntaxToken ByKeyword { get; }
        
        public SyntaxList<SeparatedElement<Expression>> Expressions { get; }
        
        public FacetWithClause WithClause { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="FacetOperator"/>.
        /// </summary>
        internal FacetOperator(SyntaxToken facetKeyword, SyntaxToken byKeyword, SyntaxList<SeparatedElement<Expression>> expressions, FacetWithClause withClause, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.FacetKeyword = Attach(facetKeyword);
            this.ByKeyword = Attach(byKeyword);
            this.Expressions = Attach(expressions);
            this.WithClause = Attach(withClause, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 4;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return FacetKeyword;
                case 1: return ByKeyword;
                case 2: return Expressions;
                case 3: return WithClause;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(FacetKeyword);
                case 1: return nameof(ByKeyword);
                case 2: return nameof(Expressions);
                case 3: return nameof(WithClause);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 3:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Keyword;
                case 2: return CompletionHint.Scalar;
                case 3: return CompletionHint.Clause;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitFacetOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitFacetOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new FacetOperator((SyntaxToken)FacetKeyword?.Clone(includeDiagnostics), (SyntaxToken)ByKeyword?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Expression>>)Expressions?.Clone(includeDiagnostics), (FacetWithClause)WithClause?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class FacetOperator */
    
    #region class FacetWithClause
    public abstract partial class FacetWithClause : Clause
    {
        /// <summary>
        /// Constructs a new instance of <see cref="FacetWithClause"/>.
        /// </summary>
        internal FacetWithClause(IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
        }
    }
    #endregion /* class FacetWithClause */
    
    #region class FacetWithOperatorClause
    public sealed partial class FacetWithOperatorClause : FacetWithClause
    {
        public override SyntaxKind Kind => SyntaxKind.FacetWithOperatorClause;
        
        public SyntaxToken WithKeyword { get; }
        
        public QueryOperator Operator { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="FacetWithOperatorClause"/>.
        /// </summary>
        internal FacetWithOperatorClause(SyntaxToken withKeyword, QueryOperator @operator, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.WithKeyword = Attach(withKeyword);
            this.Operator = Attach(@operator);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return WithKeyword;
                case 1: return Operator;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(WithKeyword);
                case 1: return nameof(Operator);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Query;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitFacetWithOperatorClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitFacetWithOperatorClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new FacetWithOperatorClause((SyntaxToken)WithKeyword?.Clone(includeDiagnostics), (QueryOperator)Operator?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class FacetWithOperatorClause */
    
    #region class FacetWithExpressionClause
    public sealed partial class FacetWithExpressionClause : FacetWithClause
    {
        public override SyntaxKind Kind => SyntaxKind.FacetWithExpressionClause;
        
        public SyntaxToken WithKeyword { get; }
        
        public SyntaxToken OpenParen { get; }
        
        public Expression Expression { get; }
        
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="FacetWithExpressionClause"/>.
        /// </summary>
        internal FacetWithExpressionClause(SyntaxToken withKeyword, SyntaxToken openParen, Expression expression, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.WithKeyword = Attach(withKeyword);
            this.OpenParen = Attach(openParen);
            this.Expression = Attach(expression);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 4;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return WithKeyword;
                case 1: return OpenParen;
                case 2: return Expression;
                case 3: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(WithKeyword);
                case 1: return nameof(OpenParen);
                case 2: return nameof(Expression);
                case 3: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Query;
                case 3: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitFacetWithExpressionClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitFacetWithExpressionClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new FacetWithExpressionClause((SyntaxToken)WithKeyword?.Clone(includeDiagnostics), (SyntaxToken)OpenParen?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class FacetWithExpressionClause */
    
    #region class FilterOperator
    public sealed partial class FilterOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.FilterOperator;
        
        public SyntaxToken Keyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public Expression Condition { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="FilterOperator"/>.
        /// </summary>
        internal FilterOperator(SyntaxToken keyword, SyntaxList<NamedParameter> parameters, Expression condition, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Keyword = Attach(keyword);
            this.Parameters = Attach(parameters);
            this.Condition = Attach(condition);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Keyword;
                case 1: return Parameters;
                case 2: return Condition;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Keyword);
                case 1: return nameof(Parameters);
                case 2: return nameof(Condition);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.None;
                case 2: return CompletionHint.Boolean;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitFilterOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitFilterOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new FilterOperator((SyntaxToken)Keyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (Expression)Condition?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class FilterOperator */
    
    #region class GetSchemaOperator
    public sealed partial class GetSchemaOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.GetSchemaOperator;
        
        public SyntaxToken GetSchemaKeyword { get; }
        
        public NamedParameter KindParameter { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="GetSchemaOperator"/>.
        /// </summary>
        internal GetSchemaOperator(SyntaxToken getSchemaKeyword, NamedParameter kindParameter, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.GetSchemaKeyword = Attach(getSchemaKeyword);
            this.KindParameter = Attach(kindParameter, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return GetSchemaKeyword;
                case 1: return KindParameter;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(GetSchemaKeyword);
                case 1: return nameof(KindParameter);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 1:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Clause;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitGetSchemaOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitGetSchemaOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new GetSchemaOperator((SyntaxToken)GetSchemaKeyword?.Clone(includeDiagnostics), (NamedParameter)KindParameter?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class GetSchemaOperator */
    
    #region class FindOperator
    public sealed partial class FindOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.FindOperator;
        
        public SyntaxToken FindKeyword { get; }
        
        public DataScopeClause DataScope { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public FindInClause InClause { get; }
        
        public SyntaxToken WhereKeyword { get; }
        
        public Expression Condition { get; }
        
        public FindProjectClause Project { get; }
        
        public FindProjectClause ProjectAway { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="FindOperator"/>.
        /// </summary>
        internal FindOperator(SyntaxToken findKeyword, DataScopeClause dataScope, SyntaxList<NamedParameter> parameters, FindInClause inClause, SyntaxToken whereKeyword, Expression condition, FindProjectClause project, FindProjectClause projectAway, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.FindKeyword = Attach(findKeyword);
            this.DataScope = Attach(dataScope, optional: true);
            this.Parameters = Attach(parameters);
            this.InClause = Attach(inClause, optional: true);
            this.WhereKeyword = Attach(whereKeyword, optional: true);
            this.Condition = Attach(condition);
            this.Project = Attach(project, optional: true);
            this.ProjectAway = Attach(projectAway, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 8;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return FindKeyword;
                case 1: return DataScope;
                case 2: return Parameters;
                case 3: return InClause;
                case 4: return WhereKeyword;
                case 5: return Condition;
                case 6: return Project;
                case 7: return ProjectAway;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(FindKeyword);
                case 1: return nameof(DataScope);
                case 2: return nameof(Parameters);
                case 3: return nameof(InClause);
                case 4: return nameof(WhereKeyword);
                case 5: return nameof(Condition);
                case 6: return nameof(Project);
                case 7: return nameof(ProjectAway);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 1:
                case 3:
                case 4:
                case 6:
                case 7:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Clause;
                case 2: return CompletionHint.None;
                case 3: return CompletionHint.Clause;
                case 4: return CompletionHint.Keyword;
                case 5: return CompletionHint.Boolean;
                case 6: return CompletionHint.Clause;
                case 7: return CompletionHint.Clause;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitFindOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitFindOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new FindOperator((SyntaxToken)FindKeyword?.Clone(includeDiagnostics), (DataScopeClause)DataScope?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (FindInClause)InClause?.Clone(includeDiagnostics), (SyntaxToken)WhereKeyword?.Clone(includeDiagnostics), (Expression)Condition?.Clone(includeDiagnostics), (FindProjectClause)Project?.Clone(includeDiagnostics), (FindProjectClause)ProjectAway?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class FindOperator */
    
    #region class DataScopeClause
    public sealed partial class DataScopeClause : Clause
    {
        public override SyntaxKind Kind => SyntaxKind.DataScopeClause;
        
        public SyntaxToken DataScopeKeyword { get; }
        
        public SyntaxToken EqualToken { get; }
        
        public SyntaxToken Value { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="DataScopeClause"/>.
        /// </summary>
        internal DataScopeClause(SyntaxToken dataScopeKeyword, SyntaxToken equalToken, SyntaxToken value, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.DataScopeKeyword = Attach(dataScopeKeyword);
            this.EqualToken = Attach(equalToken);
            this.Value = Attach(value);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return DataScopeKeyword;
                case 1: return EqualToken;
                case 2: return Value;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(DataScopeKeyword);
                case 1: return nameof(EqualToken);
                case 2: return nameof(Value);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Keyword;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitDataScopeClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitDataScopeClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new DataScopeClause((SyntaxToken)DataScopeKeyword?.Clone(includeDiagnostics), (SyntaxToken)EqualToken?.Clone(includeDiagnostics), (SyntaxToken)Value?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class DataScopeClause */
    
    #region class TypedColumnReference
    public sealed partial class TypedColumnReference : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.TypedColumnReference;
        
        public NameReference Column { get; }
        
        public SyntaxToken ColonToken { get; }
        
        public TypeExpression Type { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="TypedColumnReference"/>.
        /// </summary>
        internal TypedColumnReference(NameReference column, SyntaxToken colonToken, TypeExpression type, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Column = Attach(column);
            this.ColonToken = Attach(colonToken);
            this.Type = Attach(type);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Column;
                case 1: return ColonToken;
                case 2: return Type;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Column);
                case 1: return nameof(ColonToken);
                case 2: return nameof(Type);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Column;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitTypedColumnReference(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitTypedColumnReference(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new TypedColumnReference((NameReference)Column?.Clone(includeDiagnostics), (SyntaxToken)ColonToken?.Clone(includeDiagnostics), (TypeExpression)Type?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class TypedColumnReference */
    
    #region class FindInClause
    public sealed partial class FindInClause : Clause
    {
        public override SyntaxKind Kind => SyntaxKind.FindInClause;
        
        public SyntaxToken InKeyword { get; }
        
        public SyntaxToken OpenParen { get; }
        
        public SyntaxList<SeparatedElement<Expression>> Expressions { get; }
        
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="FindInClause"/>.
        /// </summary>
        internal FindInClause(SyntaxToken inKeyword, SyntaxToken openParen, SyntaxList<SeparatedElement<Expression>> expressions, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.InKeyword = Attach(inKeyword);
            this.OpenParen = Attach(openParen);
            this.Expressions = Attach(expressions);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 4;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return InKeyword;
                case 1: return OpenParen;
                case 2: return Expressions;
                case 3: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(InKeyword);
                case 1: return nameof(OpenParen);
                case 2: return nameof(Expressions);
                case 3: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.NonScalar;
                case 3: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitFindInClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitFindInClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new FindInClause((SyntaxToken)InKeyword?.Clone(includeDiagnostics), (SyntaxToken)OpenParen?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Expression>>)Expressions?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class FindInClause */
    
    #region class FindProjectClause
    public sealed partial class FindProjectClause : Clause
    {
        public override SyntaxKind Kind => SyntaxKind.FindProjectClause;
        
        public SyntaxToken ProjectKeyword { get; }
        
        public SyntaxList<SeparatedElement<Expression>> Columns { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="FindProjectClause"/>.
        /// </summary>
        internal FindProjectClause(SyntaxToken projectKeyword, SyntaxList<SeparatedElement<Expression>> columns, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.ProjectKeyword = Attach(projectKeyword);
            this.Columns = Attach(columns);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return ProjectKeyword;
                case 1: return Columns;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(ProjectKeyword);
                case 1: return nameof(Columns);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitFindProjectClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitFindProjectClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new FindProjectClause((SyntaxToken)ProjectKeyword?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Expression>>)Columns?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class FindProjectClause */
    
    #region class PackExpression
    public sealed partial class PackExpression : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.PackExpression;
        
        public SyntaxToken PackKeyword { get; }
        
        public SyntaxToken OpenParen { get; }
        
        public SyntaxToken AsteriskToken { get; }
        
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="PackExpression"/>.
        /// </summary>
        internal PackExpression(SyntaxToken packKeyword, SyntaxToken openParen, SyntaxToken asteriskToken, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.PackKeyword = Attach(packKeyword);
            this.OpenParen = Attach(openParen);
            this.AsteriskToken = Attach(asteriskToken);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 4;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return PackKeyword;
                case 1: return OpenParen;
                case 2: return AsteriskToken;
                case 3: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(PackKeyword);
                case 1: return nameof(OpenParen);
                case 2: return nameof(AsteriskToken);
                case 3: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Syntax;
                case 3: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitPackExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitPackExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new PackExpression((SyntaxToken)PackKeyword?.Clone(includeDiagnostics), (SyntaxToken)OpenParen?.Clone(includeDiagnostics), (SyntaxToken)AsteriskToken?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class PackExpression */
    
    #region class NameAndTypeDeclaration
    public sealed partial class NameAndTypeDeclaration : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.NameAndTypeDeclaration;
        
        public NameDeclaration Name { get; }
        
        public SyntaxToken Colon { get; }
        
        public TypeExpression Type { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="NameAndTypeDeclaration"/>.
        /// </summary>
        internal NameAndTypeDeclaration(NameDeclaration name, SyntaxToken colon, TypeExpression type, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Name = Attach(name);
            this.Colon = Attach(colon);
            this.Type = Attach(type);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Name;
                case 1: return Colon;
                case 2: return Type;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Name);
                case 1: return nameof(Colon);
                case 2: return nameof(Type);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Declaration;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitNameAndTypeDeclaration(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitNameAndTypeDeclaration(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new NameAndTypeDeclaration((NameDeclaration)Name?.Clone(includeDiagnostics), (SyntaxToken)Colon?.Clone(includeDiagnostics), (TypeExpression)Type?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class NameAndTypeDeclaration */
    
    #region class TypeExpression
    public abstract partial class TypeExpression : Expression
    {
        /// <summary>
        /// Constructs a new instance of <see cref="TypeExpression"/>.
        /// </summary>
        internal TypeExpression(IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
        }
    }
    #endregion /* class TypeExpression */
    
    #region class PrimitiveTypeExpression
    public sealed partial class PrimitiveTypeExpression : TypeExpression
    {
        public override SyntaxKind Kind => SyntaxKind.PrimitiveTypeExpression;
        
        public SyntaxToken Type { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="PrimitiveTypeExpression"/>.
        /// </summary>
        internal PrimitiveTypeExpression(SyntaxToken type, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Type = Attach(type);
            this.Init();
        }
        
        public override int ChildCount => 1;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Type;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Type);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitPrimitiveTypeExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitPrimitiveTypeExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new PrimitiveTypeExpression((SyntaxToken)Type?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class PrimitiveTypeExpression */
    
    #region class SearchOperator
    public sealed partial class SearchOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.SearchOperator;
        
        public SyntaxToken SearchKeyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public DataScopeClause DataScope { get; }
        
        public FindInClause InClause { get; }
        
        public Expression Condition { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="SearchOperator"/>.
        /// </summary>
        internal SearchOperator(SyntaxToken searchKeyword, SyntaxList<NamedParameter> parameters, DataScopeClause dataScope, FindInClause inClause, Expression condition, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.SearchKeyword = Attach(searchKeyword);
            this.Parameters = Attach(parameters);
            this.DataScope = Attach(dataScope, optional: true);
            this.InClause = Attach(inClause, optional: true);
            this.Condition = Attach(condition);
            this.Init();
        }
        
        public override int ChildCount => 5;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return SearchKeyword;
                case 1: return Parameters;
                case 2: return DataScope;
                case 3: return InClause;
                case 4: return Condition;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(SearchKeyword);
                case 1: return nameof(Parameters);
                case 2: return nameof(DataScope);
                case 3: return nameof(InClause);
                case 4: return nameof(Condition);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 2:
                case 3:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.None;
                case 2: return CompletionHint.Clause;
                case 3: return CompletionHint.Clause;
                case 4: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitSearchOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitSearchOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new SearchOperator((SyntaxToken)SearchKeyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (DataScopeClause)DataScope?.Clone(includeDiagnostics), (FindInClause)InClause?.Clone(includeDiagnostics), (Expression)Condition?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class SearchOperator */
    
    #region class ForkOperator
    public sealed partial class ForkOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.ForkOperator;
        
        public SyntaxToken ForkKeyword { get; }
        
        public SyntaxList<ForkExpression> Expressions { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ForkOperator"/>.
        /// </summary>
        internal ForkOperator(SyntaxToken forkKeyword, SyntaxList<ForkExpression> expressions, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.ForkKeyword = Attach(forkKeyword);
            this.Expressions = Attach(expressions);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return ForkKeyword;
                case 1: return Expressions;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(ForkKeyword);
                case 1: return nameof(Expressions);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.NonScalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitForkOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitForkOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ForkOperator((SyntaxToken)ForkKeyword?.Clone(includeDiagnostics), (SyntaxList<ForkExpression>)Expressions?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ForkOperator */
    
    #region class NameEqualsClause
    public sealed partial class NameEqualsClause : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.NameEqualsClause;
        
        public NameDeclaration Name { get; }
        
        public SyntaxToken EqualToken { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="NameEqualsClause"/>.
        /// </summary>
        internal NameEqualsClause(NameDeclaration name, SyntaxToken equalToken, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Name = Attach(name);
            this.EqualToken = Attach(equalToken);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Name;
                case 1: return EqualToken;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Name);
                case 1: return nameof(EqualToken);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Declaration;
                case 1: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitNameEqualsClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitNameEqualsClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new NameEqualsClause((NameDeclaration)Name?.Clone(includeDiagnostics), (SyntaxToken)EqualToken?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class NameEqualsClause */
    
    #region class ForkExpression
    public sealed partial class ForkExpression : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.ForkExpression;
        
        public NameEqualsClause NameEquals { get; }
        
        public SyntaxToken OpenParen { get; }
        
        public Expression Expression { get; }
        
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ForkExpression"/>.
        /// </summary>
        internal ForkExpression(NameEqualsClause nameEquals, SyntaxToken openParen, Expression expression, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.NameEquals = Attach(nameEquals, optional: true);
            this.OpenParen = Attach(openParen);
            this.Expression = Attach(expression);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 4;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return NameEquals;
                case 1: return OpenParen;
                case 2: return Expression;
                case 3: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(NameEquals);
                case 1: return nameof(OpenParen);
                case 2: return nameof(Expression);
                case 3: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 0:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Clause;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Clause;
                case 3: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitForkExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitForkExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ForkExpression((NameEqualsClause)NameEquals?.Clone(includeDiagnostics), (SyntaxToken)OpenParen?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ForkExpression */
    
    #region class MakeSeriesOperator
    public sealed partial class MakeSeriesOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.MakeSeriesOperator;
        
        public SyntaxToken MakeSeriesKeyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public SyntaxList<SeparatedElement<MakeSeriesExpression>> Aggregates { get; }
        
        public MakeSeriesOnClause OnClause { get; }
        
        public MakeSeriesRangeClause RangeClause { get; }
        
        public MakeSeriesByClause ByClause { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="MakeSeriesOperator"/>.
        /// </summary>
        internal MakeSeriesOperator(SyntaxToken makeSeriesKeyword, SyntaxList<NamedParameter> parameters, SyntaxList<SeparatedElement<MakeSeriesExpression>> aggregates, MakeSeriesOnClause onClause, MakeSeriesRangeClause rangeClause, MakeSeriesByClause byClause, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.MakeSeriesKeyword = Attach(makeSeriesKeyword);
            this.Parameters = Attach(parameters);
            this.Aggregates = Attach(aggregates);
            this.OnClause = Attach(onClause);
            this.RangeClause = Attach(rangeClause);
            this.ByClause = Attach(byClause, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 6;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return MakeSeriesKeyword;
                case 1: return Parameters;
                case 2: return Aggregates;
                case 3: return OnClause;
                case 4: return RangeClause;
                case 5: return ByClause;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(MakeSeriesKeyword);
                case 1: return nameof(Parameters);
                case 2: return nameof(Aggregates);
                case 3: return nameof(OnClause);
                case 4: return nameof(RangeClause);
                case 5: return nameof(ByClause);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 5:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.None;
                case 2: return CompletionHint.Aggregate;
                case 3: return CompletionHint.Clause;
                case 4: return CompletionHint.Clause;
                case 5: return CompletionHint.Clause;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitMakeSeriesOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitMakeSeriesOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new MakeSeriesOperator((SyntaxToken)MakeSeriesKeyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<MakeSeriesExpression>>)Aggregates?.Clone(includeDiagnostics), (MakeSeriesOnClause)OnClause?.Clone(includeDiagnostics), (MakeSeriesRangeClause)RangeClause?.Clone(includeDiagnostics), (MakeSeriesByClause)ByClause?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class MakeSeriesOperator */
    
    #region class MakeSeriesExpression
    public sealed partial class MakeSeriesExpression : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.MakeSeriesExpression;
        
        public Expression Expression { get; }
        
        public DefaultExpressionClause DefaultExpression { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="MakeSeriesExpression"/>.
        /// </summary>
        internal MakeSeriesExpression(Expression expression, DefaultExpressionClause defaultExpression, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Expression = Attach(expression);
            this.DefaultExpression = Attach(defaultExpression, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Expression;
                case 1: return DefaultExpression;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Expression);
                case 1: return nameof(DefaultExpression);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 1:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Scalar;
                case 1: return CompletionHint.Clause;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitMakeSeriesExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitMakeSeriesExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new MakeSeriesExpression((Expression)Expression?.Clone(includeDiagnostics), (DefaultExpressionClause)DefaultExpression?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class MakeSeriesExpression */
    
    #region class DefaultExpressionClause
    public sealed partial class DefaultExpressionClause : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.DefaultExpressionClause;
        
        public SyntaxToken DefaultKeyword { get; }
        
        public SyntaxToken EqualToken { get; }
        
        public Expression Expression { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="DefaultExpressionClause"/>.
        /// </summary>
        internal DefaultExpressionClause(SyntaxToken defaultKeyword, SyntaxToken equalToken, Expression expression, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.DefaultKeyword = Attach(defaultKeyword);
            this.EqualToken = Attach(equalToken);
            this.Expression = Attach(expression);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return DefaultKeyword;
                case 1: return EqualToken;
                case 2: return Expression;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(DefaultKeyword);
                case 1: return nameof(EqualToken);
                case 2: return nameof(Expression);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Literal;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitDefaultExpressionClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitDefaultExpressionClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new DefaultExpressionClause((SyntaxToken)DefaultKeyword?.Clone(includeDiagnostics), (SyntaxToken)EqualToken?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class DefaultExpressionClause */
    
    #region class MakeSeriesOnClause
    public sealed partial class MakeSeriesOnClause : Clause
    {
        public override SyntaxKind Kind => SyntaxKind.MakeSeriesOnClause;
        
        public SyntaxToken OnKeyword { get; }
        
        public Expression Expression { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="MakeSeriesOnClause"/>.
        /// </summary>
        internal MakeSeriesOnClause(SyntaxToken onKeyword, Expression expression, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.OnKeyword = Attach(onKeyword);
            this.Expression = Attach(expression);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return OnKeyword;
                case 1: return Expression;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(OnKeyword);
                case 1: return nameof(Expression);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitMakeSeriesOnClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitMakeSeriesOnClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new MakeSeriesOnClause((SyntaxToken)OnKeyword?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class MakeSeriesOnClause */
    
    #region class MakeSeriesFromClause
    public sealed partial class MakeSeriesFromClause : Clause
    {
        public override SyntaxKind Kind => SyntaxKind.MakeSeriesFromClause;
        
        public SyntaxToken FromKeyword { get; }
        
        public Expression Expression { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="MakeSeriesFromClause"/>.
        /// </summary>
        internal MakeSeriesFromClause(SyntaxToken fromKeyword, Expression expression, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.FromKeyword = Attach(fromKeyword);
            this.Expression = Attach(expression);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return FromKeyword;
                case 1: return Expression;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(FromKeyword);
                case 1: return nameof(Expression);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitMakeSeriesFromClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitMakeSeriesFromClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new MakeSeriesFromClause((SyntaxToken)FromKeyword?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class MakeSeriesFromClause */
    
    #region class MakeSeriesToClause
    public sealed partial class MakeSeriesToClause : Clause
    {
        public override SyntaxKind Kind => SyntaxKind.MakeSeriesToClause;
        
        public SyntaxToken ToKeyword { get; }
        
        public Expression Expression { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="MakeSeriesToClause"/>.
        /// </summary>
        internal MakeSeriesToClause(SyntaxToken toKeyword, Expression expression, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.ToKeyword = Attach(toKeyword);
            this.Expression = Attach(expression);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return ToKeyword;
                case 1: return Expression;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(ToKeyword);
                case 1: return nameof(Expression);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitMakeSeriesToClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitMakeSeriesToClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new MakeSeriesToClause((SyntaxToken)ToKeyword?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class MakeSeriesToClause */
    
    #region class MakeSeriesStepClause
    public sealed partial class MakeSeriesStepClause : Clause
    {
        public override SyntaxKind Kind => SyntaxKind.MakeSeriesStepClause;
        
        public SyntaxToken StepKeyword { get; }
        
        public Expression Expression { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="MakeSeriesStepClause"/>.
        /// </summary>
        internal MakeSeriesStepClause(SyntaxToken stepKeyword, Expression expression, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.StepKeyword = Attach(stepKeyword);
            this.Expression = Attach(expression);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return StepKeyword;
                case 1: return Expression;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(StepKeyword);
                case 1: return nameof(Expression);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitMakeSeriesStepClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitMakeSeriesStepClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new MakeSeriesStepClause((SyntaxToken)StepKeyword?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class MakeSeriesStepClause */
    
    #region class MakeSeriesRangeClause
    public abstract partial class MakeSeriesRangeClause : Clause
    {
        /// <summary>
        /// Constructs a new instance of <see cref="MakeSeriesRangeClause"/>.
        /// </summary>
        internal MakeSeriesRangeClause(IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
        }
    }
    #endregion /* class MakeSeriesRangeClause */
    
    #region class MakeSeriesInRangeClause
    public sealed partial class MakeSeriesInRangeClause : MakeSeriesRangeClause
    {
        public override SyntaxKind Kind => SyntaxKind.MakeSeriesInRangeClause;
        
        public SyntaxToken InKeyword { get; }
        
        public SyntaxToken RangeKeyword { get; }
        
        public ExpressionList Arguments { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="MakeSeriesInRangeClause"/>.
        /// </summary>
        internal MakeSeriesInRangeClause(SyntaxToken inKeyword, SyntaxToken rangeKeyword, ExpressionList arguments, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.InKeyword = Attach(inKeyword);
            this.RangeKeyword = Attach(rangeKeyword);
            this.Arguments = Attach(arguments);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return InKeyword;
                case 1: return RangeKeyword;
                case 2: return Arguments;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(InKeyword);
                case 1: return nameof(RangeKeyword);
                case 2: return nameof(Arguments);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Keyword;
                case 2: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitMakeSeriesInRangeClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitMakeSeriesInRangeClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new MakeSeriesInRangeClause((SyntaxToken)InKeyword?.Clone(includeDiagnostics), (SyntaxToken)RangeKeyword?.Clone(includeDiagnostics), (ExpressionList)Arguments?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class MakeSeriesInRangeClause */
    
    #region class MakeSeriesFromToStepClause
    public sealed partial class MakeSeriesFromToStepClause : MakeSeriesRangeClause
    {
        public override SyntaxKind Kind => SyntaxKind.MakeSeriesFromToStepClause;
        
        public MakeSeriesFromClause MakeSeriesFromClause { get; }
        
        public MakeSeriesToClause MakeSeriesToClause { get; }
        
        public MakeSeriesStepClause MakeSeriesStepClause { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="MakeSeriesFromToStepClause"/>.
        /// </summary>
        internal MakeSeriesFromToStepClause(MakeSeriesFromClause makeSeriesFromClause, MakeSeriesToClause makeSeriesToClause, MakeSeriesStepClause makeSeriesStepClause, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.MakeSeriesFromClause = Attach(makeSeriesFromClause, optional: true);
            this.MakeSeriesToClause = Attach(makeSeriesToClause, optional: true);
            this.MakeSeriesStepClause = Attach(makeSeriesStepClause);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return MakeSeriesFromClause;
                case 1: return MakeSeriesToClause;
                case 2: return MakeSeriesStepClause;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(MakeSeriesFromClause);
                case 1: return nameof(MakeSeriesToClause);
                case 2: return nameof(MakeSeriesStepClause);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 0:
                case 1:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Clause;
                case 1: return CompletionHint.Clause;
                case 2: return CompletionHint.Clause;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitMakeSeriesFromToStepClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitMakeSeriesFromToStepClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new MakeSeriesFromToStepClause((MakeSeriesFromClause)MakeSeriesFromClause?.Clone(includeDiagnostics), (MakeSeriesToClause)MakeSeriesToClause?.Clone(includeDiagnostics), (MakeSeriesStepClause)MakeSeriesStepClause?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class MakeSeriesFromToStepClause */
    
    #region class MakeSeriesByClause
    public sealed partial class MakeSeriesByClause : Clause
    {
        public override SyntaxKind Kind => SyntaxKind.MakeSeriesByClause;
        
        public SyntaxToken ByKeyword { get; }
        
        public SyntaxList<SeparatedElement<Expression>> Expressions { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="MakeSeriesByClause"/>.
        /// </summary>
        internal MakeSeriesByClause(SyntaxToken byKeyword, SyntaxList<SeparatedElement<Expression>> expressions, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.ByKeyword = Attach(byKeyword);
            this.Expressions = Attach(expressions);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return ByKeyword;
                case 1: return Expressions;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(ByKeyword);
                case 1: return nameof(Expressions);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitMakeSeriesByClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitMakeSeriesByClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new MakeSeriesByClause((SyntaxToken)ByKeyword?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Expression>>)Expressions?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class MakeSeriesByClause */
    
    #region class MvExpandOperator
    public sealed partial class MvExpandOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.MvExpandOperator;
        
        public SyntaxToken MvExpandKeyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public SyntaxList<SeparatedElement<MvExpandExpression>> Expressions { get; }
        
        public MvExpandRowLimitClause RowLimitClause { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="MvExpandOperator"/>.
        /// </summary>
        internal MvExpandOperator(SyntaxToken mvExpandKeyword, SyntaxList<NamedParameter> parameters, SyntaxList<SeparatedElement<MvExpandExpression>> expressions, MvExpandRowLimitClause rowLimitClause, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.MvExpandKeyword = Attach(mvExpandKeyword);
            this.Parameters = Attach(parameters);
            this.Expressions = Attach(expressions);
            this.RowLimitClause = Attach(rowLimitClause, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 4;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return MvExpandKeyword;
                case 1: return Parameters;
                case 2: return Expressions;
                case 3: return RowLimitClause;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(MvExpandKeyword);
                case 1: return nameof(Parameters);
                case 2: return nameof(Expressions);
                case 3: return nameof(RowLimitClause);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 3:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.None;
                case 2: return CompletionHint.Scalar;
                case 3: return CompletionHint.Clause;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitMvExpandOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitMvExpandOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new MvExpandOperator((SyntaxToken)MvExpandKeyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<MvExpandExpression>>)Expressions?.Clone(includeDiagnostics), (MvExpandRowLimitClause)RowLimitClause?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class MvExpandOperator */
    
    #region class MvExpandExpression
    public sealed partial class MvExpandExpression : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.MvExpandExpression;
        
        public Expression Expression { get; }
        
        public ToTypeOfClause ToTypeOf { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="MvExpandExpression"/>.
        /// </summary>
        internal MvExpandExpression(Expression expression, ToTypeOfClause toTypeOf, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Expression = Attach(expression);
            this.ToTypeOf = Attach(toTypeOf, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Expression;
                case 1: return ToTypeOf;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Expression);
                case 1: return nameof(ToTypeOf);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 1:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Scalar;
                case 1: return CompletionHint.Clause;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitMvExpandExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitMvExpandExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new MvExpandExpression((Expression)Expression?.Clone(includeDiagnostics), (ToTypeOfClause)ToTypeOf?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class MvExpandExpression */
    
    #region class MvExpandRowLimitClause
    public sealed partial class MvExpandRowLimitClause : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.MvExpandRowLimitClause;
        
        public SyntaxToken LimitKeyword { get; }
        
        public Expression RowLimit { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="MvExpandRowLimitClause"/>.
        /// </summary>
        internal MvExpandRowLimitClause(SyntaxToken limitKeyword, Expression rowLimit, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.LimitKeyword = Attach(limitKeyword);
            this.RowLimit = Attach(rowLimit);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return LimitKeyword;
                case 1: return RowLimit;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(LimitKeyword);
                case 1: return nameof(RowLimit);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitMvExpandRowLimitClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitMvExpandRowLimitClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new MvExpandRowLimitClause((SyntaxToken)LimitKeyword?.Clone(includeDiagnostics), (Expression)RowLimit?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class MvExpandRowLimitClause */
    
    #region class MvApplyOperator
    public sealed partial class MvApplyOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.MvApplyOperator;
        
        public SyntaxToken MvApplyKeyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public SyntaxList<SeparatedElement<MvApplyExpression>> Expressions { get; }
        
        public MvApplyRowLimitClause RowLimitClause { get; }
        
        public MvApplyContextIdClause ContextIdClause { get; }
        
        public SyntaxToken OnKeyword { get; }
        
        public MvApplySubqueryExpression Subquery { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="MvApplyOperator"/>.
        /// </summary>
        internal MvApplyOperator(SyntaxToken mvApplyKeyword, SyntaxList<NamedParameter> parameters, SyntaxList<SeparatedElement<MvApplyExpression>> expressions, MvApplyRowLimitClause rowLimitClause, MvApplyContextIdClause contextIdClause, SyntaxToken onKeyword, MvApplySubqueryExpression subquery, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.MvApplyKeyword = Attach(mvApplyKeyword);
            this.Parameters = Attach(parameters);
            this.Expressions = Attach(expressions);
            this.RowLimitClause = Attach(rowLimitClause, optional: true);
            this.ContextIdClause = Attach(contextIdClause, optional: true);
            this.OnKeyword = Attach(onKeyword);
            this.Subquery = Attach(subquery);
            this.Init();
        }
        
        public override int ChildCount => 7;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return MvApplyKeyword;
                case 1: return Parameters;
                case 2: return Expressions;
                case 3: return RowLimitClause;
                case 4: return ContextIdClause;
                case 5: return OnKeyword;
                case 6: return Subquery;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(MvApplyKeyword);
                case 1: return nameof(Parameters);
                case 2: return nameof(Expressions);
                case 3: return nameof(RowLimitClause);
                case 4: return nameof(ContextIdClause);
                case 5: return nameof(OnKeyword);
                case 6: return nameof(Subquery);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 3:
                case 4:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.None;
                case 2: return CompletionHint.Scalar;
                case 3: return CompletionHint.Clause;
                case 4: return CompletionHint.Clause;
                case 5: return CompletionHint.Keyword;
                case 6: return CompletionHint.Clause;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitMvApplyOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitMvApplyOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new MvApplyOperator((SyntaxToken)MvApplyKeyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<MvApplyExpression>>)Expressions?.Clone(includeDiagnostics), (MvApplyRowLimitClause)RowLimitClause?.Clone(includeDiagnostics), (MvApplyContextIdClause)ContextIdClause?.Clone(includeDiagnostics), (SyntaxToken)OnKeyword?.Clone(includeDiagnostics), (MvApplySubqueryExpression)Subquery?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class MvApplyOperator */
    
    #region class MvApplyExpression
    public sealed partial class MvApplyExpression : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.MvApplyExpression;
        
        public Expression Expression { get; }
        
        public ToTypeOfClause ToTypeOf { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="MvApplyExpression"/>.
        /// </summary>
        internal MvApplyExpression(Expression expression, ToTypeOfClause toTypeOf, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Expression = Attach(expression, optional: true);
            this.ToTypeOf = Attach(toTypeOf, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Expression;
                case 1: return ToTypeOf;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Expression);
                case 1: return nameof(ToTypeOf);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 0:
                case 1:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Scalar;
                case 1: return CompletionHint.Clause;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitMvApplyExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitMvApplyExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new MvApplyExpression((Expression)Expression?.Clone(includeDiagnostics), (ToTypeOfClause)ToTypeOf?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class MvApplyExpression */
    
    #region class MvApplyRowLimitClause
    public sealed partial class MvApplyRowLimitClause : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.MvApplyRowLimitClause;
        
        public SyntaxToken LimitKeyword { get; }
        
        public Expression RowLimit { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="MvApplyRowLimitClause"/>.
        /// </summary>
        internal MvApplyRowLimitClause(SyntaxToken limitKeyword, Expression rowLimit, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.LimitKeyword = Attach(limitKeyword);
            this.RowLimit = Attach(rowLimit);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return LimitKeyword;
                case 1: return RowLimit;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(LimitKeyword);
                case 1: return nameof(RowLimit);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitMvApplyRowLimitClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitMvApplyRowLimitClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new MvApplyRowLimitClause((SyntaxToken)LimitKeyword?.Clone(includeDiagnostics), (Expression)RowLimit?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class MvApplyRowLimitClause */
    
    #region class MvApplyContextIdClause
    public sealed partial class MvApplyContextIdClause : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.MvApplyContextIdClause;
        
        public SyntaxToken IdKeyword { get; }
        
        public Expression Id { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="MvApplyContextIdClause"/>.
        /// </summary>
        internal MvApplyContextIdClause(SyntaxToken idKeyword, Expression id, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.IdKeyword = Attach(idKeyword);
            this.Id = Attach(id);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return IdKeyword;
                case 1: return Id;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(IdKeyword);
                case 1: return nameof(Id);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitMvApplyContextIdClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitMvApplyContextIdClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new MvApplyContextIdClause((SyntaxToken)IdKeyword?.Clone(includeDiagnostics), (Expression)Id?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class MvApplyContextIdClause */
    
    #region class MvApplySubqueryExpression
    public sealed partial class MvApplySubqueryExpression : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.MvApplySubqueryExpression;
        
        public SyntaxToken OpenParen { get; }
        
        public Expression Expression { get; }
        
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="MvApplySubqueryExpression"/>.
        /// </summary>
        internal MvApplySubqueryExpression(SyntaxToken openParen, Expression expression, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.OpenParen = Attach(openParen);
            this.Expression = Attach(expression);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return OpenParen;
                case 1: return Expression;
                case 2: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(OpenParen);
                case 1: return nameof(Expression);
                case 2: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.Query;
                case 2: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitMvApplySubqueryExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitMvApplySubqueryExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new MvApplySubqueryExpression((SyntaxToken)OpenParen?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class MvApplySubqueryExpression */
    
    #region class ToTypeOfClause
    public sealed partial class ToTypeOfClause : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.ToTypeOfClause;
        
        public SyntaxToken ToKeyword { get; }
        
        public TypeOfLiteralExpression TypeOf { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ToTypeOfClause"/>.
        /// </summary>
        internal ToTypeOfClause(SyntaxToken toKeyword, TypeOfLiteralExpression typeOf, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.ToKeyword = Attach(toKeyword);
            this.TypeOf = Attach(typeOf);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return ToKeyword;
                case 1: return TypeOf;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(ToKeyword);
                case 1: return nameof(TypeOf);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Keyword;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitToTypeOfClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitToTypeOfClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ToTypeOfClause((SyntaxToken)ToKeyword?.Clone(includeDiagnostics), (TypeOfLiteralExpression)TypeOf?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ToTypeOfClause */
    
    #region class EvaluateSchemaClause
    public sealed partial class EvaluateSchemaClause : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.EvaluateSchemaClause;
        
        public SyntaxToken ColonToken { get; }
        
        public EvaluateRowSchema Schema { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="EvaluateSchemaClause"/>.
        /// </summary>
        internal EvaluateSchemaClause(SyntaxToken colonToken, EvaluateRowSchema schema, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.ColonToken = Attach(colonToken);
            this.Schema = Attach(schema, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return ColonToken;
                case 1: return Schema;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(ColonToken);
                case 1: return nameof(Schema);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 1:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitEvaluateSchemaClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitEvaluateSchemaClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new EvaluateSchemaClause((SyntaxToken)ColonToken?.Clone(includeDiagnostics), (EvaluateRowSchema)Schema?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class EvaluateSchemaClause */
    
    #region class EvaluateOperator
    public sealed partial class EvaluateOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.EvaluateOperator;
        
        public SyntaxToken EvaluateKeyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public FunctionCallExpression FunctionCall { get; }
        
        public EvaluateSchemaClause Schema { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="EvaluateOperator"/>.
        /// </summary>
        internal EvaluateOperator(SyntaxToken evaluateKeyword, SyntaxList<NamedParameter> parameters, FunctionCallExpression functionCall, EvaluateSchemaClause schema, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.EvaluateKeyword = Attach(evaluateKeyword);
            this.Parameters = Attach(parameters);
            this.FunctionCall = Attach(functionCall);
            this.Schema = Attach(schema, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 4;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return EvaluateKeyword;
                case 1: return Parameters;
                case 2: return FunctionCall;
                case 3: return Schema;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(EvaluateKeyword);
                case 1: return nameof(Parameters);
                case 2: return nameof(FunctionCall);
                case 3: return nameof(Schema);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 3:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.None;
                case 2: return CompletionHint.Function;
                case 3: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitEvaluateOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitEvaluateOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new EvaluateOperator((SyntaxToken)EvaluateKeyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (FunctionCallExpression)FunctionCall?.Clone(includeDiagnostics), (EvaluateSchemaClause)Schema?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class EvaluateOperator */
    
    #region class ParseOperator
    public sealed partial class ParseOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.ParseOperator;
        
        public SyntaxToken ParseKeyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public Expression Expression { get; }
        
        public SyntaxToken WithKeyword { get; }
        
        public SyntaxList<SyntaxNode> Patterns { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ParseOperator"/>.
        /// </summary>
        internal ParseOperator(SyntaxToken parseKeyword, SyntaxList<NamedParameter> parameters, Expression expression, SyntaxToken withKeyword, SyntaxList<SyntaxNode> patterns, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.ParseKeyword = Attach(parseKeyword);
            this.Parameters = Attach(parameters);
            this.Expression = Attach(expression);
            this.WithKeyword = Attach(withKeyword);
            this.Patterns = Attach(patterns);
            this.Init();
        }
        
        public override int ChildCount => 5;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return ParseKeyword;
                case 1: return Parameters;
                case 2: return Expression;
                case 3: return WithKeyword;
                case 4: return Patterns;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(ParseKeyword);
                case 1: return nameof(Parameters);
                case 2: return nameof(Expression);
                case 3: return nameof(WithKeyword);
                case 4: return nameof(Patterns);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.None;
                case 2: return CompletionHint.Scalar;
                case 3: return CompletionHint.Keyword;
                case 4: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitParseOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitParseOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ParseOperator((SyntaxToken)ParseKeyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (SyntaxToken)WithKeyword?.Clone(includeDiagnostics), (SyntaxList<SyntaxNode>)Patterns?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ParseOperator */
    
    #region class ParseWhereOperator
    public sealed partial class ParseWhereOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.ParseWhereOperator;
        
        public SyntaxToken ParseKeyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public Expression Expression { get; }
        
        public SyntaxToken WithKeyword { get; }
        
        public SyntaxList<SyntaxNode> Patterns { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ParseWhereOperator"/>.
        /// </summary>
        internal ParseWhereOperator(SyntaxToken parseKeyword, SyntaxList<NamedParameter> parameters, Expression expression, SyntaxToken withKeyword, SyntaxList<SyntaxNode> patterns, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.ParseKeyword = Attach(parseKeyword);
            this.Parameters = Attach(parameters);
            this.Expression = Attach(expression);
            this.WithKeyword = Attach(withKeyword);
            this.Patterns = Attach(patterns);
            this.Init();
        }
        
        public override int ChildCount => 5;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return ParseKeyword;
                case 1: return Parameters;
                case 2: return Expression;
                case 3: return WithKeyword;
                case 4: return Patterns;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(ParseKeyword);
                case 1: return nameof(Parameters);
                case 2: return nameof(Expression);
                case 3: return nameof(WithKeyword);
                case 4: return nameof(Patterns);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.None;
                case 2: return CompletionHint.Scalar;
                case 3: return CompletionHint.Keyword;
                case 4: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitParseWhereOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitParseWhereOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ParseWhereOperator((SyntaxToken)ParseKeyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (SyntaxToken)WithKeyword?.Clone(includeDiagnostics), (SyntaxList<SyntaxNode>)Patterns?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ParseWhereOperator */
    
    #region class ParseKvWithClause
    public sealed partial class ParseKvWithClause : Clause
    {
        public override SyntaxKind Kind => SyntaxKind.ParseKvWithClause;
        
        public SyntaxToken WithKeyword { get; }
        
        public SyntaxToken OpenParen { get; }
        
        public SyntaxList<SeparatedElement<NamedParameter>> Properties { get; }
        
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ParseKvWithClause"/>.
        /// </summary>
        internal ParseKvWithClause(SyntaxToken withKeyword, SyntaxToken openParen, SyntaxList<SeparatedElement<NamedParameter>> properties, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.WithKeyword = Attach(withKeyword);
            this.OpenParen = Attach(openParen);
            this.Properties = Attach(properties);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 4;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return WithKeyword;
                case 1: return OpenParen;
                case 2: return Properties;
                case 3: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(WithKeyword);
                case 1: return nameof(OpenParen);
                case 2: return nameof(Properties);
                case 3: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.None;
                case 3: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitParseKvWithClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitParseKvWithClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ParseKvWithClause((SyntaxToken)WithKeyword?.Clone(includeDiagnostics), (SyntaxToken)OpenParen?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<NamedParameter>>)Properties?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ParseKvWithClause */
    
    #region class ParseKvOperator
    public sealed partial class ParseKvOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.ParseKvOperator;
        
        public SyntaxToken ParseKvKeyword { get; }
        
        public Expression Expression { get; }
        
        public SyntaxToken AsKeyword { get; }
        
        public RowSchema Keys { get; }
        
        public ParseKvWithClause WithClause { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ParseKvOperator"/>.
        /// </summary>
        internal ParseKvOperator(SyntaxToken parseKvKeyword, Expression expression, SyntaxToken asKeyword, RowSchema keys, ParseKvWithClause withClause, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.ParseKvKeyword = Attach(parseKvKeyword);
            this.Expression = Attach(expression);
            this.AsKeyword = Attach(asKeyword);
            this.Keys = Attach(keys);
            this.WithClause = Attach(withClause, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 5;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return ParseKvKeyword;
                case 1: return Expression;
                case 2: return AsKeyword;
                case 3: return Keys;
                case 4: return WithClause;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(ParseKvKeyword);
                case 1: return nameof(Expression);
                case 2: return nameof(AsKeyword);
                case 3: return nameof(Keys);
                case 4: return nameof(WithClause);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 4:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Scalar;
                case 2: return CompletionHint.Keyword;
                case 3: return CompletionHint.Syntax;
                case 4: return CompletionHint.Clause;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitParseKvOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitParseKvOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ParseKvOperator((SyntaxToken)ParseKvKeyword?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (SyntaxToken)AsKeyword?.Clone(includeDiagnostics), (RowSchema)Keys?.Clone(includeDiagnostics), (ParseKvWithClause)WithClause?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ParseKvOperator */
    
    #region class PartitionOperator
    public sealed partial class PartitionOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.PartitionOperator;
        
        public SyntaxToken PartitionKeyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public SyntaxToken ByKeyword { get; }
        
        public Expression ByExpression { get; }
        
        public PartitionScope Scope { get; }
        
        public PartitionOperand Operand { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="PartitionOperator"/>.
        /// </summary>
        internal PartitionOperator(SyntaxToken partitionKeyword, SyntaxList<NamedParameter> parameters, SyntaxToken byKeyword, Expression byExpression, PartitionScope scope, PartitionOperand operand, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.PartitionKeyword = Attach(partitionKeyword);
            this.Parameters = Attach(parameters);
            this.ByKeyword = Attach(byKeyword);
            this.ByExpression = Attach(byExpression);
            this.Scope = Attach(scope, optional: true);
            this.Operand = Attach(operand);
            this.Init();
        }
        
        public override int ChildCount => 6;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return PartitionKeyword;
                case 1: return Parameters;
                case 2: return ByKeyword;
                case 3: return ByExpression;
                case 4: return Scope;
                case 5: return Operand;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(PartitionKeyword);
                case 1: return nameof(Parameters);
                case 2: return nameof(ByKeyword);
                case 3: return nameof(ByExpression);
                case 4: return nameof(Scope);
                case 5: return nameof(Operand);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 4:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.None;
                case 2: return CompletionHint.Keyword;
                case 3: return CompletionHint.Scalar;
                case 4: return CompletionHint.Syntax;
                case 5: return CompletionHint.NonScalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitPartitionOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitPartitionOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new PartitionOperator((SyntaxToken)PartitionKeyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (SyntaxToken)ByKeyword?.Clone(includeDiagnostics), (Expression)ByExpression?.Clone(includeDiagnostics), (PartitionScope)Scope?.Clone(includeDiagnostics), (PartitionOperand)Operand?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class PartitionOperator */
    
    #region class PartitionOperand
    public abstract partial class PartitionOperand : Expression
    {
        /// <summary>
        /// Constructs a new instance of <see cref="PartitionOperand"/>.
        /// </summary>
        internal PartitionOperand(IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
        }
    }
    #endregion /* class PartitionOperand */
    
    #region class PartitionQuery
    public sealed partial class PartitionQuery : PartitionOperand
    {
        public override SyntaxKind Kind => SyntaxKind.PartitionQuery;
        
        public SyntaxToken OpenBrace { get; }
        
        public Expression Query { get; }
        
        public SyntaxToken CloseBrace { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="PartitionQuery"/>.
        /// </summary>
        internal PartitionQuery(SyntaxToken openBrace, Expression query, SyntaxToken closeBrace, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.OpenBrace = Attach(openBrace);
            this.Query = Attach(query);
            this.CloseBrace = Attach(closeBrace);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return OpenBrace;
                case 1: return Query;
                case 2: return CloseBrace;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(OpenBrace);
                case 1: return nameof(Query);
                case 2: return nameof(CloseBrace);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.NonScalar;
                case 2: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitPartitionQuery(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitPartitionQuery(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new PartitionQuery((SyntaxToken)OpenBrace?.Clone(includeDiagnostics), (Expression)Query?.Clone(includeDiagnostics), (SyntaxToken)CloseBrace?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class PartitionQuery */
    
    #region class PartitionScope
    public sealed partial class PartitionScope : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.PartitionScope;
        
        public SyntaxToken InKeyword { get; }
        
        public Expression Expression { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="PartitionScope"/>.
        /// </summary>
        internal PartitionScope(SyntaxToken inKeyword, Expression expression, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.InKeyword = Attach(inKeyword);
            this.Expression = Attach(expression);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return InKeyword;
                case 1: return Expression;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(InKeyword);
                case 1: return nameof(Expression);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitPartitionScope(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitPartitionScope(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new PartitionScope((SyntaxToken)InKeyword?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class PartitionScope */
    
    #region class PartitionSubquery
    public sealed partial class PartitionSubquery : PartitionOperand
    {
        public override SyntaxKind Kind => SyntaxKind.PartitionSubquery;
        
        public SyntaxToken OpenParen { get; }
        
        public Expression Subquery { get; }
        
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="PartitionSubquery"/>.
        /// </summary>
        internal PartitionSubquery(SyntaxToken openParen, Expression subquery, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.OpenParen = Attach(openParen);
            this.Subquery = Attach(subquery);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return OpenParen;
                case 1: return Subquery;
                case 2: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(OpenParen);
                case 1: return nameof(Subquery);
                case 2: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.Query;
                case 2: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitPartitionSubquery(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitPartitionSubquery(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new PartitionSubquery((SyntaxToken)OpenParen?.Clone(includeDiagnostics), (Expression)Subquery?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class PartitionSubquery */
    
    #region class ProjectOperator
    public sealed partial class ProjectOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.ProjectOperator;
        
        public SyntaxToken ProjectKeyword { get; }
        
        public SyntaxList<SeparatedElement<Expression>> Expressions { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ProjectOperator"/>.
        /// </summary>
        internal ProjectOperator(SyntaxToken projectKeyword, SyntaxList<SeparatedElement<Expression>> expressions, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.ProjectKeyword = Attach(projectKeyword);
            this.Expressions = Attach(expressions);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return ProjectKeyword;
                case 1: return Expressions;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(ProjectKeyword);
                case 1: return nameof(Expressions);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitProjectOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitProjectOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ProjectOperator((SyntaxToken)ProjectKeyword?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Expression>>)Expressions?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ProjectOperator */
    
    #region class ProjectAwayOperator
    public sealed partial class ProjectAwayOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.ProjectAwayOperator;
        
        public SyntaxToken ProjectAwayKeyword { get; }
        
        public SyntaxList<SeparatedElement<Expression>> Expressions { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ProjectAwayOperator"/>.
        /// </summary>
        internal ProjectAwayOperator(SyntaxToken projectAwayKeyword, SyntaxList<SeparatedElement<Expression>> expressions, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.ProjectAwayKeyword = Attach(projectAwayKeyword);
            this.Expressions = Attach(expressions);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return ProjectAwayKeyword;
                case 1: return Expressions;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(ProjectAwayKeyword);
                case 1: return nameof(Expressions);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitProjectAwayOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitProjectAwayOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ProjectAwayOperator((SyntaxToken)ProjectAwayKeyword?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Expression>>)Expressions?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ProjectAwayOperator */
    
    #region class ProjectByNamesOperator
    public sealed partial class ProjectByNamesOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.ProjectByNamesOperator;
        
        public SyntaxToken ProjectByNamesKeyword { get; }
        
        public SyntaxList<SeparatedElement<Expression>> Expressions { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ProjectByNamesOperator"/>.
        /// </summary>
        internal ProjectByNamesOperator(SyntaxToken projectByNamesKeyword, SyntaxList<SeparatedElement<Expression>> expressions, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.ProjectByNamesKeyword = Attach(projectByNamesKeyword);
            this.Expressions = Attach(expressions);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return ProjectByNamesKeyword;
                case 1: return Expressions;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(ProjectByNamesKeyword);
                case 1: return nameof(Expressions);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitProjectByNamesOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitProjectByNamesOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ProjectByNamesOperator((SyntaxToken)ProjectByNamesKeyword?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Expression>>)Expressions?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ProjectByNamesOperator */
    
    #region class ProjectKeepOperator
    public sealed partial class ProjectKeepOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.ProjectKeepOperator;
        
        public SyntaxToken ProjectKeepKeyword { get; }
        
        public SyntaxList<SeparatedElement<Expression>> Expressions { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ProjectKeepOperator"/>.
        /// </summary>
        internal ProjectKeepOperator(SyntaxToken projectKeepKeyword, SyntaxList<SeparatedElement<Expression>> expressions, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.ProjectKeepKeyword = Attach(projectKeepKeyword);
            this.Expressions = Attach(expressions);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return ProjectKeepKeyword;
                case 1: return Expressions;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(ProjectKeepKeyword);
                case 1: return nameof(Expressions);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitProjectKeepOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitProjectKeepOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ProjectKeepOperator((SyntaxToken)ProjectKeepKeyword?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Expression>>)Expressions?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ProjectKeepOperator */
    
    #region class ProjectRenameOperator
    public sealed partial class ProjectRenameOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.ProjectRenameOperator;
        
        public SyntaxToken ProjectRenameKeyword { get; }
        
        public SyntaxList<SeparatedElement<Expression>> Expressions { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ProjectRenameOperator"/>.
        /// </summary>
        internal ProjectRenameOperator(SyntaxToken projectRenameKeyword, SyntaxList<SeparatedElement<Expression>> expressions, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.ProjectRenameKeyword = Attach(projectRenameKeyword);
            this.Expressions = Attach(expressions);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return ProjectRenameKeyword;
                case 1: return Expressions;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(ProjectRenameKeyword);
                case 1: return nameof(Expressions);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitProjectRenameOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitProjectRenameOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ProjectRenameOperator((SyntaxToken)ProjectRenameKeyword?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Expression>>)Expressions?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ProjectRenameOperator */
    
    #region class ProjectReorderOperator
    public sealed partial class ProjectReorderOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.ProjectReorderOperator;
        
        public SyntaxToken ProjectReorderKeyword { get; }
        
        public SyntaxList<SeparatedElement<Expression>> Expressions { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ProjectReorderOperator"/>.
        /// </summary>
        internal ProjectReorderOperator(SyntaxToken projectReorderKeyword, SyntaxList<SeparatedElement<Expression>> expressions, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.ProjectReorderKeyword = Attach(projectReorderKeyword);
            this.Expressions = Attach(expressions);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return ProjectReorderKeyword;
                case 1: return Expressions;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(ProjectReorderKeyword);
                case 1: return nameof(Expressions);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitProjectReorderOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitProjectReorderOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ProjectReorderOperator((SyntaxToken)ProjectReorderKeyword?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Expression>>)Expressions?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ProjectReorderOperator */
    
    #region class SampleOperator
    public sealed partial class SampleOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.SampleOperator;
        
        public SyntaxToken SampleKeyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public Expression Expression { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="SampleOperator"/>.
        /// </summary>
        internal SampleOperator(SyntaxToken sampleKeyword, SyntaxList<NamedParameter> parameters, Expression expression, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.SampleKeyword = Attach(sampleKeyword);
            this.Parameters = Attach(parameters);
            this.Expression = Attach(expression);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return SampleKeyword;
                case 1: return Parameters;
                case 2: return Expression;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(SampleKeyword);
                case 1: return nameof(Parameters);
                case 2: return nameof(Expression);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.None;
                case 2: return CompletionHint.Number;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitSampleOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitSampleOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new SampleOperator((SyntaxToken)SampleKeyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class SampleOperator */
    
    #region class SampleDistinctOperator
    public sealed partial class SampleDistinctOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.SampleDistinctOperator;
        
        public SyntaxToken SampleDistinctKeyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public Expression Expression { get; }
        
        public SyntaxToken OfKeyword { get; }
        
        public Expression OfExpression { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="SampleDistinctOperator"/>.
        /// </summary>
        internal SampleDistinctOperator(SyntaxToken sampleDistinctKeyword, SyntaxList<NamedParameter> parameters, Expression expression, SyntaxToken ofKeyword, Expression ofExpression, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.SampleDistinctKeyword = Attach(sampleDistinctKeyword);
            this.Parameters = Attach(parameters);
            this.Expression = Attach(expression);
            this.OfKeyword = Attach(ofKeyword);
            this.OfExpression = Attach(ofExpression);
            this.Init();
        }
        
        public override int ChildCount => 5;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return SampleDistinctKeyword;
                case 1: return Parameters;
                case 2: return Expression;
                case 3: return OfKeyword;
                case 4: return OfExpression;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(SampleDistinctKeyword);
                case 1: return nameof(Parameters);
                case 2: return nameof(Expression);
                case 3: return nameof(OfKeyword);
                case 4: return nameof(OfExpression);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.None;
                case 2: return CompletionHint.Number;
                case 3: return CompletionHint.Keyword;
                case 4: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitSampleDistinctOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitSampleDistinctOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new SampleDistinctOperator((SyntaxToken)SampleDistinctKeyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (SyntaxToken)OfKeyword?.Clone(includeDiagnostics), (Expression)OfExpression?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class SampleDistinctOperator */
    
    #region class EntityGroup
    public sealed partial class EntityGroup : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.EntityGroupExpression;
        
        public SyntaxToken EntityGroupKeyword { get; }
        
        public SyntaxToken OpenBracket { get; }
        
        public SyntaxList<SeparatedElement<Expression>> Entities { get; }
        
        public SyntaxToken CloseBracket { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="EntityGroup"/>.
        /// </summary>
        internal EntityGroup(SyntaxToken entityGroupKeyword, SyntaxToken openBracket, SyntaxList<SeparatedElement<Expression>> entities, SyntaxToken closeBracket, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.EntityGroupKeyword = Attach(entityGroupKeyword);
            this.OpenBracket = Attach(openBracket);
            this.Entities = Attach(entities);
            this.CloseBracket = Attach(closeBracket);
            this.Init();
        }
        
        public override int ChildCount => 4;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return EntityGroupKeyword;
                case 1: return OpenBracket;
                case 2: return Entities;
                case 3: return CloseBracket;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(EntityGroupKeyword);
                case 1: return nameof(OpenBracket);
                case 2: return nameof(Entities);
                case 3: return nameof(CloseBracket);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Syntax;
                case 3: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitEntityGroup(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitEntityGroup(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new EntityGroup((SyntaxToken)EntityGroupKeyword?.Clone(includeDiagnostics), (SyntaxToken)OpenBracket?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Expression>>)Entities?.Clone(includeDiagnostics), (SyntaxToken)CloseBracket?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class EntityGroup */
    
    #region class ReduceByOperator
    public sealed partial class ReduceByOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.ReduceByOperator;
        
        public SyntaxToken ReduceKeyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public SyntaxToken ByKeyword { get; }
        
        public Expression Expression { get; }
        
        public ReduceByWithClause With { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ReduceByOperator"/>.
        /// </summary>
        internal ReduceByOperator(SyntaxToken reduceKeyword, SyntaxList<NamedParameter> parameters, SyntaxToken byKeyword, Expression expression, ReduceByWithClause with, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.ReduceKeyword = Attach(reduceKeyword);
            this.Parameters = Attach(parameters);
            this.ByKeyword = Attach(byKeyword);
            this.Expression = Attach(expression);
            this.With = Attach(with, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 5;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return ReduceKeyword;
                case 1: return Parameters;
                case 2: return ByKeyword;
                case 3: return Expression;
                case 4: return With;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(ReduceKeyword);
                case 1: return nameof(Parameters);
                case 2: return nameof(ByKeyword);
                case 3: return nameof(Expression);
                case 4: return nameof(With);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 4:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.None;
                case 2: return CompletionHint.Keyword;
                case 3: return CompletionHint.Scalar;
                case 4: return CompletionHint.Clause;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitReduceByOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitReduceByOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ReduceByOperator((SyntaxToken)ReduceKeyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (SyntaxToken)ByKeyword?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (ReduceByWithClause)With?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ReduceByOperator */
    
    #region class ReduceByWithClause
    public sealed partial class ReduceByWithClause : Clause
    {
        public override SyntaxKind Kind => SyntaxKind.ReduceByWithClause;
        
        public SyntaxToken WithKeyword { get; }
        
        public SyntaxList<SeparatedElement<NamedParameter>> Parameters { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ReduceByWithClause"/>.
        /// </summary>
        internal ReduceByWithClause(SyntaxToken withKeyword, SyntaxList<SeparatedElement<NamedParameter>> parameters, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.WithKeyword = Attach(withKeyword);
            this.Parameters = Attach(parameters);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return WithKeyword;
                case 1: return Parameters;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(WithKeyword);
                case 1: return nameof(Parameters);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitReduceByWithClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitReduceByWithClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ReduceByWithClause((SyntaxToken)WithKeyword?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<NamedParameter>>)Parameters?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ReduceByWithClause */
    
    #region class SummarizeOperator
    public sealed partial class SummarizeOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.SummarizeOperator;
        
        public SyntaxToken SummarizeKeyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public SyntaxList<SeparatedElement<Expression>> Aggregates { get; }
        
        public SummarizeByClause ByClause { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="SummarizeOperator"/>.
        /// </summary>
        internal SummarizeOperator(SyntaxToken summarizeKeyword, SyntaxList<NamedParameter> parameters, SyntaxList<SeparatedElement<Expression>> aggregates, SummarizeByClause byClause, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.SummarizeKeyword = Attach(summarizeKeyword);
            this.Parameters = Attach(parameters);
            this.Aggregates = Attach(aggregates);
            this.ByClause = Attach(byClause, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 4;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return SummarizeKeyword;
                case 1: return Parameters;
                case 2: return Aggregates;
                case 3: return ByClause;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(SummarizeKeyword);
                case 1: return nameof(Parameters);
                case 2: return nameof(Aggregates);
                case 3: return nameof(ByClause);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 3:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.None;
                case 2: return CompletionHint.Aggregate;
                case 3: return CompletionHint.Clause;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitSummarizeOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitSummarizeOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new SummarizeOperator((SyntaxToken)SummarizeKeyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Expression>>)Aggregates?.Clone(includeDiagnostics), (SummarizeByClause)ByClause?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class SummarizeOperator */
    
    #region class MacroExpandScopeReferenceName
    public sealed partial class MacroExpandScopeReferenceName : Clause
    {
        public override SyntaxKind Kind => SyntaxKind.MacroExpandScopeReferenceName;
        
        public SyntaxToken AsKeyword { get; }
        
        public NameDeclaration EntityGroupReferenceName { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="MacroExpandScopeReferenceName"/>.
        /// </summary>
        internal MacroExpandScopeReferenceName(SyntaxToken asKeyword, NameDeclaration entityGroupReferenceName, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.AsKeyword = Attach(asKeyword);
            this.EntityGroupReferenceName = Attach(entityGroupReferenceName);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return AsKeyword;
                case 1: return EntityGroupReferenceName;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(AsKeyword);
                case 1: return nameof(EntityGroupReferenceName);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.EntityGroup;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitMacroExpandScopeReferenceName(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitMacroExpandScopeReferenceName(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new MacroExpandScopeReferenceName((SyntaxToken)AsKeyword?.Clone(includeDiagnostics), (NameDeclaration)EntityGroupReferenceName?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class MacroExpandScopeReferenceName */
    
    #region class MacroExpandOperator
    public sealed partial class MacroExpandOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.MacroExpandOperator;
        
        public SyntaxToken MacroExpandKeyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public Expression EntityGroup { get; }
        
        public MacroExpandScopeReferenceName ScopeReferenceName { get; }
        
        public SyntaxToken OpenParen { get; }
        
        public SyntaxList<SeparatedElement<Statement>> StatementList { get; }
        
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="MacroExpandOperator"/>.
        /// </summary>
        internal MacroExpandOperator(SyntaxToken macroExpandKeyword, SyntaxList<NamedParameter> parameters, Expression entityGroup, MacroExpandScopeReferenceName scopeReferenceName, SyntaxToken openParen, SyntaxList<SeparatedElement<Statement>> statementList, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.MacroExpandKeyword = Attach(macroExpandKeyword);
            this.Parameters = Attach(parameters);
            this.EntityGroup = Attach(entityGroup);
            this.ScopeReferenceName = Attach(scopeReferenceName, optional: true);
            this.OpenParen = Attach(openParen);
            this.StatementList = Attach(statementList);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 7;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return MacroExpandKeyword;
                case 1: return Parameters;
                case 2: return EntityGroup;
                case 3: return ScopeReferenceName;
                case 4: return OpenParen;
                case 5: return StatementList;
                case 6: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(MacroExpandKeyword);
                case 1: return nameof(Parameters);
                case 2: return nameof(EntityGroup);
                case 3: return nameof(ScopeReferenceName);
                case 4: return nameof(OpenParen);
                case 5: return nameof(StatementList);
                case 6: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 3:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.None;
                case 2: return CompletionHint.EntityGroup;
                case 3: return CompletionHint.None;
                case 4: return CompletionHint.Keyword;
                case 5: return CompletionHint.NonScalar;
                case 6: return CompletionHint.Keyword;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitMacroExpandOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitMacroExpandOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new MacroExpandOperator((SyntaxToken)MacroExpandKeyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (Expression)EntityGroup?.Clone(includeDiagnostics), (MacroExpandScopeReferenceName)ScopeReferenceName?.Clone(includeDiagnostics), (SyntaxToken)OpenParen?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Statement>>)StatementList?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class MacroExpandOperator */
    
    #region class SummarizeByClause
    public sealed partial class SummarizeByClause : Clause
    {
        public override SyntaxKind Kind => SyntaxKind.SummarizeByClause;
        
        public SyntaxToken ByKeyword { get; }
        
        public SyntaxList<SeparatedElement<Expression>> Expressions { get; }
        
        public NamedExpression BinClause { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="SummarizeByClause"/>.
        /// </summary>
        internal SummarizeByClause(SyntaxToken byKeyword, SyntaxList<SeparatedElement<Expression>> expressions, NamedExpression binClause, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.ByKeyword = Attach(byKeyword);
            this.Expressions = Attach(expressions);
            this.BinClause = Attach(binClause, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return ByKeyword;
                case 1: return Expressions;
                case 2: return BinClause;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(ByKeyword);
                case 1: return nameof(Expressions);
                case 2: return nameof(BinClause);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 2:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Scalar;
                case 2: return CompletionHint.None;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitSummarizeByClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitSummarizeByClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new SummarizeByClause((SyntaxToken)ByKeyword?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Expression>>)Expressions?.Clone(includeDiagnostics), (NamedExpression)BinClause?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class SummarizeByClause */
    
    #region class DistinctOperator
    public sealed partial class DistinctOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.DistinctOperator;
        
        public SyntaxToken DistinctKeyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public SyntaxList<SeparatedElement<Expression>> Expressions { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="DistinctOperator"/>.
        /// </summary>
        internal DistinctOperator(SyntaxToken distinctKeyword, SyntaxList<NamedParameter> parameters, SyntaxList<SeparatedElement<Expression>> expressions, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.DistinctKeyword = Attach(distinctKeyword);
            this.Parameters = Attach(parameters);
            this.Expressions = Attach(expressions);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return DistinctKeyword;
                case 1: return Parameters;
                case 2: return Expressions;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(DistinctKeyword);
                case 1: return nameof(Parameters);
                case 2: return nameof(Expressions);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.None;
                case 2: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitDistinctOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitDistinctOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new DistinctOperator((SyntaxToken)DistinctKeyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Expression>>)Expressions?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class DistinctOperator */
    
    #region class TakeOperator
    public sealed partial class TakeOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.TakeOperator;
        
        public SyntaxToken Keyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public Expression Expression { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="TakeOperator"/>.
        /// </summary>
        internal TakeOperator(SyntaxToken keyword, SyntaxList<NamedParameter> parameters, Expression expression, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Keyword = Attach(keyword);
            this.Parameters = Attach(parameters);
            this.Expression = Attach(expression);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Keyword;
                case 1: return Parameters;
                case 2: return Expression;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Keyword);
                case 1: return nameof(Parameters);
                case 2: return nameof(Expression);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.None;
                case 2: return CompletionHint.Number;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitTakeOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitTakeOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new TakeOperator((SyntaxToken)Keyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class TakeOperator */
    
    #region class SortOperator
    public sealed partial class SortOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.SortOperator;
        
        public SyntaxToken Keyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public SyntaxToken ByKeyword { get; }
        
        public SyntaxList<SeparatedElement<Expression>> Expressions { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="SortOperator"/>.
        /// </summary>
        internal SortOperator(SyntaxToken keyword, SyntaxList<NamedParameter> parameters, SyntaxToken byKeyword, SyntaxList<SeparatedElement<Expression>> expressions, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Keyword = Attach(keyword);
            this.Parameters = Attach(parameters);
            this.ByKeyword = Attach(byKeyword);
            this.Expressions = Attach(expressions);
            this.Init();
        }
        
        public override int ChildCount => 4;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Keyword;
                case 1: return Parameters;
                case 2: return ByKeyword;
                case 3: return Expressions;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Keyword);
                case 1: return nameof(Parameters);
                case 2: return nameof(ByKeyword);
                case 3: return nameof(Expressions);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.None;
                case 2: return CompletionHint.Keyword;
                case 3: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitSortOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitSortOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new SortOperator((SyntaxToken)Keyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (SyntaxToken)ByKeyword?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Expression>>)Expressions?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class SortOperator */
    
    #region class OrderedExpression
    public sealed partial class OrderedExpression : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.OrderedExpression;
        
        public Expression Expression { get; }
        
        public OrderingClause Ordering { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="OrderedExpression"/>.
        /// </summary>
        internal OrderedExpression(Expression expression, OrderingClause ordering, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Expression = Attach(expression);
            this.Ordering = Attach(ordering);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Expression;
                case 1: return Ordering;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Expression);
                case 1: return nameof(Ordering);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Scalar;
                case 1: return CompletionHint.Clause;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitOrderedExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitOrderedExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new OrderedExpression((Expression)Expression?.Clone(includeDiagnostics), (OrderingClause)Ordering?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class OrderedExpression */
    
    #region class OrderingClause
    public sealed partial class OrderingClause : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.OrderingClause;
        
        public SyntaxToken AscOrDescKeyword { get; }
        
        public OrderingNullsClause NullsClause { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="OrderingClause"/>.
        /// </summary>
        internal OrderingClause(SyntaxToken ascOrDescKeyword, OrderingNullsClause nullsClause, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.AscOrDescKeyword = Attach(ascOrDescKeyword, optional: true);
            this.NullsClause = Attach(nullsClause, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return AscOrDescKeyword;
                case 1: return NullsClause;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(AscOrDescKeyword);
                case 1: return nameof(NullsClause);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 0:
                case 1:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Clause;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitOrderingClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitOrderingClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new OrderingClause((SyntaxToken)AscOrDescKeyword?.Clone(includeDiagnostics), (OrderingNullsClause)NullsClause?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class OrderingClause */
    
    #region class OrderingNullsClause
    public sealed partial class OrderingNullsClause : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.OrderingNullsClause;
        
        public SyntaxToken NullsKeyword { get; }
        
        public SyntaxToken FirstOrLastKeyword { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="OrderingNullsClause"/>.
        /// </summary>
        internal OrderingNullsClause(SyntaxToken nullsKeyword, SyntaxToken firstOrLastKeyword, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.NullsKeyword = Attach(nullsKeyword);
            this.FirstOrLastKeyword = Attach(firstOrLastKeyword);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return NullsKeyword;
                case 1: return FirstOrLastKeyword;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(NullsKeyword);
                case 1: return nameof(FirstOrLastKeyword);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Keyword;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitOrderingNullsClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitOrderingNullsClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new OrderingNullsClause((SyntaxToken)NullsKeyword?.Clone(includeDiagnostics), (SyntaxToken)FirstOrLastKeyword?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class OrderingNullsClause */
    
    #region class TopHittersOperator
    public sealed partial class TopHittersOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.TopHittersOperator;
        
        public SyntaxToken TopHittersKeyword { get; }
        
        public Expression Expression { get; }
        
        public SyntaxToken OfKeyword { get; }
        
        public Expression OfExpression { get; }
        
        public TopHittersByClause ByClause { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="TopHittersOperator"/>.
        /// </summary>
        internal TopHittersOperator(SyntaxToken topHittersKeyword, Expression expression, SyntaxToken ofKeyword, Expression ofExpression, TopHittersByClause byClause, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.TopHittersKeyword = Attach(topHittersKeyword);
            this.Expression = Attach(expression);
            this.OfKeyword = Attach(ofKeyword);
            this.OfExpression = Attach(ofExpression);
            this.ByClause = Attach(byClause, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 5;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return TopHittersKeyword;
                case 1: return Expression;
                case 2: return OfKeyword;
                case 3: return OfExpression;
                case 4: return ByClause;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(TopHittersKeyword);
                case 1: return nameof(Expression);
                case 2: return nameof(OfKeyword);
                case 3: return nameof(OfExpression);
                case 4: return nameof(ByClause);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 4:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Number;
                case 2: return CompletionHint.Keyword;
                case 3: return CompletionHint.Scalar;
                case 4: return CompletionHint.Clause;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitTopHittersOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitTopHittersOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new TopHittersOperator((SyntaxToken)TopHittersKeyword?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (SyntaxToken)OfKeyword?.Clone(includeDiagnostics), (Expression)OfExpression?.Clone(includeDiagnostics), (TopHittersByClause)ByClause?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class TopHittersOperator */
    
    #region class TopHittersByClause
    public sealed partial class TopHittersByClause : Clause
    {
        public override SyntaxKind Kind => SyntaxKind.TopHittersByClause;
        
        public SyntaxToken ByKeyword { get; }
        
        public Expression Expression { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="TopHittersByClause"/>.
        /// </summary>
        internal TopHittersByClause(SyntaxToken byKeyword, Expression expression, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.ByKeyword = Attach(byKeyword);
            this.Expression = Attach(expression);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return ByKeyword;
                case 1: return Expression;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(ByKeyword);
                case 1: return nameof(Expression);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitTopHittersByClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitTopHittersByClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new TopHittersByClause((SyntaxToken)ByKeyword?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class TopHittersByClause */
    
    #region class TopOperator
    public sealed partial class TopOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.TopOperator;
        
        public SyntaxToken TopKeyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public Expression Expression { get; }
        
        public SyntaxToken ByKeyword { get; }
        
        public Expression ByExpression { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="TopOperator"/>.
        /// </summary>
        internal TopOperator(SyntaxToken topKeyword, SyntaxList<NamedParameter> parameters, Expression expression, SyntaxToken byKeyword, Expression byExpression, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.TopKeyword = Attach(topKeyword);
            this.Parameters = Attach(parameters);
            this.Expression = Attach(expression);
            this.ByKeyword = Attach(byKeyword);
            this.ByExpression = Attach(byExpression);
            this.Init();
        }
        
        public override int ChildCount => 5;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return TopKeyword;
                case 1: return Parameters;
                case 2: return Expression;
                case 3: return ByKeyword;
                case 4: return ByExpression;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(TopKeyword);
                case 1: return nameof(Parameters);
                case 2: return nameof(Expression);
                case 3: return nameof(ByKeyword);
                case 4: return nameof(ByExpression);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.None;
                case 2: return CompletionHint.Number;
                case 3: return CompletionHint.Keyword;
                case 4: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitTopOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitTopOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new TopOperator((SyntaxToken)TopKeyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (SyntaxToken)ByKeyword?.Clone(includeDiagnostics), (Expression)ByExpression?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class TopOperator */
    
    #region class TopNestedOperator
    public sealed partial class TopNestedOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.TopNestedOperator;
        
        public SyntaxList<SeparatedElement<TopNestedClause>> Clauses { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="TopNestedOperator"/>.
        /// </summary>
        internal TopNestedOperator(SyntaxList<SeparatedElement<TopNestedClause>> clauses, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Clauses = Attach(clauses);
            this.Init();
        }
        
        public override int ChildCount => 1;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Clauses;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Clauses);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Clause;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitTopNestedOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitTopNestedOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new TopNestedOperator((SyntaxList<SeparatedElement<TopNestedClause>>)Clauses?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class TopNestedOperator */
    
    #region class TopNestedClause
    public sealed partial class TopNestedClause : Clause
    {
        public override SyntaxKind Kind => SyntaxKind.TopNestedClause;
        
        public SyntaxToken TopNestedKeyword { get; }
        
        public Expression Expression { get; }
        
        public SyntaxToken OfKeyword { get; }
        
        public Expression OfExpression { get; }
        
        public TopNestedWithOthersClause WithOthersClause { get; }
        
        public SyntaxToken ByKeyword { get; }
        
        public Expression ByExpression { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="TopNestedClause"/>.
        /// </summary>
        internal TopNestedClause(SyntaxToken topNestedKeyword, Expression expression, SyntaxToken ofKeyword, Expression ofExpression, TopNestedWithOthersClause withOthersClause, SyntaxToken byKeyword, Expression byExpression, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.TopNestedKeyword = Attach(topNestedKeyword);
            this.Expression = Attach(expression, optional: true);
            this.OfKeyword = Attach(ofKeyword);
            this.OfExpression = Attach(ofExpression);
            this.WithOthersClause = Attach(withOthersClause, optional: true);
            this.ByKeyword = Attach(byKeyword);
            this.ByExpression = Attach(byExpression);
            this.Init();
        }
        
        public override int ChildCount => 7;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return TopNestedKeyword;
                case 1: return Expression;
                case 2: return OfKeyword;
                case 3: return OfExpression;
                case 4: return WithOthersClause;
                case 5: return ByKeyword;
                case 6: return ByExpression;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(TopNestedKeyword);
                case 1: return nameof(Expression);
                case 2: return nameof(OfKeyword);
                case 3: return nameof(OfExpression);
                case 4: return nameof(WithOthersClause);
                case 5: return nameof(ByKeyword);
                case 6: return nameof(ByExpression);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 1:
                case 4:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Number;
                case 2: return CompletionHint.Keyword;
                case 3: return CompletionHint.Scalar;
                case 4: return CompletionHint.Clause;
                case 5: return CompletionHint.Keyword;
                case 6: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitTopNestedClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitTopNestedClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new TopNestedClause((SyntaxToken)TopNestedKeyword?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (SyntaxToken)OfKeyword?.Clone(includeDiagnostics), (Expression)OfExpression?.Clone(includeDiagnostics), (TopNestedWithOthersClause)WithOthersClause?.Clone(includeDiagnostics), (SyntaxToken)ByKeyword?.Clone(includeDiagnostics), (Expression)ByExpression?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class TopNestedClause */
    
    #region class TopNestedWithOthersClause
    public sealed partial class TopNestedWithOthersClause : Clause
    {
        public override SyntaxKind Kind => SyntaxKind.TopNestedWithOthersClause;
        
        public SyntaxToken WithKeyword { get; }
        
        public SyntaxToken OthersKeyword { get; }
        
        public SyntaxToken Equal { get; }
        
        public Expression Expression { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="TopNestedWithOthersClause"/>.
        /// </summary>
        internal TopNestedWithOthersClause(SyntaxToken withKeyword, SyntaxToken othersKeyword, SyntaxToken equal, Expression expression, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.WithKeyword = Attach(withKeyword);
            this.OthersKeyword = Attach(othersKeyword);
            this.Equal = Attach(equal);
            this.Expression = Attach(expression);
            this.Init();
        }
        
        public override int ChildCount => 4;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return WithKeyword;
                case 1: return OthersKeyword;
                case 2: return Equal;
                case 3: return Expression;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(WithKeyword);
                case 1: return nameof(OthersKeyword);
                case 2: return nameof(Equal);
                case 3: return nameof(Expression);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Keyword;
                case 2: return CompletionHint.Syntax;
                case 3: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitTopNestedWithOthersClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitTopNestedWithOthersClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new TopNestedWithOthersClause((SyntaxToken)WithKeyword?.Clone(includeDiagnostics), (SyntaxToken)OthersKeyword?.Clone(includeDiagnostics), (SyntaxToken)Equal?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class TopNestedWithOthersClause */
    
    #region class UnionOperator
    public sealed partial class UnionOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.UnionOperator;
        
        public SyntaxToken UnionKeyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public SyntaxList<SeparatedElement<Expression>> Expressions { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="UnionOperator"/>.
        /// </summary>
        internal UnionOperator(SyntaxToken unionKeyword, SyntaxList<NamedParameter> parameters, SyntaxList<SeparatedElement<Expression>> expressions, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.UnionKeyword = Attach(unionKeyword);
            this.Parameters = Attach(parameters);
            this.Expressions = Attach(expressions);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return UnionKeyword;
                case 1: return Parameters;
                case 2: return Expressions;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(UnionKeyword);
                case 1: return nameof(Parameters);
                case 2: return nameof(Expressions);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.None;
                case 2: return CompletionHint.NonScalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitUnionOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitUnionOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new UnionOperator((SyntaxToken)UnionKeyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Expression>>)Expressions?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class UnionOperator */
    
    #region class AsOperator
    public sealed partial class AsOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.AsOperator;
        
        public SyntaxToken AsKeyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public NameDeclaration Name { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="AsOperator"/>.
        /// </summary>
        internal AsOperator(SyntaxToken asKeyword, SyntaxList<NamedParameter> parameters, NameDeclaration name, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.AsKeyword = Attach(asKeyword);
            this.Parameters = Attach(parameters);
            this.Name = Attach(name);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return AsKeyword;
                case 1: return Parameters;
                case 2: return Name;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(AsKeyword);
                case 1: return nameof(Parameters);
                case 2: return nameof(Name);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.None;
                case 2: return CompletionHint.Declaration;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitAsOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitAsOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new AsOperator((SyntaxToken)AsKeyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (NameDeclaration)Name?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class AsOperator */
    
    #region class SerializeOperator
    public sealed partial class SerializeOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.SerializeOperator;
        
        public SyntaxToken SerializeKeyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public SyntaxList<SeparatedElement<Expression>> Expressions { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="SerializeOperator"/>.
        /// </summary>
        internal SerializeOperator(SyntaxToken serializeKeyword, SyntaxList<NamedParameter> parameters, SyntaxList<SeparatedElement<Expression>> expressions, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.SerializeKeyword = Attach(serializeKeyword);
            this.Parameters = Attach(parameters);
            this.Expressions = Attach(expressions);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return SerializeKeyword;
                case 1: return Parameters;
                case 2: return Expressions;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(SerializeKeyword);
                case 1: return nameof(Parameters);
                case 2: return nameof(Expressions);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.None;
                case 2: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitSerializeOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitSerializeOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new SerializeOperator((SyntaxToken)SerializeKeyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Expression>>)Expressions?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class SerializeOperator */
    
    #region class InvokeOperator
    public sealed partial class InvokeOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.InvokeOperator;
        
        public SyntaxToken InvokeKeyword { get; }
        
        public Expression Function { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="InvokeOperator"/>.
        /// </summary>
        internal InvokeOperator(SyntaxToken invokeKeyword, Expression function, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.InvokeKeyword = Attach(invokeKeyword);
            this.Function = Attach(function);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return InvokeKeyword;
                case 1: return Function;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(InvokeKeyword);
                case 1: return nameof(Function);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.TabularFunction;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitInvokeOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitInvokeOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new InvokeOperator((SyntaxToken)InvokeKeyword?.Clone(includeDiagnostics), (Expression)Function?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class InvokeOperator */
    
    #region class RenderOperator
    public sealed partial class RenderOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.RenderOperator;
        
        public SyntaxToken RenderKeyword { get; }
        
        public SyntaxToken ChartType { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public RenderWithClause WithClause { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="RenderOperator"/>.
        /// </summary>
        internal RenderOperator(SyntaxToken renderKeyword, SyntaxToken chartType, SyntaxList<NamedParameter> parameters, RenderWithClause withClause, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.RenderKeyword = Attach(renderKeyword);
            this.ChartType = Attach(chartType, optional: true);
            this.Parameters = Attach(parameters);
            this.WithClause = Attach(withClause, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 4;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return RenderKeyword;
                case 1: return ChartType;
                case 2: return Parameters;
                case 3: return WithClause;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(RenderKeyword);
                case 1: return nameof(ChartType);
                case 2: return nameof(Parameters);
                case 3: return nameof(WithClause);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 1:
                case 3:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Keyword;
                case 2: return CompletionHint.None;
                case 3: return CompletionHint.Clause;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitRenderOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitRenderOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new RenderOperator((SyntaxToken)RenderKeyword?.Clone(includeDiagnostics), (SyntaxToken)ChartType?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (RenderWithClause)WithClause?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class RenderOperator */
    
    #region class MakeGraphOperator
    public sealed partial class MakeGraphOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.MakeGraphOperator;
        
        public SyntaxToken MakeGraphKeyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public NameReference SourceColumn { get; }
        
        public SyntaxToken DirectionToken { get; }
        
        public NameReference TargetColumn { get; }
        
        public MakeGraphWithClause WithClause { get; }
        
        public MakeGraphPartitionedByClause PartitionedByClause { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="MakeGraphOperator"/>.
        /// </summary>
        internal MakeGraphOperator(SyntaxToken makeGraphKeyword, SyntaxList<NamedParameter> parameters, NameReference sourceColumn, SyntaxToken directionToken, NameReference targetColumn, MakeGraphWithClause withClause, MakeGraphPartitionedByClause partitionedByClause, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.MakeGraphKeyword = Attach(makeGraphKeyword);
            this.Parameters = Attach(parameters);
            this.SourceColumn = Attach(sourceColumn);
            this.DirectionToken = Attach(directionToken);
            this.TargetColumn = Attach(targetColumn);
            this.WithClause = Attach(withClause, optional: true);
            this.PartitionedByClause = Attach(partitionedByClause, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 7;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return MakeGraphKeyword;
                case 1: return Parameters;
                case 2: return SourceColumn;
                case 3: return DirectionToken;
                case 4: return TargetColumn;
                case 5: return WithClause;
                case 6: return PartitionedByClause;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(MakeGraphKeyword);
                case 1: return nameof(Parameters);
                case 2: return nameof(SourceColumn);
                case 3: return nameof(DirectionToken);
                case 4: return nameof(TargetColumn);
                case 5: return nameof(WithClause);
                case 6: return nameof(PartitionedByClause);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 5:
                case 6:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Column;
                case 3: return CompletionHint.Syntax;
                case 4: return CompletionHint.Column;
                case 5: return CompletionHint.Clause;
                case 6: return CompletionHint.Clause;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitMakeGraphOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitMakeGraphOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new MakeGraphOperator((SyntaxToken)MakeGraphKeyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (NameReference)SourceColumn?.Clone(includeDiagnostics), (SyntaxToken)DirectionToken?.Clone(includeDiagnostics), (NameReference)TargetColumn?.Clone(includeDiagnostics), (MakeGraphWithClause)WithClause?.Clone(includeDiagnostics), (MakeGraphPartitionedByClause)PartitionedByClause?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class MakeGraphOperator */
    
    #region class MakeGraphWithClause
    public abstract partial class MakeGraphWithClause : SyntaxNode
    {
        /// <summary>
        /// Constructs a new instance of <see cref="MakeGraphWithClause"/>.
        /// </summary>
        internal MakeGraphWithClause(IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
        }
    }
    #endregion /* class MakeGraphWithClause */
    
    #region class MakeGraphWithTablesAndKeysClause
    public sealed partial class MakeGraphWithTablesAndKeysClause : MakeGraphWithClause
    {
        public override SyntaxKind Kind => SyntaxKind.MakeGraphWithTablesAndKeysClause;
        
        public SyntaxToken WithKeyword { get; }
        
        public SyntaxList<SeparatedElement<MakeGraphTableAndKeyClause>> TablesAndKeys { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="MakeGraphWithTablesAndKeysClause"/>.
        /// </summary>
        internal MakeGraphWithTablesAndKeysClause(SyntaxToken withKeyword, SyntaxList<SeparatedElement<MakeGraphTableAndKeyClause>> tablesAndKeys, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.WithKeyword = Attach(withKeyword);
            this.TablesAndKeys = Attach(tablesAndKeys);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return WithKeyword;
                case 1: return TablesAndKeys;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(WithKeyword);
                case 1: return nameof(TablesAndKeys);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.NonScalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitMakeGraphWithTablesAndKeysClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitMakeGraphWithTablesAndKeysClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new MakeGraphWithTablesAndKeysClause((SyntaxToken)WithKeyword?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<MakeGraphTableAndKeyClause>>)TablesAndKeys?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class MakeGraphWithTablesAndKeysClause */
    
    #region class MakeGraphWithImplicitIdClause
    public sealed partial class MakeGraphWithImplicitIdClause : MakeGraphWithClause
    {
        public override SyntaxKind Kind => SyntaxKind.MakeGraphWithImplicitIdClause;
        
        public SyntaxToken WithNodeIdKeyword { get; }
        
        public SyntaxToken EqualToken { get; }
        
        public NameDeclaration Name { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="MakeGraphWithImplicitIdClause"/>.
        /// </summary>
        internal MakeGraphWithImplicitIdClause(SyntaxToken withNodeIdKeyword, SyntaxToken equalToken, NameDeclaration name, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.WithNodeIdKeyword = Attach(withNodeIdKeyword);
            this.EqualToken = Attach(equalToken);
            this.Name = Attach(name);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return WithNodeIdKeyword;
                case 1: return EqualToken;
                case 2: return Name;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(WithNodeIdKeyword);
                case 1: return nameof(EqualToken);
                case 2: return nameof(Name);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Declaration;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitMakeGraphWithImplicitIdClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitMakeGraphWithImplicitIdClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new MakeGraphWithImplicitIdClause((SyntaxToken)WithNodeIdKeyword?.Clone(includeDiagnostics), (SyntaxToken)EqualToken?.Clone(includeDiagnostics), (NameDeclaration)Name?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class MakeGraphWithImplicitIdClause */
    
    #region class GraphMarkComponentsOperator
    public sealed partial class GraphMarkComponentsOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.GraphMarkComponentsOperator;
        
        public SyntaxToken GraphMarkComponentsKeyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="GraphMarkComponentsOperator"/>.
        /// </summary>
        internal GraphMarkComponentsOperator(SyntaxToken graphMarkComponentsKeyword, SyntaxList<NamedParameter> parameters, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.GraphMarkComponentsKeyword = Attach(graphMarkComponentsKeyword);
            this.Parameters = Attach(parameters);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return GraphMarkComponentsKeyword;
                case 1: return Parameters;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(GraphMarkComponentsKeyword);
                case 1: return nameof(Parameters);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.None;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitGraphMarkComponentsOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitGraphMarkComponentsOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new GraphMarkComponentsOperator((SyntaxToken)GraphMarkComponentsKeyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class GraphMarkComponentsOperator */
    
    #region class GraphWhereNodesOperator
    public sealed partial class GraphWhereNodesOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.GraphWhereNodesOperator;
        
        public SyntaxToken GraphWhereNodesKeyword { get; }
        
        public Expression Condition { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="GraphWhereNodesOperator"/>.
        /// </summary>
        internal GraphWhereNodesOperator(SyntaxToken graphWhereNodesKeyword, Expression condition, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.GraphWhereNodesKeyword = Attach(graphWhereNodesKeyword);
            this.Condition = Attach(condition);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return GraphWhereNodesKeyword;
                case 1: return Condition;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(GraphWhereNodesKeyword);
                case 1: return nameof(Condition);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Boolean;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitGraphWhereNodesOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitGraphWhereNodesOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new GraphWhereNodesOperator((SyntaxToken)GraphWhereNodesKeyword?.Clone(includeDiagnostics), (Expression)Condition?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class GraphWhereNodesOperator */
    
    #region class GraphWhereEdgesOperator
    public sealed partial class GraphWhereEdgesOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.GraphWhereEdgesOperator;
        
        public SyntaxToken GraphWhereEdgesKeyword { get; }
        
        public Expression Condition { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="GraphWhereEdgesOperator"/>.
        /// </summary>
        internal GraphWhereEdgesOperator(SyntaxToken graphWhereEdgesKeyword, Expression condition, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.GraphWhereEdgesKeyword = Attach(graphWhereEdgesKeyword);
            this.Condition = Attach(condition);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return GraphWhereEdgesKeyword;
                case 1: return Condition;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(GraphWhereEdgesKeyword);
                case 1: return nameof(Condition);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Boolean;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitGraphWhereEdgesOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitGraphWhereEdgesOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new GraphWhereEdgesOperator((SyntaxToken)GraphWhereEdgesKeyword?.Clone(includeDiagnostics), (Expression)Condition?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class GraphWhereEdgesOperator */
    
    #region class MakeGraphTableAndKeyClause
    public sealed partial class MakeGraphTableAndKeyClause : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.MakeGraphTableAndKeyClause;
        
        public Expression Table { get; }
        
        public SyntaxToken OnKeyword { get; }
        
        public NameReference Column { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="MakeGraphTableAndKeyClause"/>.
        /// </summary>
        internal MakeGraphTableAndKeyClause(Expression table, SyntaxToken onKeyword, NameReference column, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Table = Attach(table);
            this.OnKeyword = Attach(onKeyword);
            this.Column = Attach(column);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Table;
                case 1: return OnKeyword;
                case 2: return Column;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Table);
                case 1: return nameof(OnKeyword);
                case 2: return nameof(Column);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.NonScalar;
                case 1: return CompletionHint.Keyword;
                case 2: return CompletionHint.Column;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitMakeGraphTableAndKeyClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitMakeGraphTableAndKeyClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new MakeGraphTableAndKeyClause((Expression)Table?.Clone(includeDiagnostics), (SyntaxToken)OnKeyword?.Clone(includeDiagnostics), (NameReference)Column?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class MakeGraphTableAndKeyClause */
    
    #region class MakeGraphPartitionedByClause
    public sealed partial class MakeGraphPartitionedByClause : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.MakeGraphPartitionedByClause;
        
        public SyntaxToken PartitionedByKeyword { get; }
        
        public NameReference Entity { get; }
        
        public SyntaxToken OpenParen { get; }
        
        public Expression Subquery { get; }
        
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="MakeGraphPartitionedByClause"/>.
        /// </summary>
        internal MakeGraphPartitionedByClause(SyntaxToken partitionedByKeyword, NameReference entity, SyntaxToken openParen, Expression subquery, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.PartitionedByKeyword = Attach(partitionedByKeyword);
            this.Entity = Attach(entity);
            this.OpenParen = Attach(openParen);
            this.Subquery = Attach(subquery);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 5;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return PartitionedByKeyword;
                case 1: return Entity;
                case 2: return OpenParen;
                case 3: return Subquery;
                case 4: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(PartitionedByKeyword);
                case 1: return nameof(Entity);
                case 2: return nameof(OpenParen);
                case 3: return nameof(Subquery);
                case 4: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Column;
                case 2: return CompletionHint.Syntax;
                case 3: return CompletionHint.Query;
                case 4: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitMakeGraphPartitionedByClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitMakeGraphPartitionedByClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new MakeGraphPartitionedByClause((SyntaxToken)PartitionedByKeyword?.Clone(includeDiagnostics), (NameReference)Entity?.Clone(includeDiagnostics), (SyntaxToken)OpenParen?.Clone(includeDiagnostics), (Expression)Subquery?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class MakeGraphPartitionedByClause */
    
    #region class GraphToTableOperator
    public sealed partial class GraphToTableOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.GraphToTableOperator;
        
        public SyntaxToken GraphToTableKeyword { get; }
        
        public SyntaxList<SeparatedElement<GraphToTableOutputClause>> OutputClause { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="GraphToTableOperator"/>.
        /// </summary>
        internal GraphToTableOperator(SyntaxToken graphToTableKeyword, SyntaxList<SeparatedElement<GraphToTableOutputClause>> outputClause, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.GraphToTableKeyword = Attach(graphToTableKeyword);
            this.OutputClause = Attach(outputClause);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return GraphToTableKeyword;
                case 1: return OutputClause;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(GraphToTableKeyword);
                case 1: return nameof(OutputClause);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitGraphToTableOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitGraphToTableOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new GraphToTableOperator((SyntaxToken)GraphToTableKeyword?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<GraphToTableOutputClause>>)OutputClause?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class GraphToTableOperator */
    
    #region class GraphToTableOutputClause
    public sealed partial class GraphToTableOutputClause : Clause
    {
        public override SyntaxKind Kind => SyntaxKind.GraphToTableOutputClause;
        
        public SyntaxToken EntityKeyword { get; }
        
        public GraphToTableAsClause AsClause { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="GraphToTableOutputClause"/>.
        /// </summary>
        internal GraphToTableOutputClause(SyntaxToken entityKeyword, GraphToTableAsClause asClause, SyntaxList<NamedParameter> parameters, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.EntityKeyword = Attach(entityKeyword);
            this.AsClause = Attach(asClause, optional: true);
            this.Parameters = Attach(parameters, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return EntityKeyword;
                case 1: return AsClause;
                case 2: return Parameters;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(EntityKeyword);
                case 1: return nameof(AsClause);
                case 2: return nameof(Parameters);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 1:
                case 2:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.None;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitGraphToTableOutputClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitGraphToTableOutputClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new GraphToTableOutputClause((SyntaxToken)EntityKeyword?.Clone(includeDiagnostics), (GraphToTableAsClause)AsClause?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class GraphToTableOutputClause */
    
    #region class GraphToTableAsClause
    public sealed partial class GraphToTableAsClause : Clause
    {
        public override SyntaxKind Kind => SyntaxKind.GraphToTableAsClause;
        
        public SyntaxToken AsKeyword { get; }
        
        public NameDeclaration Name { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="GraphToTableAsClause"/>.
        /// </summary>
        internal GraphToTableAsClause(SyntaxToken asKeyword, NameDeclaration name, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.AsKeyword = Attach(asKeyword);
            this.Name = Attach(name);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return AsKeyword;
                case 1: return Name;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(AsKeyword);
                case 1: return nameof(Name);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Declaration;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitGraphToTableAsClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitGraphToTableAsClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new GraphToTableAsClause((SyntaxToken)AsKeyword?.Clone(includeDiagnostics), (NameDeclaration)Name?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class GraphToTableAsClause */
    
    #region class GraphMatchOperator
    public sealed partial class GraphMatchOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.GraphMatchOperator;
        
        public SyntaxToken GraphMatchKeyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public SyntaxList<SeparatedElement<GraphMatchPattern>> Patterns { get; }
        
        public WhereClause WhereClause { get; }
        
        public ProjectClause ProjectClause { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="GraphMatchOperator"/>.
        /// </summary>
        internal GraphMatchOperator(SyntaxToken graphMatchKeyword, SyntaxList<NamedParameter> parameters, SyntaxList<SeparatedElement<GraphMatchPattern>> patterns, WhereClause whereClause, ProjectClause projectClause, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.GraphMatchKeyword = Attach(graphMatchKeyword);
            this.Parameters = Attach(parameters);
            this.Patterns = Attach(patterns);
            this.WhereClause = Attach(whereClause, optional: true);
            this.ProjectClause = Attach(projectClause, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 5;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return GraphMatchKeyword;
                case 1: return Parameters;
                case 2: return Patterns;
                case 3: return WhereClause;
                case 4: return ProjectClause;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(GraphMatchKeyword);
                case 1: return nameof(Parameters);
                case 2: return nameof(Patterns);
                case 3: return nameof(WhereClause);
                case 4: return nameof(ProjectClause);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 3:
                case 4:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.None;
                case 2: return CompletionHint.Syntax;
                case 3: return CompletionHint.Syntax;
                case 4: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitGraphMatchOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitGraphMatchOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new GraphMatchOperator((SyntaxToken)GraphMatchKeyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<GraphMatchPattern>>)Patterns?.Clone(includeDiagnostics), (WhereClause)WhereClause?.Clone(includeDiagnostics), (ProjectClause)ProjectClause?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class GraphMatchOperator */
    
    #region class GraphShortestPathsOperator
    public sealed partial class GraphShortestPathsOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.GraphShortestPathsOperator;
        
        public SyntaxToken GraphShortestPathsKeyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public SyntaxList<SeparatedElement<GraphMatchPattern>> Patterns { get; }
        
        public WhereClause WhereClause { get; }
        
        public ProjectClause ProjectClause { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="GraphShortestPathsOperator"/>.
        /// </summary>
        internal GraphShortestPathsOperator(SyntaxToken graphShortestPathsKeyword, SyntaxList<NamedParameter> parameters, SyntaxList<SeparatedElement<GraphMatchPattern>> patterns, WhereClause whereClause, ProjectClause projectClause, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.GraphShortestPathsKeyword = Attach(graphShortestPathsKeyword);
            this.Parameters = Attach(parameters);
            this.Patterns = Attach(patterns);
            this.WhereClause = Attach(whereClause, optional: true);
            this.ProjectClause = Attach(projectClause, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 5;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return GraphShortestPathsKeyword;
                case 1: return Parameters;
                case 2: return Patterns;
                case 3: return WhereClause;
                case 4: return ProjectClause;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(GraphShortestPathsKeyword);
                case 1: return nameof(Parameters);
                case 2: return nameof(Patterns);
                case 3: return nameof(WhereClause);
                case 4: return nameof(ProjectClause);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 3:
                case 4:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.None;
                case 2: return CompletionHint.Syntax;
                case 3: return CompletionHint.Syntax;
                case 4: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitGraphShortestPathsOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitGraphShortestPathsOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new GraphShortestPathsOperator((SyntaxToken)GraphShortestPathsKeyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<GraphMatchPattern>>)Patterns?.Clone(includeDiagnostics), (WhereClause)WhereClause?.Clone(includeDiagnostics), (ProjectClause)ProjectClause?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class GraphShortestPathsOperator */
    
    #region class GraphMatchPattern
    public sealed partial class GraphMatchPattern : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.GraphMatchPattern;
        
        public SyntaxList<GraphMatchPatternNotation> PatternElements { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="GraphMatchPattern"/>.
        /// </summary>
        internal GraphMatchPattern(SyntaxList<GraphMatchPatternNotation> patternElements, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.PatternElements = Attach(patternElements);
            this.Init();
        }
        
        public override int ChildCount => 1;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return PatternElements;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(PatternElements);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitGraphMatchPattern(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitGraphMatchPattern(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new GraphMatchPattern((SyntaxList<GraphMatchPatternNotation>)PatternElements?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class GraphMatchPattern */
    
    #region class GraphMatchPatternNotation
    public abstract partial class GraphMatchPatternNotation : SyntaxNode
    {
        /// <summary>
        /// Constructs a new instance of <see cref="GraphMatchPatternNotation"/>.
        /// </summary>
        internal GraphMatchPatternNotation(IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
        }
    }
    #endregion /* class GraphMatchPatternNotation */
    
    #region class GraphMatchPatternNode
    public sealed partial class GraphMatchPatternNode : GraphMatchPatternNotation
    {
        public override SyntaxKind Kind => SyntaxKind.GraphMatchPatternNode;
        
        public SyntaxToken Open { get; }
        
        public NameDeclaration Name { get; }
        
        public SyntaxToken Close { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="GraphMatchPatternNode"/>.
        /// </summary>
        internal GraphMatchPatternNode(SyntaxToken open, NameDeclaration name, SyntaxToken close, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Open = Attach(open);
            this.Name = Attach(name, optional: true);
            this.Close = Attach(close);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Open;
                case 1: return Name;
                case 2: return Close;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Open);
                case 1: return nameof(Name);
                case 2: return nameof(Close);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 1:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.None;
                case 2: return CompletionHint.Keyword;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitGraphMatchPatternNode(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitGraphMatchPatternNode(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new GraphMatchPatternNode((SyntaxToken)Open?.Clone(includeDiagnostics), (NameDeclaration)Name?.Clone(includeDiagnostics), (SyntaxToken)Close?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class GraphMatchPatternNode */
    
    #region class GraphMatchPatternEdge
    public sealed partial class GraphMatchPatternEdge : GraphMatchPatternNotation
    {
        public override SyntaxKind Kind => SyntaxKind.GraphMatchPatternEdge;
        
        public SyntaxToken FirstToken { get; }
        
        public NameDeclaration Name { get; }
        
        public GraphMatchPatternEdgeRange Range { get; }
        
        public SyntaxToken LastToken { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="GraphMatchPatternEdge"/>.
        /// </summary>
        internal GraphMatchPatternEdge(SyntaxToken firstToken, NameDeclaration name, GraphMatchPatternEdgeRange range, SyntaxToken lastToken, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.FirstToken = Attach(firstToken);
            this.Name = Attach(name, optional: true);
            this.Range = Attach(range, optional: true);
            this.LastToken = Attach(lastToken, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 4;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return FirstToken;
                case 1: return Name;
                case 2: return Range;
                case 3: return LastToken;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(FirstToken);
                case 1: return nameof(Name);
                case 2: return nameof(Range);
                case 3: return nameof(LastToken);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 1:
                case 2:
                case 3:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.None;
                case 2: return CompletionHint.None;
                case 3: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitGraphMatchPatternEdge(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitGraphMatchPatternEdge(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new GraphMatchPatternEdge((SyntaxToken)FirstToken?.Clone(includeDiagnostics), (NameDeclaration)Name?.Clone(includeDiagnostics), (GraphMatchPatternEdgeRange)Range?.Clone(includeDiagnostics), (SyntaxToken)LastToken?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class GraphMatchPatternEdge */
    
    #region class GraphMatchPatternEdgeRange
    public sealed partial class GraphMatchPatternEdgeRange : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.GraphMatchPatternEdgeRange;
        
        public SyntaxToken Asterisk { get; }
        
        public Expression RangeStart { get; }
        
        public SyntaxToken DotDotToken { get; }
        
        public Expression RangeEnd { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="GraphMatchPatternEdgeRange"/>.
        /// </summary>
        internal GraphMatchPatternEdgeRange(SyntaxToken asterisk, Expression rangeStart, SyntaxToken dotDotToken, Expression rangeEnd, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Asterisk = Attach(asterisk);
            this.RangeStart = Attach(rangeStart);
            this.DotDotToken = Attach(dotDotToken);
            this.RangeEnd = Attach(rangeEnd);
            this.Init();
        }
        
        public override int ChildCount => 4;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Asterisk;
                case 1: return RangeStart;
                case 2: return DotDotToken;
                case 3: return RangeEnd;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Asterisk);
                case 1: return nameof(RangeStart);
                case 2: return nameof(DotDotToken);
                case 3: return nameof(RangeEnd);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.Scalar;
                case 2: return CompletionHint.Syntax;
                case 3: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitGraphMatchPatternEdgeRange(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitGraphMatchPatternEdgeRange(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new GraphMatchPatternEdgeRange((SyntaxToken)Asterisk?.Clone(includeDiagnostics), (Expression)RangeStart?.Clone(includeDiagnostics), (SyntaxToken)DotDotToken?.Clone(includeDiagnostics), (Expression)RangeEnd?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class GraphMatchPatternEdgeRange */
    
    #region class WhereClause
    public sealed partial class WhereClause : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.WhereClause;
        
        public SyntaxToken WhereKeyword { get; }
        
        public Expression Condition { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="WhereClause"/>.
        /// </summary>
        internal WhereClause(SyntaxToken whereKeyword, Expression condition, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.WhereKeyword = Attach(whereKeyword);
            this.Condition = Attach(condition);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return WhereKeyword;
                case 1: return Condition;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(WhereKeyword);
                case 1: return nameof(Condition);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Boolean;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitWhereClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitWhereClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new WhereClause((SyntaxToken)WhereKeyword?.Clone(includeDiagnostics), (Expression)Condition?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class WhereClause */
    
    #region class ProjectClause
    public sealed partial class ProjectClause : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.ProjectClause;
        
        public SyntaxToken ProjectKeyword { get; }
        
        public SyntaxList<SeparatedElement<Expression>> Expressions { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ProjectClause"/>.
        /// </summary>
        internal ProjectClause(SyntaxToken projectKeyword, SyntaxList<SeparatedElement<Expression>> expressions, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.ProjectKeyword = Attach(projectKeyword);
            this.Expressions = Attach(expressions);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return ProjectKeyword;
                case 1: return Expressions;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(ProjectKeyword);
                case 1: return nameof(Expressions);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitProjectClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitProjectClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ProjectClause((SyntaxToken)ProjectKeyword?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Expression>>)Expressions?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ProjectClause */
    
    #region class NameReferenceList
    public sealed partial class NameReferenceList : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.NameReferenceList;
        
        public SyntaxList<SeparatedElement<NameReference>> Names { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="NameReferenceList"/>.
        /// </summary>
        internal NameReferenceList(SyntaxList<SeparatedElement<NameReference>> names, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Names = Attach(names);
            this.Init();
        }
        
        public override int ChildCount => 1;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Names;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Names);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitNameReferenceList(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitNameReferenceList(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new NameReferenceList((SyntaxList<SeparatedElement<NameReference>>)Names?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class NameReferenceList */
    
    #region class RenderWithClause
    public sealed partial class RenderWithClause : Clause
    {
        public override SyntaxKind Kind => SyntaxKind.RenderWithClause;
        
        public SyntaxToken WithKeyword { get; }
        
        public SyntaxToken OpenParen { get; }
        
        public SyntaxToken LeadingComma { get; }
        
        public SyntaxList<SeparatedElement<NamedParameter>> Properties { get; }
        
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="RenderWithClause"/>.
        /// </summary>
        internal RenderWithClause(SyntaxToken withKeyword, SyntaxToken openParen, SyntaxToken leadingComma, SyntaxList<SeparatedElement<NamedParameter>> properties, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.WithKeyword = Attach(withKeyword);
            this.OpenParen = Attach(openParen);
            this.LeadingComma = Attach(leadingComma, optional: true);
            this.Properties = Attach(properties);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 5;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return WithKeyword;
                case 1: return OpenParen;
                case 2: return LeadingComma;
                case 3: return Properties;
                case 4: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(WithKeyword);
                case 1: return nameof(OpenParen);
                case 2: return nameof(LeadingComma);
                case 3: return nameof(Properties);
                case 4: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 2:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Syntax;
                case 3: return CompletionHint.None;
                case 4: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitRenderWithClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitRenderWithClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new RenderWithClause((SyntaxToken)WithKeyword?.Clone(includeDiagnostics), (SyntaxToken)OpenParen?.Clone(includeDiagnostics), (SyntaxToken)LeadingComma?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<NamedParameter>>)Properties?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class RenderWithClause */
    
    #region class PrintOperator
    public sealed partial class PrintOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.PrintOperator;
        
        public SyntaxToken PrintKeyword { get; }
        
        public SyntaxList<SeparatedElement<Expression>> Expressions { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="PrintOperator"/>.
        /// </summary>
        internal PrintOperator(SyntaxToken printKeyword, SyntaxList<SeparatedElement<Expression>> expressions, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.PrintKeyword = Attach(printKeyword);
            this.Expressions = Attach(expressions);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return PrintKeyword;
                case 1: return Expressions;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(PrintKeyword);
                case 1: return nameof(Expressions);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitPrintOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitPrintOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new PrintOperator((SyntaxToken)PrintKeyword?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Expression>>)Expressions?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class PrintOperator */
    
    #region class AliasStatement
    public sealed partial class AliasStatement : Statement
    {
        public override SyntaxKind Kind => SyntaxKind.AliasStatement;
        
        public SyntaxToken AliasKeyword { get; }
        
        public SyntaxToken DatabaseKeyword { get; }
        
        public NameDeclaration Name { get; }
        
        public SyntaxToken Equal { get; }
        
        public Expression Expression { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="AliasStatement"/>.
        /// </summary>
        internal AliasStatement(SyntaxToken aliasKeyword, SyntaxToken databaseKeyword, NameDeclaration name, SyntaxToken equal, Expression expression, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.AliasKeyword = Attach(aliasKeyword);
            this.DatabaseKeyword = Attach(databaseKeyword);
            this.Name = Attach(name);
            this.Equal = Attach(equal);
            this.Expression = Attach(expression);
            this.Init();
        }
        
        public override int ChildCount => 5;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return AliasKeyword;
                case 1: return DatabaseKeyword;
                case 2: return Name;
                case 3: return Equal;
                case 4: return Expression;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(AliasKeyword);
                case 1: return nameof(DatabaseKeyword);
                case 2: return nameof(Name);
                case 3: return nameof(Equal);
                case 4: return nameof(Expression);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Keyword;
                case 2: return CompletionHint.Declaration;
                case 3: return CompletionHint.Syntax;
                case 4: return CompletionHint.Database;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitAliasStatement(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitAliasStatement(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new AliasStatement((SyntaxToken)AliasKeyword?.Clone(includeDiagnostics), (SyntaxToken)DatabaseKeyword?.Clone(includeDiagnostics), (NameDeclaration)Name?.Clone(includeDiagnostics), (SyntaxToken)Equal?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class AliasStatement */
    
    #region class LetStatement
    public sealed partial class LetStatement : Statement
    {
        public override SyntaxKind Kind => SyntaxKind.LetStatement;
        
        public SyntaxToken LetKeyword { get; }
        
        public NameDeclaration Name { get; }
        
        public SyntaxToken Equal { get; }
        
        public Expression Expression { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="LetStatement"/>.
        /// </summary>
        internal LetStatement(SyntaxToken letKeyword, NameDeclaration name, SyntaxToken equal, Expression expression, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.LetKeyword = Attach(letKeyword);
            this.Name = Attach(name);
            this.Equal = Attach(equal);
            this.Expression = Attach(expression);
            this.Init();
        }
        
        public override int ChildCount => 4;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return LetKeyword;
                case 1: return Name;
                case 2: return Equal;
                case 3: return Expression;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(LetKeyword);
                case 1: return nameof(Name);
                case 2: return nameof(Equal);
                case 3: return nameof(Expression);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Declaration;
                case 2: return CompletionHint.Syntax;
                case 3: return CompletionHint.Expression;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitLetStatement(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitLetStatement(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new LetStatement((SyntaxToken)LetKeyword?.Clone(includeDiagnostics), (NameDeclaration)Name?.Clone(includeDiagnostics), (SyntaxToken)Equal?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class LetStatement */
    
    #region class FunctionDeclaration
    public sealed partial class FunctionDeclaration : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.FunctionDeclaration;
        
        public SyntaxToken ViewKeyword { get; }
        
        public FunctionParameters Parameters { get; }
        
        public FunctionBody Body { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="FunctionDeclaration"/>.
        /// </summary>
        internal FunctionDeclaration(SyntaxToken viewKeyword, FunctionParameters parameters, FunctionBody body, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.ViewKeyword = Attach(viewKeyword, optional: true);
            this.Parameters = Attach(parameters);
            this.Body = Attach(body);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return ViewKeyword;
                case 1: return Parameters;
                case 2: return Body;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(ViewKeyword);
                case 1: return nameof(Parameters);
                case 2: return nameof(Body);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 0:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Clause;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitFunctionDeclaration(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitFunctionDeclaration(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new FunctionDeclaration((SyntaxToken)ViewKeyword?.Clone(includeDiagnostics), (FunctionParameters)Parameters?.Clone(includeDiagnostics), (FunctionBody)Body?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class FunctionDeclaration */
    
    #region class FunctionParameters
    public sealed partial class FunctionParameters : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.FunctionParameters;
        
        public SyntaxToken OpenParen { get; }
        
        public SyntaxList<SeparatedElement<FunctionParameter>> Parameters { get; }
        
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="FunctionParameters"/>.
        /// </summary>
        internal FunctionParameters(SyntaxToken openParen, SyntaxList<SeparatedElement<FunctionParameter>> parameters, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.OpenParen = Attach(openParen);
            this.Parameters = Attach(parameters);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return OpenParen;
                case 1: return Parameters;
                case 2: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(OpenParen);
                case 1: return nameof(Parameters);
                case 2: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitFunctionParameters(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitFunctionParameters(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new FunctionParameters((SyntaxToken)OpenParen?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<FunctionParameter>>)Parameters?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class FunctionParameters */
    
    #region class FunctionParameter
    public sealed partial class FunctionParameter : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.FunctionParameter;
        
        public NameAndTypeDeclaration NameAndType { get; }
        
        public DefaultValueDeclaration DefaultValue { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="FunctionParameter"/>.
        /// </summary>
        internal FunctionParameter(NameAndTypeDeclaration nameAndType, DefaultValueDeclaration defaultValue, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.NameAndType = Attach(nameAndType);
            this.DefaultValue = Attach(defaultValue, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return NameAndType;
                case 1: return DefaultValue;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(NameAndType);
                case 1: return nameof(DefaultValue);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 1:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 1: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitFunctionParameter(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitFunctionParameter(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new FunctionParameter((NameAndTypeDeclaration)NameAndType?.Clone(includeDiagnostics), (DefaultValueDeclaration)DefaultValue?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class FunctionParameter */
    
    #region class DefaultValueDeclaration
    public sealed partial class DefaultValueDeclaration : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.DefaultValueDeclaration;
        
        public SyntaxToken Equal { get; }
        
        public Expression Value { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="DefaultValueDeclaration"/>.
        /// </summary>
        internal DefaultValueDeclaration(SyntaxToken equal, Expression value, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Equal = Attach(equal);
            this.Value = Attach(value);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Equal;
                case 1: return Value;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Equal);
                case 1: return nameof(Value);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 1: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitDefaultValueDeclaration(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitDefaultValueDeclaration(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new DefaultValueDeclaration((SyntaxToken)Equal?.Clone(includeDiagnostics), (Expression)Value?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class DefaultValueDeclaration */
    
    #region class FunctionBody
    public sealed partial class FunctionBody : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.FunctionBody;
        
        public SyntaxToken OpenBrace { get; }
        
        public SyntaxList<SeparatedElement<Statement>> Statements { get; }
        
        public Expression Expression { get; }
        
        public SyntaxToken Semicolon { get; }
        
        public SyntaxToken CloseBrace { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="FunctionBody"/>.
        /// </summary>
        internal FunctionBody(SyntaxToken openBrace, SyntaxList<SeparatedElement<Statement>> statements, Expression expression, SyntaxToken semicolon, SyntaxToken closeBrace, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.OpenBrace = Attach(openBrace);
            this.Statements = Attach(statements);
            this.Expression = Attach(expression, optional: true);
            this.Semicolon = Attach(semicolon, optional: true);
            this.CloseBrace = Attach(closeBrace);
            this.Init();
        }
        
        public override int ChildCount => 5;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return OpenBrace;
                case 1: return Statements;
                case 2: return Expression;
                case 3: return Semicolon;
                case 4: return CloseBrace;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(OpenBrace);
                case 1: return nameof(Statements);
                case 2: return nameof(Expression);
                case 3: return nameof(Semicolon);
                case 4: return nameof(CloseBrace);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 2:
                case 3:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.NonScalar;
                case 2: return CompletionHint.Expression;
                case 3: return CompletionHint.Syntax;
                case 4: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitFunctionBody(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitFunctionBody(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new FunctionBody((SyntaxToken)OpenBrace?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Statement>>)Statements?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (SyntaxToken)Semicolon?.Clone(includeDiagnostics), (SyntaxToken)CloseBrace?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class FunctionBody */
    
    #region class SchemaTypeExpression
    public sealed partial class SchemaTypeExpression : TypeExpression
    {
        public override SyntaxKind Kind => SyntaxKind.SchemaTypeExpression;
        
        public SyntaxToken OpenParen { get; }
        
        public SyntaxList<SeparatedElement<Expression>> Columns { get; }
        
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="SchemaTypeExpression"/>.
        /// </summary>
        internal SchemaTypeExpression(SyntaxToken openParen, SyntaxList<SeparatedElement<Expression>> columns, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.OpenParen = Attach(openParen);
            this.Columns = Attach(columns);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return OpenParen;
                case 1: return Columns;
                case 2: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(OpenParen);
                case 1: return nameof(Columns);
                case 2: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.Declaration;
                case 2: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitSchemaTypeExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitSchemaTypeExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new SchemaTypeExpression((SyntaxToken)OpenParen?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Expression>>)Columns?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class SchemaTypeExpression */
    
    #region class ExpressionStatement
    public sealed partial class ExpressionStatement : Statement
    {
        public override SyntaxKind Kind => SyntaxKind.ExpressionStatement;
        
        public Expression Expression { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ExpressionStatement"/>.
        /// </summary>
        internal ExpressionStatement(Expression expression, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Expression = Attach(expression);
            this.Init();
        }
        
        public override int ChildCount => 1;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Expression;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Expression);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Inherit;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitExpressionStatement(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitExpressionStatement(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ExpressionStatement((Expression)Expression?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ExpressionStatement */
    
    #region class MaterializeExpression
    public sealed partial class MaterializeExpression : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.MaterializeExpression;
        
        public SyntaxToken MaterializeKeyword { get; }
        
        public SyntaxToken OpenParen { get; }
        
        public Expression Expression { get; }
        
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="MaterializeExpression"/>.
        /// </summary>
        internal MaterializeExpression(SyntaxToken materializeKeyword, SyntaxToken openParen, Expression expression, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.MaterializeKeyword = Attach(materializeKeyword);
            this.OpenParen = Attach(openParen);
            this.Expression = Attach(expression);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 4;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return MaterializeKeyword;
                case 1: return OpenParen;
                case 2: return Expression;
                case 3: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(MaterializeKeyword);
                case 1: return nameof(OpenParen);
                case 2: return nameof(Expression);
                case 3: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.NonScalar;
                case 3: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitMaterializeExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitMaterializeExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new MaterializeExpression((SyntaxToken)MaterializeKeyword?.Clone(includeDiagnostics), (SyntaxToken)OpenParen?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class MaterializeExpression */
    
    #region class SetOptionStatement
    public sealed partial class SetOptionStatement : Statement
    {
        public override SyntaxKind Kind => SyntaxKind.SetOptionStatement;
        
        public SyntaxToken SetKeyword { get; }
        
        public NameDeclaration Name { get; }
        
        public OptionValueClause ValueClause { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="SetOptionStatement"/>.
        /// </summary>
        internal SetOptionStatement(SyntaxToken setKeyword, NameDeclaration name, OptionValueClause valueClause, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.SetKeyword = Attach(setKeyword);
            this.Name = Attach(name);
            this.ValueClause = Attach(valueClause, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return SetKeyword;
                case 1: return Name;
                case 2: return ValueClause;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(SetKeyword);
                case 1: return nameof(Name);
                case 2: return nameof(ValueClause);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 2:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Option;
                case 2: return CompletionHint.Clause;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitSetOptionStatement(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitSetOptionStatement(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new SetOptionStatement((SyntaxToken)SetKeyword?.Clone(includeDiagnostics), (NameDeclaration)Name?.Clone(includeDiagnostics), (OptionValueClause)ValueClause?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class SetOptionStatement */
    
    #region class OptionValueClause
    public sealed partial class OptionValueClause : Clause
    {
        public override SyntaxKind Kind => SyntaxKind.OptionValueClause;
        
        public SyntaxToken Equal { get; }
        
        public Expression Expression { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="OptionValueClause"/>.
        /// </summary>
        internal OptionValueClause(SyntaxToken equal, Expression expression, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Equal = Attach(equal);
            this.Expression = Attach(expression);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Equal;
                case 1: return Expression;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Equal);
                case 1: return nameof(Expression);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitOptionValueClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitOptionValueClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new OptionValueClause((SyntaxToken)Equal?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class OptionValueClause */
    
    #region class QueryParametersStatement
    public sealed partial class QueryParametersStatement : Statement
    {
        public override SyntaxKind Kind => SyntaxKind.QueryParametersStatement;
        
        public SyntaxToken DeclareKeyword { get; }
        
        public SyntaxToken QueryParametersKeyword { get; }
        
        public SyntaxToken OpenParen { get; }
        
        public SyntaxList<SeparatedElement<FunctionParameter>> Parameters { get; }
        
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="QueryParametersStatement"/>.
        /// </summary>
        internal QueryParametersStatement(SyntaxToken declareKeyword, SyntaxToken queryParametersKeyword, SyntaxToken openParen, SyntaxList<SeparatedElement<FunctionParameter>> parameters, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.DeclareKeyword = Attach(declareKeyword);
            this.QueryParametersKeyword = Attach(queryParametersKeyword);
            this.OpenParen = Attach(openParen);
            this.Parameters = Attach(parameters);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 5;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return DeclareKeyword;
                case 1: return QueryParametersKeyword;
                case 2: return OpenParen;
                case 3: return Parameters;
                case 4: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(DeclareKeyword);
                case 1: return nameof(QueryParametersKeyword);
                case 2: return nameof(OpenParen);
                case 3: return nameof(Parameters);
                case 4: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Syntax;
                case 3: return CompletionHint.Syntax;
                case 4: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitQueryParametersStatement(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitQueryParametersStatement(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new QueryParametersStatement((SyntaxToken)DeclareKeyword?.Clone(includeDiagnostics), (SyntaxToken)QueryParametersKeyword?.Clone(includeDiagnostics), (SyntaxToken)OpenParen?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<FunctionParameter>>)Parameters?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class QueryParametersStatement */
    
    #region class RestrictStatementWithClause
    public sealed partial class RestrictStatementWithClause : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.RestrictStatementWithClause;
        
        public SyntaxToken WithKeyword { get; }
        
        public SyntaxToken OpenParen { get; }
        
        public SyntaxList<SeparatedElement<NamedParameter>> Properties { get; }
        
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="RestrictStatementWithClause"/>.
        /// </summary>
        internal RestrictStatementWithClause(SyntaxToken withKeyword, SyntaxToken openParen, SyntaxList<SeparatedElement<NamedParameter>> properties, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.WithKeyword = Attach(withKeyword);
            this.OpenParen = Attach(openParen);
            this.Properties = Attach(properties);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 4;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return WithKeyword;
                case 1: return OpenParen;
                case 2: return Properties;
                case 3: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(WithKeyword);
                case 1: return nameof(OpenParen);
                case 2: return nameof(Properties);
                case 3: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.None;
                case 3: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitRestrictStatementWithClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitRestrictStatementWithClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new RestrictStatementWithClause((SyntaxToken)WithKeyword?.Clone(includeDiagnostics), (SyntaxToken)OpenParen?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<NamedParameter>>)Properties?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class RestrictStatementWithClause */
    
    #region class RestrictStatement
    public sealed partial class RestrictStatement : Statement
    {
        public override SyntaxKind Kind => SyntaxKind.RestrictStatement;
        
        public SyntaxToken RestrictKeyword { get; }
        
        public SyntaxToken AccessKeyword { get; }
        
        public SyntaxToken ToKeyword { get; }
        
        public SyntaxToken OpenParen { get; }
        
        public SyntaxList<SeparatedElement<Expression>> Expressions { get; }
        
        public SyntaxToken CloseParen { get; }
        
        public RestrictStatementWithClause WithClause { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="RestrictStatement"/>.
        /// </summary>
        internal RestrictStatement(SyntaxToken restrictKeyword, SyntaxToken accessKeyword, SyntaxToken toKeyword, SyntaxToken openParen, SyntaxList<SeparatedElement<Expression>> expressions, SyntaxToken closeParen, RestrictStatementWithClause withClause, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.RestrictKeyword = Attach(restrictKeyword);
            this.AccessKeyword = Attach(accessKeyword);
            this.ToKeyword = Attach(toKeyword);
            this.OpenParen = Attach(openParen);
            this.Expressions = Attach(expressions);
            this.CloseParen = Attach(closeParen);
            this.WithClause = Attach(withClause, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 7;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return RestrictKeyword;
                case 1: return AccessKeyword;
                case 2: return ToKeyword;
                case 3: return OpenParen;
                case 4: return Expressions;
                case 5: return CloseParen;
                case 6: return WithClause;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(RestrictKeyword);
                case 1: return nameof(AccessKeyword);
                case 2: return nameof(ToKeyword);
                case 3: return nameof(OpenParen);
                case 4: return nameof(Expressions);
                case 5: return nameof(CloseParen);
                case 6: return nameof(WithClause);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 6:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Keyword;
                case 2: return CompletionHint.Keyword;
                case 3: return CompletionHint.Syntax;
                case 4: return CompletionHint.Scalar;
                case 5: return CompletionHint.Syntax;
                case 6: return CompletionHint.Clause;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitRestrictStatement(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitRestrictStatement(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new RestrictStatement((SyntaxToken)RestrictKeyword?.Clone(includeDiagnostics), (SyntaxToken)AccessKeyword?.Clone(includeDiagnostics), (SyntaxToken)ToKeyword?.Clone(includeDiagnostics), (SyntaxToken)OpenParen?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Expression>>)Expressions?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (RestrictStatementWithClause)WithClause?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class RestrictStatement */
    
    #region class PatternStatement
    public sealed partial class PatternStatement : Statement
    {
        public override SyntaxKind Kind => SyntaxKind.PatternStatement;
        
        public SyntaxToken DeclareKeyword { get; }
        
        public SyntaxToken PatternKeyword { get; }
        
        public NameDeclaration Name { get; }
        
        public PatternDeclaration Pattern { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="PatternStatement"/>.
        /// </summary>
        internal PatternStatement(SyntaxToken declareKeyword, SyntaxToken patternKeyword, NameDeclaration name, PatternDeclaration pattern, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.DeclareKeyword = Attach(declareKeyword);
            this.PatternKeyword = Attach(patternKeyword);
            this.Name = Attach(name);
            this.Pattern = Attach(pattern, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 4;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return DeclareKeyword;
                case 1: return PatternKeyword;
                case 2: return Name;
                case 3: return Pattern;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(DeclareKeyword);
                case 1: return nameof(PatternKeyword);
                case 2: return nameof(Name);
                case 3: return nameof(Pattern);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 3:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Keyword;
                case 2: return CompletionHint.Declaration;
                case 3: return CompletionHint.Clause;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitPatternStatement(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitPatternStatement(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new PatternStatement((SyntaxToken)DeclareKeyword?.Clone(includeDiagnostics), (SyntaxToken)PatternKeyword?.Clone(includeDiagnostics), (NameDeclaration)Name?.Clone(includeDiagnostics), (PatternDeclaration)Pattern?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class PatternStatement */
    
    #region class PatternDeclaration
    public sealed partial class PatternDeclaration : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.PatternDeclaration;
        
        public SyntaxToken EqualToken { get; }
        
        public SyntaxToken OpenParen { get; }
        
        public SyntaxList<SeparatedElement<NameAndTypeDeclaration>> Parameters { get; }
        
        public SyntaxToken CloseParen { get; }
        
        public PatternPathParameter PathParameter { get; }
        
        public SyntaxToken OpenBrace { get; }
        
        public SyntaxList<PatternMatch> Patterns { get; }
        
        public SyntaxToken CloseBrace { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="PatternDeclaration"/>.
        /// </summary>
        internal PatternDeclaration(SyntaxToken equalToken, SyntaxToken openParen, SyntaxList<SeparatedElement<NameAndTypeDeclaration>> parameters, SyntaxToken closeParen, PatternPathParameter pathParameter, SyntaxToken openBrace, SyntaxList<PatternMatch> patterns, SyntaxToken closeBrace, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.EqualToken = Attach(equalToken);
            this.OpenParen = Attach(openParen);
            this.Parameters = Attach(parameters);
            this.CloseParen = Attach(closeParen);
            this.PathParameter = Attach(pathParameter, optional: true);
            this.OpenBrace = Attach(openBrace);
            this.Patterns = Attach(patterns);
            this.CloseBrace = Attach(closeBrace);
            this.Init();
        }
        
        public override int ChildCount => 8;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return EqualToken;
                case 1: return OpenParen;
                case 2: return Parameters;
                case 3: return CloseParen;
                case 4: return PathParameter;
                case 5: return OpenBrace;
                case 6: return Patterns;
                case 7: return CloseBrace;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(EqualToken);
                case 1: return nameof(OpenParen);
                case 2: return nameof(Parameters);
                case 3: return nameof(CloseParen);
                case 4: return nameof(PathParameter);
                case 5: return nameof(OpenBrace);
                case 6: return nameof(Patterns);
                case 7: return nameof(CloseBrace);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 4:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Syntax;
                case 3: return CompletionHint.Syntax;
                case 4: return CompletionHint.Clause;
                case 5: return CompletionHint.Syntax;
                case 6: return CompletionHint.Clause;
                case 7: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitPatternDeclaration(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitPatternDeclaration(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new PatternDeclaration((SyntaxToken)EqualToken?.Clone(includeDiagnostics), (SyntaxToken)OpenParen?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<NameAndTypeDeclaration>>)Parameters?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (PatternPathParameter)PathParameter?.Clone(includeDiagnostics), (SyntaxToken)OpenBrace?.Clone(includeDiagnostics), (SyntaxList<PatternMatch>)Patterns?.Clone(includeDiagnostics), (SyntaxToken)CloseBrace?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class PatternDeclaration */
    
    #region class PatternPathParameter
    public sealed partial class PatternPathParameter : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.PatternPathParameter;
        
        public SyntaxToken OpenBracket { get; }
        
        public NameAndTypeDeclaration Parameter { get; }
        
        public SyntaxToken CloseBracket { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="PatternPathParameter"/>.
        /// </summary>
        internal PatternPathParameter(SyntaxToken openBracket, NameAndTypeDeclaration parameter, SyntaxToken closeBracket, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.OpenBracket = Attach(openBracket);
            this.Parameter = Attach(parameter);
            this.CloseBracket = Attach(closeBracket);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return OpenBracket;
                case 1: return Parameter;
                case 2: return CloseBracket;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(OpenBracket);
                case 1: return nameof(Parameter);
                case 2: return nameof(CloseBracket);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitPatternPathParameter(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitPatternPathParameter(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new PatternPathParameter((SyntaxToken)OpenBracket?.Clone(includeDiagnostics), (NameAndTypeDeclaration)Parameter?.Clone(includeDiagnostics), (SyntaxToken)CloseBracket?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class PatternPathParameter */
    
    #region class PatternMatch
    public sealed partial class PatternMatch : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.PatternMatch;
        
        public ExpressionList ParameterValues { get; }
        
        public PatternPathValue PathValue { get; }
        
        public SyntaxToken EqualToken { get; }
        
        public FunctionBody Body { get; }
        
        public SyntaxToken SemicolonToken { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="PatternMatch"/>.
        /// </summary>
        internal PatternMatch(ExpressionList parameterValues, PatternPathValue pathValue, SyntaxToken equalToken, FunctionBody body, SyntaxToken semicolonToken, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.ParameterValues = Attach(parameterValues);
            this.PathValue = Attach(pathValue, optional: true);
            this.EqualToken = Attach(equalToken);
            this.Body = Attach(body);
            this.SemicolonToken = Attach(semicolonToken);
            this.Init();
        }
        
        public override int ChildCount => 5;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return ParameterValues;
                case 1: return PathValue;
                case 2: return EqualToken;
                case 3: return Body;
                case 4: return SemicolonToken;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(ParameterValues);
                case 1: return nameof(PathValue);
                case 2: return nameof(EqualToken);
                case 3: return nameof(Body);
                case 4: return nameof(SemicolonToken);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 1:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.Clause;
                case 2: return CompletionHint.Syntax;
                case 3: return CompletionHint.Clause;
                case 4: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitPatternMatch(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitPatternMatch(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new PatternMatch((ExpressionList)ParameterValues?.Clone(includeDiagnostics), (PatternPathValue)PathValue?.Clone(includeDiagnostics), (SyntaxToken)EqualToken?.Clone(includeDiagnostics), (FunctionBody)Body?.Clone(includeDiagnostics), (SyntaxToken)SemicolonToken?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class PatternMatch */
    
    #region class PatternPathValue
    public sealed partial class PatternPathValue : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.PatternPathValue;
        
        public SyntaxToken DotToken { get; }
        
        public SyntaxToken OpenBracket { get; }
        
        public Expression Value { get; }
        
        public SyntaxToken CloseBracket { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="PatternPathValue"/>.
        /// </summary>
        internal PatternPathValue(SyntaxToken dotToken, SyntaxToken openBracket, Expression value, SyntaxToken closeBracket, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.DotToken = Attach(dotToken);
            this.OpenBracket = Attach(openBracket);
            this.Value = Attach(value);
            this.CloseBracket = Attach(closeBracket);
            this.Init();
        }
        
        public override int ChildCount => 4;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return DotToken;
                case 1: return OpenBracket;
                case 2: return Value;
                case 3: return CloseBracket;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(DotToken);
                case 1: return nameof(OpenBracket);
                case 2: return nameof(Value);
                case 3: return nameof(CloseBracket);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Scalar;
                case 3: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitPatternPathValue(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitPatternPathValue(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new PatternPathValue((SyntaxToken)DotToken?.Clone(includeDiagnostics), (SyntaxToken)OpenBracket?.Clone(includeDiagnostics), (Expression)Value?.Clone(includeDiagnostics), (SyntaxToken)CloseBracket?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class PatternPathValue */
    
    #region class DataScopeExpression
    public sealed partial class DataScopeExpression : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.DataScopeExpression;
        
        public Expression Expression { get; }
        
        public DataScopeClause DataScopeClause { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="DataScopeExpression"/>.
        /// </summary>
        internal DataScopeExpression(Expression expression, DataScopeClause dataScopeClause, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Expression = Attach(expression);
            this.DataScopeClause = Attach(dataScopeClause);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Expression;
                case 1: return DataScopeClause;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Expression);
                case 1: return nameof(DataScopeClause);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 1: return CompletionHint.Clause;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitDataScopeExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitDataScopeExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new DataScopeExpression((Expression)Expression?.Clone(includeDiagnostics), (DataScopeClause)DataScopeClause?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class DataScopeExpression */
    
    #region class DataTableExpression
    public sealed partial class DataTableExpression : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.DataTableExpression;
        
        public SyntaxToken DataTableKeyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public RowSchema Schema { get; }
        
        public SyntaxToken OpenBracket { get; }
        
        public SyntaxToken LeadingComma { get; }
        
        public SyntaxList<SeparatedElement<Expression>> Values { get; }
        
        public SyntaxToken CloseBracket { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="DataTableExpression"/>.
        /// </summary>
        internal DataTableExpression(SyntaxToken dataTableKeyword, SyntaxList<NamedParameter> parameters, RowSchema schema, SyntaxToken openBracket, SyntaxToken leadingComma, SyntaxList<SeparatedElement<Expression>> values, SyntaxToken closeBracket, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.DataTableKeyword = Attach(dataTableKeyword);
            this.Parameters = Attach(parameters);
            this.Schema = Attach(schema);
            this.OpenBracket = Attach(openBracket);
            this.LeadingComma = Attach(leadingComma, optional: true);
            this.Values = Attach(values);
            this.CloseBracket = Attach(closeBracket);
            this.Init();
        }
        
        public override int ChildCount => 7;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return DataTableKeyword;
                case 1: return Parameters;
                case 2: return Schema;
                case 3: return OpenBracket;
                case 4: return LeadingComma;
                case 5: return Values;
                case 6: return CloseBracket;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(DataTableKeyword);
                case 1: return nameof(Parameters);
                case 2: return nameof(Schema);
                case 3: return nameof(OpenBracket);
                case 4: return nameof(LeadingComma);
                case 5: return nameof(Values);
                case 6: return nameof(CloseBracket);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 4:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.None;
                case 2: return CompletionHint.Syntax;
                case 3: return CompletionHint.Syntax;
                case 4: return CompletionHint.Syntax;
                case 5: return CompletionHint.Literal;
                case 6: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitDataTableExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitDataTableExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new DataTableExpression((SyntaxToken)DataTableKeyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (RowSchema)Schema?.Clone(includeDiagnostics), (SyntaxToken)OpenBracket?.Clone(includeDiagnostics), (SyntaxToken)LeadingComma?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Expression>>)Values?.Clone(includeDiagnostics), (SyntaxToken)CloseBracket?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class DataTableExpression */
    
    #region class RowSchema
    public sealed partial class RowSchema : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.RowSchema;
        
        public SyntaxToken OpenParen { get; }
        
        public SyntaxToken LeadingComma { get; }
        
        public SyntaxList<SeparatedElement<NameAndTypeDeclaration>> Columns { get; }
        
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="RowSchema"/>.
        /// </summary>
        internal RowSchema(SyntaxToken openParen, SyntaxToken leadingComma, SyntaxList<SeparatedElement<NameAndTypeDeclaration>> columns, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.OpenParen = Attach(openParen);
            this.LeadingComma = Attach(leadingComma, optional: true);
            this.Columns = Attach(columns);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 4;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return OpenParen;
                case 1: return LeadingComma;
                case 2: return Columns;
                case 3: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(OpenParen);
                case 1: return nameof(LeadingComma);
                case 2: return nameof(Columns);
                case 3: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 1:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Declaration;
                case 3: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitRowSchema(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitRowSchema(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new RowSchema((SyntaxToken)OpenParen?.Clone(includeDiagnostics), (SyntaxToken)LeadingComma?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<NameAndTypeDeclaration>>)Columns?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class RowSchema */
    
    #region class EvaluateRowSchema
    public sealed partial class EvaluateRowSchema : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.EvaluateRowSchema;
        
        public SyntaxToken OpenParen { get; }
        
        public SyntaxToken LeadingComma { get; }
        
        public SyntaxToken AsteriskToken { get; }
        
        public SyntaxToken AsteriskTokenComma { get; }
        
        public SyntaxList<SeparatedElement<NameAndTypeDeclaration>> Columns { get; }
        
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="EvaluateRowSchema"/>.
        /// </summary>
        internal EvaluateRowSchema(SyntaxToken openParen, SyntaxToken leadingComma, SyntaxToken asteriskToken, SyntaxToken asteriskTokenComma, SyntaxList<SeparatedElement<NameAndTypeDeclaration>> columns, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.OpenParen = Attach(openParen);
            this.LeadingComma = Attach(leadingComma, optional: true);
            this.AsteriskToken = Attach(asteriskToken, optional: true);
            this.AsteriskTokenComma = Attach(asteriskTokenComma, optional: true);
            this.Columns = Attach(columns);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 6;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return OpenParen;
                case 1: return LeadingComma;
                case 2: return AsteriskToken;
                case 3: return AsteriskTokenComma;
                case 4: return Columns;
                case 5: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(OpenParen);
                case 1: return nameof(LeadingComma);
                case 2: return nameof(AsteriskToken);
                case 3: return nameof(AsteriskTokenComma);
                case 4: return nameof(Columns);
                case 5: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 1:
                case 2:
                case 3:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Syntax;
                case 3: return CompletionHint.Syntax;
                case 4: return CompletionHint.Declaration;
                case 5: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitEvaluateRowSchema(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitEvaluateRowSchema(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new EvaluateRowSchema((SyntaxToken)OpenParen?.Clone(includeDiagnostics), (SyntaxToken)LeadingComma?.Clone(includeDiagnostics), (SyntaxToken)AsteriskToken?.Clone(includeDiagnostics), (SyntaxToken)AsteriskTokenComma?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<NameAndTypeDeclaration>>)Columns?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class EvaluateRowSchema */
    
    #region class ExternalDataExpression
    public sealed partial class ExternalDataExpression : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.ExternalDataExpression;
        
        public SyntaxToken ExternalDataKeyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public RowSchema Schema { get; }
        
        public SyntaxToken OpenBracket { get; }
        
        public SyntaxList<SeparatedElement<Expression>> URIs { get; }
        
        public SyntaxToken CloseBracket { get; }
        
        public ExternalDataWithClause WithClause { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ExternalDataExpression"/>.
        /// </summary>
        internal ExternalDataExpression(SyntaxToken externalDataKeyword, SyntaxList<NamedParameter> parameters, RowSchema schema, SyntaxToken openBracket, SyntaxList<SeparatedElement<Expression>> uRIs, SyntaxToken closeBracket, ExternalDataWithClause withClause, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.ExternalDataKeyword = Attach(externalDataKeyword);
            this.Parameters = Attach(parameters);
            this.Schema = Attach(schema);
            this.OpenBracket = Attach(openBracket);
            this.URIs = Attach(uRIs);
            this.CloseBracket = Attach(closeBracket);
            this.WithClause = Attach(withClause, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 7;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return ExternalDataKeyword;
                case 1: return Parameters;
                case 2: return Schema;
                case 3: return OpenBracket;
                case 4: return URIs;
                case 5: return CloseBracket;
                case 6: return WithClause;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(ExternalDataKeyword);
                case 1: return nameof(Parameters);
                case 2: return nameof(Schema);
                case 3: return nameof(OpenBracket);
                case 4: return nameof(URIs);
                case 5: return nameof(CloseBracket);
                case 6: return nameof(WithClause);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 6:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.None;
                case 2: return CompletionHint.Syntax;
                case 3: return CompletionHint.Syntax;
                case 4: return CompletionHint.None;
                case 5: return CompletionHint.Syntax;
                case 6: return CompletionHint.Clause;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitExternalDataExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitExternalDataExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ExternalDataExpression((SyntaxToken)ExternalDataKeyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (RowSchema)Schema?.Clone(includeDiagnostics), (SyntaxToken)OpenBracket?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Expression>>)URIs?.Clone(includeDiagnostics), (SyntaxToken)CloseBracket?.Clone(includeDiagnostics), (ExternalDataWithClause)WithClause?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ExternalDataExpression */
    
    #region class ContextualDataTableExpression
    public sealed partial class ContextualDataTableExpression : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.ContextualDataTableExpression;
        
        public SyntaxToken ContextualDataTableKeyword { get; }
        
        public Expression Id { get; }
        
        public RowSchema Schema { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ContextualDataTableExpression"/>.
        /// </summary>
        internal ContextualDataTableExpression(SyntaxToken contextualDataTableKeyword, Expression id, RowSchema schema, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.ContextualDataTableKeyword = Attach(contextualDataTableKeyword);
            this.Id = Attach(id);
            this.Schema = Attach(schema);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return ContextualDataTableKeyword;
                case 1: return Id;
                case 2: return Schema;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(ContextualDataTableKeyword);
                case 1: return nameof(Id);
                case 2: return nameof(Schema);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.None;
                case 2: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitContextualDataTableExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitContextualDataTableExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ContextualDataTableExpression((SyntaxToken)ContextualDataTableKeyword?.Clone(includeDiagnostics), (Expression)Id?.Clone(includeDiagnostics), (RowSchema)Schema?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ContextualDataTableExpression */
    
    #region class ExternalDataWithClause
    public sealed partial class ExternalDataWithClause : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.ExternalDataWithClause;
        
        public SyntaxToken WithKeyword { get; }
        
        public SyntaxToken OpenParen { get; }
        
        public SyntaxList<SeparatedElement<NamedParameter>> Properties { get; }
        
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ExternalDataWithClause"/>.
        /// </summary>
        internal ExternalDataWithClause(SyntaxToken withKeyword, SyntaxToken openParen, SyntaxList<SeparatedElement<NamedParameter>> properties, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.WithKeyword = Attach(withKeyword);
            this.OpenParen = Attach(openParen);
            this.Properties = Attach(properties);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 4;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return WithKeyword;
                case 1: return OpenParen;
                case 2: return Properties;
                case 3: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(WithKeyword);
                case 1: return nameof(OpenParen);
                case 2: return nameof(Properties);
                case 3: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Syntax;
                case 3: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitExternalDataWithClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitExternalDataWithClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ExternalDataWithClause((SyntaxToken)WithKeyword?.Clone(includeDiagnostics), (SyntaxToken)OpenParen?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<NamedParameter>>)Properties?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ExternalDataWithClause */
    
    #region class InlineExternalTableKindClause
    public sealed partial class InlineExternalTableKindClause : Clause
    {
        public override SyntaxKind Kind => SyntaxKind.InlineExternalTableKindClause;
        
        public SyntaxToken KindKeyword { get; }
        
        public SyntaxToken EqualToken { get; }
        
        public SyntaxToken Value { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="InlineExternalTableKindClause"/>.
        /// </summary>
        internal InlineExternalTableKindClause(SyntaxToken kindKeyword, SyntaxToken equalToken, SyntaxToken value, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.KindKeyword = Attach(kindKeyword);
            this.EqualToken = Attach(equalToken);
            this.Value = Attach(value);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return KindKeyword;
                case 1: return EqualToken;
                case 2: return Value;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(KindKeyword);
                case 1: return nameof(EqualToken);
                case 2: return nameof(Value);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Keyword;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitInlineExternalTableKindClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitInlineExternalTableKindClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new InlineExternalTableKindClause((SyntaxToken)KindKeyword?.Clone(includeDiagnostics), (SyntaxToken)EqualToken?.Clone(includeDiagnostics), (SyntaxToken)Value?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class InlineExternalTableKindClause */
    
    #region class InlineExternalTableDataFormatClause
    public sealed partial class InlineExternalTableDataFormatClause : Clause
    {
        public override SyntaxKind Kind => SyntaxKind.InlineExternalTableDataFormatClause;
        
        public SyntaxToken DataFormatKeyword { get; }
        
        public SyntaxToken EqualToken { get; }
        
        public SyntaxToken Value { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="InlineExternalTableDataFormatClause"/>.
        /// </summary>
        internal InlineExternalTableDataFormatClause(SyntaxToken dataFormatKeyword, SyntaxToken equalToken, SyntaxToken value, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.DataFormatKeyword = Attach(dataFormatKeyword);
            this.EqualToken = Attach(equalToken);
            this.Value = Attach(value);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return DataFormatKeyword;
                case 1: return EqualToken;
                case 2: return Value;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(DataFormatKeyword);
                case 1: return nameof(EqualToken);
                case 2: return nameof(Value);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Keyword;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitInlineExternalTableDataFormatClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitInlineExternalTableDataFormatClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new InlineExternalTableDataFormatClause((SyntaxToken)DataFormatKeyword?.Clone(includeDiagnostics), (SyntaxToken)EqualToken?.Clone(includeDiagnostics), (SyntaxToken)Value?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class InlineExternalTableDataFormatClause */
    
    #region class DateTimePattern
    /// <summary>
    /// datetime pattern expression in Inline External Table path format.
    /// </summary>
    public sealed partial class DateTimePattern : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.DateTimePattern;
        
        public SyntaxToken DateTimePatternKeyword { get; }
        
        public SyntaxToken OpenParen { get; }
        
        public LiteralExpression StringLiteral { get; }
        
        public SyntaxToken Comma { get; }
        
        public NameReference PartitionColumn { get; }
        
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="DateTimePattern"/>.
        /// </summary>
        internal DateTimePattern(SyntaxToken dateTimePatternKeyword, SyntaxToken openParen, LiteralExpression stringLiteral, SyntaxToken comma, NameReference partitionColumn, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.DateTimePatternKeyword = Attach(dateTimePatternKeyword);
            this.OpenParen = Attach(openParen);
            this.StringLiteral = Attach(stringLiteral);
            this.Comma = Attach(comma);
            this.PartitionColumn = Attach(partitionColumn);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 6;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return DateTimePatternKeyword;
                case 1: return OpenParen;
                case 2: return StringLiteral;
                case 3: return Comma;
                case 4: return PartitionColumn;
                case 5: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(DateTimePatternKeyword);
                case 1: return nameof(OpenParen);
                case 2: return nameof(StringLiteral);
                case 3: return nameof(Comma);
                case 4: return nameof(PartitionColumn);
                case 5: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Keyword;
                case 3: return CompletionHint.Syntax;
                case 4: return CompletionHint.Column;
                case 5: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitDateTimePattern(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitDateTimePattern(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new DateTimePattern((SyntaxToken)DateTimePatternKeyword?.Clone(includeDiagnostics), (SyntaxToken)OpenParen?.Clone(includeDiagnostics), (LiteralExpression)StringLiteral?.Clone(includeDiagnostics), (SyntaxToken)Comma?.Clone(includeDiagnostics), (NameReference)PartitionColumn?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class DateTimePattern */
    
    #region class InlineExternalTablePathFormatPartitionColumnReference
    public sealed partial class InlineExternalTablePathFormatPartitionColumnReference : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.InlineExternalTablePathFormatPartitionColumnReference;
        
        public Expression PartitionColumnExpression { get; }
        
        public LiteralExpression SeparatorLiteral { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="InlineExternalTablePathFormatPartitionColumnReference"/>.
        /// </summary>
        internal InlineExternalTablePathFormatPartitionColumnReference(Expression partitionColumnExpression, LiteralExpression separatorLiteral, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.PartitionColumnExpression = Attach(partitionColumnExpression);
            this.SeparatorLiteral = Attach(separatorLiteral, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return PartitionColumnExpression;
                case 1: return SeparatorLiteral;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(PartitionColumnExpression);
                case 1: return nameof(SeparatorLiteral);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 1:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Column;
                case 1: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitInlineExternalTablePathFormatPartitionColumnReference(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitInlineExternalTablePathFormatPartitionColumnReference(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new InlineExternalTablePathFormatPartitionColumnReference((Expression)PartitionColumnExpression?.Clone(includeDiagnostics), (LiteralExpression)SeparatorLiteral?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class InlineExternalTablePathFormatPartitionColumnReference */
    
    #region class InlineExternalTablePathFormatClause
    public sealed partial class InlineExternalTablePathFormatClause : Clause
    {
        public override SyntaxKind Kind => SyntaxKind.InlineExternalTablePathFormatClause;
        
        public SyntaxToken PathFormatKeyword { get; }
        
        public SyntaxToken EqualToken { get; }
        
        public SyntaxToken OpenParen { get; }
        
        public LiteralExpression OptionalSeparatorLiteral { get; }
        
        public SyntaxList<InlineExternalTablePathFormatPartitionColumnReference> PathExpressions { get; }
        
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="InlineExternalTablePathFormatClause"/>.
        /// </summary>
        internal InlineExternalTablePathFormatClause(SyntaxToken pathFormatKeyword, SyntaxToken equalToken, SyntaxToken openParen, LiteralExpression optionalSeparatorLiteral, SyntaxList<InlineExternalTablePathFormatPartitionColumnReference> pathExpressions, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.PathFormatKeyword = Attach(pathFormatKeyword);
            this.EqualToken = Attach(equalToken);
            this.OpenParen = Attach(openParen);
            this.OptionalSeparatorLiteral = Attach(optionalSeparatorLiteral, optional: true);
            this.PathExpressions = Attach(pathExpressions);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 6;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return PathFormatKeyword;
                case 1: return EqualToken;
                case 2: return OpenParen;
                case 3: return OptionalSeparatorLiteral;
                case 4: return PathExpressions;
                case 5: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(PathFormatKeyword);
                case 1: return nameof(EqualToken);
                case 2: return nameof(OpenParen);
                case 3: return nameof(OptionalSeparatorLiteral);
                case 4: return nameof(PathExpressions);
                case 5: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 3:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Syntax;
                case 3: return CompletionHint.Syntax;
                case 4: return CompletionHint.Column;
                case 5: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitInlineExternalTablePathFormatClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitInlineExternalTablePathFormatClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new InlineExternalTablePathFormatClause((SyntaxToken)PathFormatKeyword?.Clone(includeDiagnostics), (SyntaxToken)EqualToken?.Clone(includeDiagnostics), (SyntaxToken)OpenParen?.Clone(includeDiagnostics), (LiteralExpression)OptionalSeparatorLiteral?.Clone(includeDiagnostics), (SyntaxList<InlineExternalTablePathFormatPartitionColumnReference>)PathExpressions?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class InlineExternalTablePathFormatClause */
    
    #region class PartitionColumnDeclaration
    public sealed partial class PartitionColumnDeclaration : Expression
    {
        public override SyntaxKind Kind => SyntaxKind.PartitionColumnDeclaration;
        
        public NameDeclaration Name { get; }
        
        public SyntaxToken Colon { get; }
        
        public TypeExpression Type { get; }
        
        public SyntaxToken Equal { get; }
        
        public Expression Expr { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="PartitionColumnDeclaration"/>.
        /// </summary>
        internal PartitionColumnDeclaration(NameDeclaration name, SyntaxToken colon, TypeExpression type, SyntaxToken equal, Expression expr, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Name = Attach(name);
            this.Colon = Attach(colon);
            this.Type = Attach(type);
            this.Equal = Attach(equal, optional: true);
            this.Expr = Attach(expr, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 5;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Name;
                case 1: return Colon;
                case 2: return Type;
                case 3: return Equal;
                case 4: return Expr;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Name);
                case 1: return nameof(Colon);
                case 2: return nameof(Type);
                case 3: return nameof(Equal);
                case 4: return nameof(Expr);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 3:
                case 4:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Declaration;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Syntax;
                case 3: return CompletionHint.Syntax;
                case 4: return CompletionHint.Column;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitPartitionColumnDeclaration(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitPartitionColumnDeclaration(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new PartitionColumnDeclaration((NameDeclaration)Name?.Clone(includeDiagnostics), (SyntaxToken)Colon?.Clone(includeDiagnostics), (TypeExpression)Type?.Clone(includeDiagnostics), (SyntaxToken)Equal?.Clone(includeDiagnostics), (Expression)Expr?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class PartitionColumnDeclaration */
    
    #region class InlineExternalTablePartitionClause
    /// <summary>
    /// A clause that specifies the partitioning for inline external table.
    /// </summary>
    public sealed partial class InlineExternalTablePartitionClause : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.InlineExternalTablePartitionClause;
        
        public SyntaxToken PartitionKeyword { get; }
        
        public SyntaxToken ByKeyword { get; }
        
        public SyntaxToken OpenParen { get; }
        
        public SyntaxToken LeadingComma { get; }
        
        public SyntaxList<SeparatedElement<PartitionColumnDeclaration>> PartitionColumns { get; }
        
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="InlineExternalTablePartitionClause"/>.
        /// </summary>
        internal InlineExternalTablePartitionClause(SyntaxToken partitionKeyword, SyntaxToken byKeyword, SyntaxToken openParen, SyntaxToken leadingComma, SyntaxList<SeparatedElement<PartitionColumnDeclaration>> partitionColumns, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.PartitionKeyword = Attach(partitionKeyword);
            this.ByKeyword = Attach(byKeyword);
            this.OpenParen = Attach(openParen);
            this.LeadingComma = Attach(leadingComma, optional: true);
            this.PartitionColumns = Attach(partitionColumns);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 6;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return PartitionKeyword;
                case 1: return ByKeyword;
                case 2: return OpenParen;
                case 3: return LeadingComma;
                case 4: return PartitionColumns;
                case 5: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(PartitionKeyword);
                case 1: return nameof(ByKeyword);
                case 2: return nameof(OpenParen);
                case 3: return nameof(LeadingComma);
                case 4: return nameof(PartitionColumns);
                case 5: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 3:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Keyword;
                case 2: return CompletionHint.Syntax;
                case 3: return CompletionHint.Syntax;
                case 4: return CompletionHint.Declaration;
                case 5: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitInlineExternalTablePartitionClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitInlineExternalTablePartitionClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new InlineExternalTablePartitionClause((SyntaxToken)PartitionKeyword?.Clone(includeDiagnostics), (SyntaxToken)ByKeyword?.Clone(includeDiagnostics), (SyntaxToken)OpenParen?.Clone(includeDiagnostics), (SyntaxToken)LeadingComma?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<PartitionColumnDeclaration>>)PartitionColumns?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class InlineExternalTablePartitionClause */
    
    #region class InlineExternalTableConnectionStringsClause
    /// <summary>
    /// A clause that specifies list of connection strings for inline external table.
    /// </summary>
    public sealed partial class InlineExternalTableConnectionStringsClause : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.InlineExternalTableConnectionStringsClause;
        
        public SyntaxToken OpenParen { get; }
        
        public SyntaxList<SeparatedElement<Expression>> ConnectionStrings { get; }
        
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="InlineExternalTableConnectionStringsClause"/>.
        /// </summary>
        internal InlineExternalTableConnectionStringsClause(SyntaxToken openParen, SyntaxList<SeparatedElement<Expression>> connectionStrings, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.OpenParen = Attach(openParen);
            this.ConnectionStrings = Attach(connectionStrings);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return OpenParen;
                case 1: return ConnectionStrings;
                case 2: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(OpenParen);
                case 1: return nameof(ConnectionStrings);
                case 2: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.None;
                case 2: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitInlineExternalTableConnectionStringsClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitInlineExternalTableConnectionStringsClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new InlineExternalTableConnectionStringsClause((SyntaxToken)OpenParen?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Expression>>)ConnectionStrings?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class InlineExternalTableConnectionStringsClause */
    
    #region class InlineExternalTableExpression
    /// <summary>
    /// A node in the kusto syntax that represents an inline external table expression.
    /// </summary>
    public sealed partial class InlineExternalTableExpression : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.InlineExternalTableExpression;
        
        public SyntaxToken InlineExternalTableKeyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public RowSchema Schema { get; }
        
        public InlineExternalTableKindClause KindParameter { get; }
        
        public InlineExternalTablePartitionClause PartitionClause { get; }
        
        public InlineExternalTablePathFormatClause PathFormat { get; }
        
        public InlineExternalTableDataFormatClause DataFormatParameter { get; }
        
        public InlineExternalTableConnectionStringsClause ConnectionStrings { get; }
        
        public ExternalDataWithClause WithClause { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="InlineExternalTableExpression"/>.
        /// </summary>
        internal InlineExternalTableExpression(SyntaxToken inlineExternalTableKeyword, SyntaxList<NamedParameter> parameters, RowSchema schema, InlineExternalTableKindClause kindParameter, InlineExternalTablePartitionClause partitionClause, InlineExternalTablePathFormatClause pathFormat, InlineExternalTableDataFormatClause dataFormatParameter, InlineExternalTableConnectionStringsClause connectionStrings, ExternalDataWithClause withClause, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.InlineExternalTableKeyword = Attach(inlineExternalTableKeyword);
            this.Parameters = Attach(parameters);
            this.Schema = Attach(schema);
            this.KindParameter = Attach(kindParameter);
            this.PartitionClause = Attach(partitionClause, optional: true);
            this.PathFormat = Attach(pathFormat, optional: true);
            this.DataFormatParameter = Attach(dataFormatParameter);
            this.ConnectionStrings = Attach(connectionStrings);
            this.WithClause = Attach(withClause, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 9;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return InlineExternalTableKeyword;
                case 1: return Parameters;
                case 2: return Schema;
                case 3: return KindParameter;
                case 4: return PartitionClause;
                case 5: return PathFormat;
                case 6: return DataFormatParameter;
                case 7: return ConnectionStrings;
                case 8: return WithClause;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(InlineExternalTableKeyword);
                case 1: return nameof(Parameters);
                case 2: return nameof(Schema);
                case 3: return nameof(KindParameter);
                case 4: return nameof(PartitionClause);
                case 5: return nameof(PathFormat);
                case 6: return nameof(DataFormatParameter);
                case 7: return nameof(ConnectionStrings);
                case 8: return nameof(WithClause);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 4:
                case 5:
                case 8:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.None;
                case 2: return CompletionHint.Syntax;
                case 3: return CompletionHint.Syntax;
                case 4: return CompletionHint.Syntax;
                case 5: return CompletionHint.Syntax;
                case 6: return CompletionHint.Syntax;
                case 7: return CompletionHint.Syntax;
                case 8: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitInlineExternalTableExpression(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitInlineExternalTableExpression(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new InlineExternalTableExpression((SyntaxToken)InlineExternalTableKeyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (RowSchema)Schema?.Clone(includeDiagnostics), (InlineExternalTableKindClause)KindParameter?.Clone(includeDiagnostics), (InlineExternalTablePartitionClause)PartitionClause?.Clone(includeDiagnostics), (InlineExternalTablePathFormatClause)PathFormat?.Clone(includeDiagnostics), (InlineExternalTableDataFormatClause)DataFormatParameter?.Clone(includeDiagnostics), (InlineExternalTableConnectionStringsClause)ConnectionStrings?.Clone(includeDiagnostics), (ExternalDataWithClause)WithClause?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class InlineExternalTableExpression */
    
    #region class JoinOperator
    public sealed partial class JoinOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.JoinOperator;
        
        public SyntaxToken JoinKeyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public Expression Expression { get; }
        
        public JoinConditionClause ConditionClause { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="JoinOperator"/>.
        /// </summary>
        internal JoinOperator(SyntaxToken joinKeyword, SyntaxList<NamedParameter> parameters, Expression expression, JoinConditionClause conditionClause, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.JoinKeyword = Attach(joinKeyword);
            this.Parameters = Attach(parameters);
            this.Expression = Attach(expression);
            this.ConditionClause = Attach(conditionClause, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 4;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return JoinKeyword;
                case 1: return Parameters;
                case 2: return Expression;
                case 3: return ConditionClause;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(JoinKeyword);
                case 1: return nameof(Parameters);
                case 2: return nameof(Expression);
                case 3: return nameof(ConditionClause);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 3:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.NonScalar;
                case 3: return CompletionHint.Clause;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitJoinOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitJoinOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new JoinOperator((SyntaxToken)JoinKeyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (JoinConditionClause)ConditionClause?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class JoinOperator */
    
    #region class LookupOperator
    public sealed partial class LookupOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.LookupOperator;
        
        public SyntaxToken LookupKeyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public Expression Expression { get; }
        
        public JoinConditionClause LookupClause { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="LookupOperator"/>.
        /// </summary>
        internal LookupOperator(SyntaxToken lookupKeyword, SyntaxList<NamedParameter> parameters, Expression expression, JoinConditionClause lookupClause, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.LookupKeyword = Attach(lookupKeyword);
            this.Parameters = Attach(parameters);
            this.Expression = Attach(expression);
            this.LookupClause = Attach(lookupClause);
            this.Init();
        }
        
        public override int ChildCount => 4;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return LookupKeyword;
                case 1: return Parameters;
                case 2: return Expression;
                case 3: return LookupClause;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(LookupKeyword);
                case 1: return nameof(Parameters);
                case 2: return nameof(Expression);
                case 3: return nameof(LookupClause);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.NonScalar;
                case 3: return CompletionHint.Clause;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitLookupOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitLookupOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new LookupOperator((SyntaxToken)LookupKeyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (JoinConditionClause)LookupClause?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class LookupOperator */
    
    #region class JoinConditionClause
    public abstract partial class JoinConditionClause : Clause
    {
        /// <summary>
        /// Constructs a new instance of <see cref="JoinConditionClause"/>.
        /// </summary>
        internal JoinConditionClause(IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
        }
    }
    #endregion /* class JoinConditionClause */
    
    #region class JoinOnClause
    public sealed partial class JoinOnClause : JoinConditionClause
    {
        public override SyntaxKind Kind => SyntaxKind.JoinOnClause;
        
        public SyntaxToken OnKeyword { get; }
        
        public SyntaxList<SeparatedElement<Expression>> Expressions { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="JoinOnClause"/>.
        /// </summary>
        internal JoinOnClause(SyntaxToken onKeyword, SyntaxList<SeparatedElement<Expression>> expressions, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.OnKeyword = Attach(onKeyword);
            this.Expressions = Attach(expressions);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return OnKeyword;
                case 1: return Expressions;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(OnKeyword);
                case 1: return nameof(Expressions);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Column;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitJoinOnClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitJoinOnClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new JoinOnClause((SyntaxToken)OnKeyword?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Expression>>)Expressions?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class JoinOnClause */
    
    #region class JoinWhereClause
    public sealed partial class JoinWhereClause : JoinConditionClause
    {
        public override SyntaxKind Kind => SyntaxKind.JoinWhereClause;
        
        public SyntaxToken WhereKeyword { get; }
        
        public Expression Expression { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="JoinWhereClause"/>.
        /// </summary>
        internal JoinWhereClause(SyntaxToken whereKeyword, Expression expression, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.WhereKeyword = Attach(whereKeyword);
            this.Expression = Attach(expression);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return WhereKeyword;
                case 1: return Expression;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(WhereKeyword);
                case 1: return nameof(Expression);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Boolean;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitJoinWhereClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitJoinWhereClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new JoinWhereClause((SyntaxToken)WhereKeyword?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class JoinWhereClause */
    
    #region class ScanOperator
    public sealed partial class ScanOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.ScanOperator;
        
        public SyntaxToken ScanKeyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public ScanOrderByClause OrderByClause { get; }
        
        public ScanPartitionByClause PartitionByClause { get; }
        
        public ScanDeclareClause DeclareClause { get; }
        
        public SyntaxToken WithKeyword { get; }
        
        public SyntaxToken OpenParenToken { get; }
        
        public SyntaxList<ScanStep> Steps { get; }
        
        public SyntaxToken CloseParenToken { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ScanOperator"/>.
        /// </summary>
        internal ScanOperator(SyntaxToken scanKeyword, SyntaxList<NamedParameter> parameters, ScanOrderByClause orderByClause, ScanPartitionByClause partitionByClause, ScanDeclareClause declareClause, SyntaxToken withKeyword, SyntaxToken openParenToken, SyntaxList<ScanStep> steps, SyntaxToken closeParenToken, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.ScanKeyword = Attach(scanKeyword);
            this.Parameters = Attach(parameters);
            this.OrderByClause = Attach(orderByClause, optional: true);
            this.PartitionByClause = Attach(partitionByClause, optional: true);
            this.DeclareClause = Attach(declareClause, optional: true);
            this.WithKeyword = Attach(withKeyword);
            this.OpenParenToken = Attach(openParenToken, optional: true);
            this.Steps = Attach(steps);
            this.CloseParenToken = Attach(closeParenToken, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 9;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return ScanKeyword;
                case 1: return Parameters;
                case 2: return OrderByClause;
                case 3: return PartitionByClause;
                case 4: return DeclareClause;
                case 5: return WithKeyword;
                case 6: return OpenParenToken;
                case 7: return Steps;
                case 8: return CloseParenToken;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(ScanKeyword);
                case 1: return nameof(Parameters);
                case 2: return nameof(OrderByClause);
                case 3: return nameof(PartitionByClause);
                case 4: return nameof(DeclareClause);
                case 5: return nameof(WithKeyword);
                case 6: return nameof(OpenParenToken);
                case 7: return nameof(Steps);
                case 8: return nameof(CloseParenToken);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 2:
                case 3:
                case 4:
                case 6:
                case 8:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Syntax;
                case 3: return CompletionHint.Syntax;
                case 4: return CompletionHint.Syntax;
                case 5: return CompletionHint.Keyword;
                case 6: return CompletionHint.Syntax;
                case 7: return CompletionHint.Syntax;
                case 8: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitScanOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitScanOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ScanOperator((SyntaxToken)ScanKeyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (ScanOrderByClause)OrderByClause?.Clone(includeDiagnostics), (ScanPartitionByClause)PartitionByClause?.Clone(includeDiagnostics), (ScanDeclareClause)DeclareClause?.Clone(includeDiagnostics), (SyntaxToken)WithKeyword?.Clone(includeDiagnostics), (SyntaxToken)OpenParenToken?.Clone(includeDiagnostics), (SyntaxList<ScanStep>)Steps?.Clone(includeDiagnostics), (SyntaxToken)CloseParenToken?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ScanOperator */
    
    #region class AssertSchemaOperator
    public sealed partial class AssertSchemaOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.AssertSchemaOperator;
        
        public SyntaxToken AssertSchemaKeyword { get; }
        
        public RowSchema Schema { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="AssertSchemaOperator"/>.
        /// </summary>
        internal AssertSchemaOperator(SyntaxToken assertSchemaKeyword, RowSchema schema, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.AssertSchemaKeyword = Attach(assertSchemaKeyword);
            this.Schema = Attach(schema);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return AssertSchemaKeyword;
                case 1: return Schema;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(AssertSchemaKeyword);
                case 1: return nameof(Schema);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitAssertSchemaOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitAssertSchemaOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new AssertSchemaOperator((SyntaxToken)AssertSchemaKeyword?.Clone(includeDiagnostics), (RowSchema)Schema?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class AssertSchemaOperator */
    
    #region class ScanDeclareClause
    public sealed partial class ScanDeclareClause : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.ScanDeclareClause;
        
        public SyntaxToken DeclareKeyword { get; }
        
        public SyntaxToken OpenParen { get; }
        
        public SyntaxList<SeparatedElement<FunctionParameter>> Declarations { get; }
        
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ScanDeclareClause"/>.
        /// </summary>
        internal ScanDeclareClause(SyntaxToken declareKeyword, SyntaxToken openParen, SyntaxList<SeparatedElement<FunctionParameter>> declarations, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.DeclareKeyword = Attach(declareKeyword);
            this.OpenParen = Attach(openParen);
            this.Declarations = Attach(declarations);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 4;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return DeclareKeyword;
                case 1: return OpenParen;
                case 2: return Declarations;
                case 3: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(DeclareKeyword);
                case 1: return nameof(OpenParen);
                case 2: return nameof(Declarations);
                case 3: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Syntax;
                case 3: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitScanDeclareClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitScanDeclareClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ScanDeclareClause((SyntaxToken)DeclareKeyword?.Clone(includeDiagnostics), (SyntaxToken)OpenParen?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<FunctionParameter>>)Declarations?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ScanDeclareClause */
    
    #region class ScanOrderByClause
    public sealed partial class ScanOrderByClause : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.ScanOrderByClause;
        
        public SyntaxToken OrderKeyword { get; }
        
        public SyntaxToken ByKeyword { get; }
        
        public SyntaxList<SeparatedElement<Expression>> Expressions { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ScanOrderByClause"/>.
        /// </summary>
        internal ScanOrderByClause(SyntaxToken orderKeyword, SyntaxToken byKeyword, SyntaxList<SeparatedElement<Expression>> expressions, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.OrderKeyword = Attach(orderKeyword);
            this.ByKeyword = Attach(byKeyword);
            this.Expressions = Attach(expressions);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return OrderKeyword;
                case 1: return ByKeyword;
                case 2: return Expressions;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(OrderKeyword);
                case 1: return nameof(ByKeyword);
                case 2: return nameof(Expressions);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Keyword;
                case 2: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitScanOrderByClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitScanOrderByClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ScanOrderByClause((SyntaxToken)OrderKeyword?.Clone(includeDiagnostics), (SyntaxToken)ByKeyword?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Expression>>)Expressions?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ScanOrderByClause */
    
    #region class ScanPartitionByClause
    public sealed partial class ScanPartitionByClause : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.ScanPartitionByClause;
        
        public SyntaxToken PartitionKeyword { get; }
        
        public SyntaxToken ByKeyword { get; }
        
        public SyntaxList<SeparatedElement<Expression>> Expressions { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ScanPartitionByClause"/>.
        /// </summary>
        internal ScanPartitionByClause(SyntaxToken partitionKeyword, SyntaxToken byKeyword, SyntaxList<SeparatedElement<Expression>> expressions, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.PartitionKeyword = Attach(partitionKeyword);
            this.ByKeyword = Attach(byKeyword);
            this.Expressions = Attach(expressions);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return PartitionKeyword;
                case 1: return ByKeyword;
                case 2: return Expressions;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(PartitionKeyword);
                case 1: return nameof(ByKeyword);
                case 2: return nameof(Expressions);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Keyword;
                case 2: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitScanPartitionByClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitScanPartitionByClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ScanPartitionByClause((SyntaxToken)PartitionKeyword?.Clone(includeDiagnostics), (SyntaxToken)ByKeyword?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Expression>>)Expressions?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ScanPartitionByClause */
    
    #region class ScanStepOutput
    public sealed partial class ScanStepOutput : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.ScanStepOutput;
        
        public SyntaxToken OutputKeyword { get; }
        
        public SyntaxToken EqualToken { get; }
        
        public SyntaxToken OutputKind { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ScanStepOutput"/>.
        /// </summary>
        internal ScanStepOutput(SyntaxToken outputKeyword, SyntaxToken equalToken, SyntaxToken outputKind, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.OutputKeyword = Attach(outputKeyword);
            this.EqualToken = Attach(equalToken);
            this.OutputKind = Attach(outputKind);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return OutputKeyword;
                case 1: return EqualToken;
                case 2: return OutputKind;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(OutputKeyword);
                case 1: return nameof(EqualToken);
                case 2: return nameof(OutputKind);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Keyword;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitScanStepOutput(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitScanStepOutput(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ScanStepOutput((SyntaxToken)OutputKeyword?.Clone(includeDiagnostics), (SyntaxToken)EqualToken?.Clone(includeDiagnostics), (SyntaxToken)OutputKind?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ScanStepOutput */
    
    #region class ScanStep
    public sealed partial class ScanStep : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.ScanStep;
        
        public SyntaxToken StepKeyword { get; }
        
        public NameDeclaration Name { get; }
        
        public SyntaxToken OptionalKeyword { get; }
        
        public ScanStepOutput ScanStepOutput { get; }
        
        public SyntaxToken ColonToken { get; }
        
        public Expression Condition { get; }
        
        public ScanComputationClause ComputationClause { get; }
        
        public SyntaxToken SemicolonToken { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ScanStep"/>.
        /// </summary>
        internal ScanStep(SyntaxToken stepKeyword, NameDeclaration name, SyntaxToken optionalKeyword, ScanStepOutput scanStepOutput, SyntaxToken colonToken, Expression condition, ScanComputationClause computationClause, SyntaxToken semicolonToken, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.StepKeyword = Attach(stepKeyword);
            this.Name = Attach(name);
            this.OptionalKeyword = Attach(optionalKeyword, optional: true);
            this.ScanStepOutput = Attach(scanStepOutput, optional: true);
            this.ColonToken = Attach(colonToken);
            this.Condition = Attach(condition);
            this.ComputationClause = Attach(computationClause, optional: true);
            this.SemicolonToken = Attach(semicolonToken);
            this.Init();
        }
        
        public override int ChildCount => 8;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return StepKeyword;
                case 1: return Name;
                case 2: return OptionalKeyword;
                case 3: return ScanStepOutput;
                case 4: return ColonToken;
                case 5: return Condition;
                case 6: return ComputationClause;
                case 7: return SemicolonToken;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(StepKeyword);
                case 1: return nameof(Name);
                case 2: return nameof(OptionalKeyword);
                case 3: return nameof(ScanStepOutput);
                case 4: return nameof(ColonToken);
                case 5: return nameof(Condition);
                case 6: return nameof(ComputationClause);
                case 7: return nameof(SemicolonToken);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 2:
                case 3:
                case 6:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Keyword;
                case 3: return CompletionHint.Syntax;
                case 4: return CompletionHint.Syntax;
                case 5: return CompletionHint.Scalar;
                case 6: return CompletionHint.Syntax;
                case 7: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitScanStep(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitScanStep(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ScanStep((SyntaxToken)StepKeyword?.Clone(includeDiagnostics), (NameDeclaration)Name?.Clone(includeDiagnostics), (SyntaxToken)OptionalKeyword?.Clone(includeDiagnostics), (ScanStepOutput)ScanStepOutput?.Clone(includeDiagnostics), (SyntaxToken)ColonToken?.Clone(includeDiagnostics), (Expression)Condition?.Clone(includeDiagnostics), (ScanComputationClause)ComputationClause?.Clone(includeDiagnostics), (SyntaxToken)SemicolonToken?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ScanStep */
    
    #region class ScanComputationClause
    public sealed partial class ScanComputationClause : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.ScanComputationClause;
        
        public SyntaxToken ArrowToken { get; }
        
        public SyntaxList<SeparatedElement<ScanAssignment>> Assignments { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ScanComputationClause"/>.
        /// </summary>
        internal ScanComputationClause(SyntaxToken arrowToken, SyntaxList<SeparatedElement<ScanAssignment>> assignments, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.ArrowToken = Attach(arrowToken);
            this.Assignments = Attach(assignments);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return ArrowToken;
                case 1: return Assignments;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(ArrowToken);
                case 1: return nameof(Assignments);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.Column;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitScanComputationClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitScanComputationClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ScanComputationClause((SyntaxToken)ArrowToken?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<ScanAssignment>>)Assignments?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ScanComputationClause */
    
    #region class ScanAssignment
    public sealed partial class ScanAssignment : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.ScanAssignment;
        
        public NameReference Name { get; }
        
        public SyntaxToken EqualToken { get; }
        
        public Expression Expression { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="ScanAssignment"/>.
        /// </summary>
        internal ScanAssignment(NameReference name, SyntaxToken equalToken, Expression expression, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Name = Attach(name);
            this.EqualToken = Attach(equalToken);
            this.Expression = Attach(expression);
            this.Init();
        }
        
        public override int ChildCount => 3;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Name;
                case 1: return EqualToken;
                case 2: return Expression;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Name);
                case 1: return nameof(EqualToken);
                case 2: return nameof(Expression);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Column;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Scalar;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitScanAssignment(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitScanAssignment(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new ScanAssignment((NameReference)Name?.Clone(includeDiagnostics), (SyntaxToken)EqualToken?.Clone(includeDiagnostics), (Expression)Expression?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class ScanAssignment */
    
    #region class PartitionByOperator
    public sealed partial class PartitionByOperator : QueryOperator
    {
        public override SyntaxKind Kind => SyntaxKind.PartitionByOperator;
        
        public SyntaxToken PartitionByKeyword { get; }
        
        public SyntaxList<NamedParameter> Parameters { get; }
        
        public Expression Entity { get; }
        
        public PartitionByIdClause IdClause { get; }
        
        public SyntaxToken OpenParen { get; }
        
        public Expression Subquery { get; }
        
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="PartitionByOperator"/>.
        /// </summary>
        internal PartitionByOperator(SyntaxToken partitionByKeyword, SyntaxList<NamedParameter> parameters, Expression entity, PartitionByIdClause idClause, SyntaxToken openParen, Expression subquery, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.PartitionByKeyword = Attach(partitionByKeyword);
            this.Parameters = Attach(parameters);
            this.Entity = Attach(entity);
            this.IdClause = Attach(idClause, optional: true);
            this.OpenParen = Attach(openParen);
            this.Subquery = Attach(subquery);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 7;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return PartitionByKeyword;
                case 1: return Parameters;
                case 2: return Entity;
                case 3: return IdClause;
                case 4: return OpenParen;
                case 5: return Subquery;
                case 6: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(PartitionByKeyword);
                case 1: return nameof(Parameters);
                case 2: return nameof(Entity);
                case 3: return nameof(IdClause);
                case 4: return nameof(OpenParen);
                case 5: return nameof(Subquery);
                case 6: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 3:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Syntax;
                case 2: return CompletionHint.Column;
                case 3: return CompletionHint.Syntax;
                case 4: return CompletionHint.Syntax;
                case 5: return CompletionHint.Query;
                case 6: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitPartitionByOperator(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitPartitionByOperator(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new PartitionByOperator((SyntaxToken)PartitionByKeyword?.Clone(includeDiagnostics), (SyntaxList<NamedParameter>)Parameters?.Clone(includeDiagnostics), (Expression)Entity?.Clone(includeDiagnostics), (PartitionByIdClause)IdClause?.Clone(includeDiagnostics), (SyntaxToken)OpenParen?.Clone(includeDiagnostics), (Expression)Subquery?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class PartitionByOperator */
    
    #region class PartitionByIdClause
    public sealed partial class PartitionByIdClause : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.PartitionByIdClause;
        
        public SyntaxToken IdKeyword { get; }
        
        public Expression Value { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="PartitionByIdClause"/>.
        /// </summary>
        internal PartitionByIdClause(SyntaxToken idKeyword, Expression value, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.IdKeyword = Attach(idKeyword);
            this.Value = Attach(value);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return IdKeyword;
                case 1: return Value;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(IdKeyword);
                case 1: return nameof(Value);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Literal;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitPartitionByIdClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitPartitionByIdClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new PartitionByIdClause((SyntaxToken)IdKeyword?.Clone(includeDiagnostics), (Expression)Value?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class PartitionByIdClause */
    
    #region class CommandWithClause
    public abstract partial class CommandWithClause : Clause
    {
        /// <summary>
        /// Constructs a new instance of <see cref="CommandWithClause"/>.
        /// </summary>
        internal CommandWithClause(IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
        }
    }
    #endregion /* class CommandWithClause */
    
    #region class CommandWithValueClause
    public sealed partial class CommandWithValueClause : CommandWithClause
    {
        public override SyntaxKind Kind => SyntaxKind.CommandWithValueClause;
        
        public SyntaxToken WithKeyword { get; }
        
        public Expression Value { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="CommandWithValueClause"/>.
        /// </summary>
        internal CommandWithValueClause(SyntaxToken withKeyword, Expression value, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.WithKeyword = Attach(withKeyword);
            this.Value = Attach(value, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return WithKeyword;
                case 1: return Value;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(WithKeyword);
                case 1: return nameof(Value);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 1:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Literal;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitCommandWithValueClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitCommandWithValueClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new CommandWithValueClause((SyntaxToken)WithKeyword?.Clone(includeDiagnostics), (Expression)Value?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class CommandWithValueClause */
    
    #region class CommandWithPropertyListClause
    public sealed partial class CommandWithPropertyListClause : CommandWithClause
    {
        public override SyntaxKind Kind => SyntaxKind.CommandWithPropertyListClause;
        
        public SyntaxToken WithKeyword { get; }
        
        public SyntaxToken OpenParen { get; }
        
        public SyntaxList<SeparatedElement<NamedParameter>> Properties { get; }
        
        public SyntaxToken CloseParen { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="CommandWithPropertyListClause"/>.
        /// </summary>
        internal CommandWithPropertyListClause(SyntaxToken withKeyword, SyntaxToken openParen, SyntaxList<SeparatedElement<NamedParameter>> properties, SyntaxToken closeParen, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.WithKeyword = Attach(withKeyword);
            this.OpenParen = Attach(openParen);
            this.Properties = Attach(properties);
            this.CloseParen = Attach(closeParen);
            this.Init();
        }
        
        public override int ChildCount => 4;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return WithKeyword;
                case 1: return OpenParen;
                case 2: return Properties;
                case 3: return CloseParen;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(WithKeyword);
                case 1: return nameof(OpenParen);
                case 2: return nameof(Properties);
                case 3: return nameof(CloseParen);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Keyword;
                case 1: return CompletionHint.Keyword;
                case 2: return CompletionHint.Scalar;
                case 3: return CompletionHint.Keyword;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitCommandWithPropertyListClause(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitCommandWithPropertyListClause(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new CommandWithPropertyListClause((SyntaxToken)WithKeyword?.Clone(includeDiagnostics), (SyntaxToken)OpenParen?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<NamedParameter>>)Properties?.Clone(includeDiagnostics), (SyntaxToken)CloseParen?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class CommandWithPropertyListClause */
    
    #region class Command
    public abstract partial class Command : Expression
    {
        /// <summary>
        /// Constructs a new instance of <see cref="Command"/>.
        /// </summary>
        internal Command(IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
        }
    }
    #endregion /* class Command */
    
    #region class UnknownCommand
    public sealed partial class UnknownCommand : Command
    {
        public override SyntaxKind Kind => SyntaxKind.UnknownCommand;
        
        public SyntaxToken DotToken { get; }
        
        public SyntaxList<SyntaxElement> Parts { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="UnknownCommand"/>.
        /// </summary>
        internal UnknownCommand(SyntaxToken dotToken, SyntaxList<SyntaxElement> parts, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.DotToken = Attach(dotToken);
            this.Parts = Attach(parts);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return DotToken;
                case 1: return Parts;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(DotToken);
                case 1: return nameof(Parts);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitUnknownCommand(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitUnknownCommand(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new UnknownCommand((SyntaxToken)DotToken?.Clone(includeDiagnostics), (SyntaxList<SyntaxElement>)Parts?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class UnknownCommand */
    
    #region class CustomCommand
    public sealed partial class CustomCommand : Command
    {
        public override SyntaxKind Kind => SyntaxKind.CustomCommand;
        
        public string CommandKind { get; }
        
        public SyntaxToken DotToken { get; }
        
        public SyntaxElement Custom { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="CustomCommand"/>.
        /// </summary>
        internal CustomCommand(string commandKind, SyntaxToken dotToken, SyntaxElement custom, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.CommandKind = commandKind;
            this.DotToken = Attach(dotToken);
            this.Custom = Attach(custom);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return DotToken;
                case 1: return Custom;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(DotToken);
                case 1: return nameof(Custom);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitCustomCommand(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitCustomCommand(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new CustomCommand(CommandKind, (SyntaxToken)DotToken?.Clone(includeDiagnostics), (SyntaxElement)Custom?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class CustomCommand */
    
    #region class PartialCommand
    public sealed partial class PartialCommand : Command
    {
        public override SyntaxKind Kind => SyntaxKind.PartialCommand;
        
        public IReadOnlyList<string> CommandKinds { get; }
        
        public SyntaxToken DotToken { get; }
        
        public SyntaxList<SyntaxElement> Parts { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="PartialCommand"/>.
        /// </summary>
        internal PartialCommand(IReadOnlyList<string> commandKinds, SyntaxToken dotToken, SyntaxList<SyntaxElement> parts, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.CommandKinds = commandKinds;
            this.DotToken = Attach(dotToken);
            this.Parts = Attach(parts);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return DotToken;
                case 1: return Parts;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(DotToken);
                case 1: return nameof(Parts);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                case 1: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitPartialCommand(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitPartialCommand(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new PartialCommand(CommandKinds, (SyntaxToken)DotToken?.Clone(includeDiagnostics), (SyntaxList<SyntaxElement>)Parts?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class PartialCommand */
    
    #region class CommandAndSkippedTokens
    public sealed partial class CommandAndSkippedTokens : Command
    {
        public override SyntaxKind Kind => SyntaxKind.CommandAndSkippedTokens;
        
        public Command Command { get; }
        
        public SkippedTokens SkippedTokens { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="CommandAndSkippedTokens"/>.
        /// </summary>
        internal CommandAndSkippedTokens(Command command, SkippedTokens skippedTokens, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Command = Attach(command);
            this.SkippedTokens = Attach(skippedTokens, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 2;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Command;
                case 1: return SkippedTokens;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Command);
                case 1: return nameof(SkippedTokens);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 1:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.NonScalar;
                case 1: return CompletionHint.None;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitCommandAndSkippedTokens(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitCommandAndSkippedTokens(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new CommandAndSkippedTokens((Command)Command?.Clone(includeDiagnostics), (SkippedTokens)SkippedTokens?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class CommandAndSkippedTokens */
    
    #region class BadCommand
    public sealed partial class BadCommand : Command
    {
        public override SyntaxKind Kind => SyntaxKind.BadCommand;
        
        public SyntaxToken DotToken { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="BadCommand"/>.
        /// </summary>
        internal BadCommand(SyntaxToken dotToken, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.DotToken = Attach(dotToken);
            this.Init();
        }
        
        public override int ChildCount => 1;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return DotToken;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(DotToken);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.Syntax;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitBadCommand(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitBadCommand(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new BadCommand((SyntaxToken)DotToken?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class BadCommand */
    
    #region class CommandBlock
    public sealed partial class CommandBlock : SyntaxNode
    {
        public override SyntaxKind Kind => SyntaxKind.CommandBlock;
        
        public SyntaxList<Directive> Directives { get; }
        
        public SyntaxList<SeparatedElement<Statement>> Statements { get; }
        
        public SkippedTokens SkippedTokens { get; }
        
        public SyntaxToken EndOfCommand { get; }
        
        /// <summary>
        /// Constructs a new instance of <see cref="CommandBlock"/>.
        /// </summary>
        internal CommandBlock(SyntaxList<Directive> directives, SyntaxList<SeparatedElement<Statement>> statements, SkippedTokens skippedTokens, SyntaxToken endOfCommand, IReadOnlyList<Diagnostic> diagnostics = null) : base(diagnostics)
        {
            this.Directives = Attach(directives);
            this.Statements = Attach(statements);
            this.SkippedTokens = Attach(skippedTokens, optional: true);
            this.EndOfCommand = Attach(endOfCommand, optional: true);
            this.Init();
        }
        
        public override int ChildCount => 4;
        
        public override SyntaxElement GetChild(int index)
        {
            switch (index)
            {
                case 0: return Directives;
                case 1: return Statements;
                case 2: return SkippedTokens;
                case 3: return EndOfCommand;
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override string GetName(int index)
        {
            switch (index)
            {
                case 0: return nameof(Directives);
                case 1: return nameof(Statements);
                case 2: return nameof(SkippedTokens);
                case 3: return nameof(EndOfCommand);
                default: throw new ArgumentOutOfRangeException();
            }
        }
        
        public override bool IsOptional(int index)
        {
            switch (index)
            {
                case 2:
                case 3:
                    return true;
                default:
                    return false;
            }
        }
        
        protected override CompletionHint GetCompletionHintCore(int index)
        {
            switch (index)
            {
                case 0: return CompletionHint.None;
                case 1: return CompletionHint.NonScalar;
                case 2: return CompletionHint.None;
                case 3: return CompletionHint.None;
                default: return CompletionHint.Inherit;
            }
        }
        
        public override void Accept(SyntaxVisitor visitor)
        {
            visitor.VisitCommandBlock(this);
        }
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitCommandBlock(this);
        }
        
        protected override SyntaxElement CloneCore(bool includeDiagnostics)
        {
            return new CommandBlock((SyntaxList<Directive>)Directives?.Clone(includeDiagnostics), (SyntaxList<SeparatedElement<Statement>>)Statements?.Clone(includeDiagnostics), (SkippedTokens)SkippedTokens?.Clone(includeDiagnostics), (SyntaxToken)EndOfCommand?.Clone(includeDiagnostics), (includeDiagnostics ? this.SyntaxDiagnostics : null));
        }
    }
    #endregion /* class CommandBlock */
    #endregion /* SyntaxNodes */
    
    #region Visitors
    #region SyntaxVisitor
    public partial class SyntaxVisitor
    {
        public abstract void VisitDirectiveBlock(DirectiveBlock node);
        public abstract void VisitDirective(Directive node);
        public abstract void VisitSkippedTokens(SkippedTokens node);
        public abstract void VisitQueryBlock(QueryBlock node);
        public abstract void VisitTypeOfLiteralExpression(TypeOfLiteralExpression node);
        public abstract void VisitBadQueryOperator(BadQueryOperator node);
        public abstract void VisitCompoundStringLiteralExpression(CompoundStringLiteralExpression node);
        public abstract void VisitTokenName(TokenName node);
        public abstract void VisitBracketedName(BracketedName node);
        public abstract void VisitBracedName(BracedName node);
        public abstract void VisitWildcardedName(WildcardedName node);
        public abstract void VisitBracketedWildcardedName(BracketedWildcardedName node);
        public abstract void VisitNameDeclaration(NameDeclaration node);
        public abstract void VisitNameReference(NameReference node);
        public abstract void VisitLiteralExpression(LiteralExpression node);
        public abstract void VisitStarExpression(StarExpression node);
        public abstract void VisitAtExpression(AtExpression node);
        public abstract void VisitJsonPair(JsonPair node);
        public abstract void VisitJsonObjectExpression(JsonObjectExpression node);
        public abstract void VisitJsonArrayExpression(JsonArrayExpression node);
        public abstract void VisitDynamicExpression(DynamicExpression node);
        public abstract void VisitParenthesizedExpression(ParenthesizedExpression node);
        public abstract void VisitExpressionList(ExpressionList node);
        public abstract void VisitExpressionCouple(ExpressionCouple node);
        public abstract void VisitPrefixUnaryExpression(PrefixUnaryExpression node);
        public abstract void VisitBinaryExpression(BinaryExpression node);
        public abstract void VisitInExpression(InExpression node);
        public abstract void VisitHasAnyExpression(HasAnyExpression node);
        public abstract void VisitHasAllExpression(HasAllExpression node);
        public abstract void VisitBetweenExpression(BetweenExpression node);
        public abstract void VisitFunctionCallExpression(FunctionCallExpression node);
        public abstract void VisitToScalarExpression(ToScalarExpression node);
        public abstract void VisitToTableExpression(ToTableExpression node);
        public abstract void VisitMaterializedViewCombineExpression(MaterializedViewCombineExpression node);
        public abstract void VisitMaterializedViewCombineNameClause(MaterializedViewCombineNameClause node);
        public abstract void VisitMaterializedViewCombineClause(MaterializedViewCombineClause node);
        public abstract void VisitSimpleNamedExpression(SimpleNamedExpression node);
        public abstract void VisitRenameList(RenameList node);
        public abstract void VisitCompoundNamedExpression(CompoundNamedExpression node);
        public abstract void VisitBracketedExpression(BracketedExpression node);
        public abstract void VisitPathExpression(PathExpression node);
        public abstract void VisitElementExpression(ElementExpression node);
        public abstract void VisitPipeExpression(PipeExpression node);
        public abstract void VisitRangeOperator(RangeOperator node);
        public abstract void VisitNamedParameter(NamedParameter node);
        public abstract void VisitConsumeOperator(ConsumeOperator node);
        public abstract void VisitCountOperator(CountOperator node);
        public abstract void VisitCountAsIdentifierClause(CountAsIdentifierClause node);
        public abstract void VisitExecuteAndCacheOperator(ExecuteAndCacheOperator node);
        public abstract void VisitExtendOperator(ExtendOperator node);
        public abstract void VisitFacetOperator(FacetOperator node);
        public abstract void VisitFacetWithOperatorClause(FacetWithOperatorClause node);
        public abstract void VisitFacetWithExpressionClause(FacetWithExpressionClause node);
        public abstract void VisitFilterOperator(FilterOperator node);
        public abstract void VisitGetSchemaOperator(GetSchemaOperator node);
        public abstract void VisitFindOperator(FindOperator node);
        public abstract void VisitDataScopeClause(DataScopeClause node);
        public abstract void VisitTypedColumnReference(TypedColumnReference node);
        public abstract void VisitFindInClause(FindInClause node);
        public abstract void VisitFindProjectClause(FindProjectClause node);
        public abstract void VisitPackExpression(PackExpression node);
        public abstract void VisitNameAndTypeDeclaration(NameAndTypeDeclaration node);
        public abstract void VisitPrimitiveTypeExpression(PrimitiveTypeExpression node);
        public abstract void VisitSearchOperator(SearchOperator node);
        public abstract void VisitForkOperator(ForkOperator node);
        public abstract void VisitNameEqualsClause(NameEqualsClause node);
        public abstract void VisitForkExpression(ForkExpression node);
        public abstract void VisitMakeSeriesOperator(MakeSeriesOperator node);
        public abstract void VisitMakeSeriesExpression(MakeSeriesExpression node);
        public abstract void VisitDefaultExpressionClause(DefaultExpressionClause node);
        public abstract void VisitMakeSeriesOnClause(MakeSeriesOnClause node);
        public abstract void VisitMakeSeriesFromClause(MakeSeriesFromClause node);
        public abstract void VisitMakeSeriesToClause(MakeSeriesToClause node);
        public abstract void VisitMakeSeriesStepClause(MakeSeriesStepClause node);
        public abstract void VisitMakeSeriesInRangeClause(MakeSeriesInRangeClause node);
        public abstract void VisitMakeSeriesFromToStepClause(MakeSeriesFromToStepClause node);
        public abstract void VisitMakeSeriesByClause(MakeSeriesByClause node);
        public abstract void VisitMvExpandOperator(MvExpandOperator node);
        public abstract void VisitMvExpandExpression(MvExpandExpression node);
        public abstract void VisitMvExpandRowLimitClause(MvExpandRowLimitClause node);
        public abstract void VisitMvApplyOperator(MvApplyOperator node);
        public abstract void VisitMvApplyExpression(MvApplyExpression node);
        public abstract void VisitMvApplyRowLimitClause(MvApplyRowLimitClause node);
        public abstract void VisitMvApplyContextIdClause(MvApplyContextIdClause node);
        public abstract void VisitMvApplySubqueryExpression(MvApplySubqueryExpression node);
        public abstract void VisitToTypeOfClause(ToTypeOfClause node);
        public abstract void VisitEvaluateSchemaClause(EvaluateSchemaClause node);
        public abstract void VisitEvaluateOperator(EvaluateOperator node);
        public abstract void VisitParseOperator(ParseOperator node);
        public abstract void VisitParseWhereOperator(ParseWhereOperator node);
        public abstract void VisitParseKvWithClause(ParseKvWithClause node);
        public abstract void VisitParseKvOperator(ParseKvOperator node);
        public abstract void VisitPartitionOperator(PartitionOperator node);
        public abstract void VisitPartitionQuery(PartitionQuery node);
        public abstract void VisitPartitionScope(PartitionScope node);
        public abstract void VisitPartitionSubquery(PartitionSubquery node);
        public abstract void VisitProjectOperator(ProjectOperator node);
        public abstract void VisitProjectAwayOperator(ProjectAwayOperator node);
        public abstract void VisitProjectByNamesOperator(ProjectByNamesOperator node);
        public abstract void VisitProjectKeepOperator(ProjectKeepOperator node);
        public abstract void VisitProjectRenameOperator(ProjectRenameOperator node);
        public abstract void VisitProjectReorderOperator(ProjectReorderOperator node);
        public abstract void VisitSampleOperator(SampleOperator node);
        public abstract void VisitSampleDistinctOperator(SampleDistinctOperator node);
        public abstract void VisitEntityGroup(EntityGroup node);
        public abstract void VisitReduceByOperator(ReduceByOperator node);
        public abstract void VisitReduceByWithClause(ReduceByWithClause node);
        public abstract void VisitSummarizeOperator(SummarizeOperator node);
        public abstract void VisitMacroExpandScopeReferenceName(MacroExpandScopeReferenceName node);
        public abstract void VisitMacroExpandOperator(MacroExpandOperator node);
        public abstract void VisitSummarizeByClause(SummarizeByClause node);
        public abstract void VisitDistinctOperator(DistinctOperator node);
        public abstract void VisitTakeOperator(TakeOperator node);
        public abstract void VisitSortOperator(SortOperator node);
        public abstract void VisitOrderedExpression(OrderedExpression node);
        public abstract void VisitOrderingClause(OrderingClause node);
        public abstract void VisitOrderingNullsClause(OrderingNullsClause node);
        public abstract void VisitTopHittersOperator(TopHittersOperator node);
        public abstract void VisitTopHittersByClause(TopHittersByClause node);
        public abstract void VisitTopOperator(TopOperator node);
        public abstract void VisitTopNestedOperator(TopNestedOperator node);
        public abstract void VisitTopNestedClause(TopNestedClause node);
        public abstract void VisitTopNestedWithOthersClause(TopNestedWithOthersClause node);
        public abstract void VisitUnionOperator(UnionOperator node);
        public abstract void VisitAsOperator(AsOperator node);
        public abstract void VisitSerializeOperator(SerializeOperator node);
        public abstract void VisitInvokeOperator(InvokeOperator node);
        public abstract void VisitRenderOperator(RenderOperator node);
        public abstract void VisitMakeGraphOperator(MakeGraphOperator node);
        public abstract void VisitMakeGraphWithTablesAndKeysClause(MakeGraphWithTablesAndKeysClause node);
        public abstract void VisitMakeGraphWithImplicitIdClause(MakeGraphWithImplicitIdClause node);
        public abstract void VisitGraphMarkComponentsOperator(GraphMarkComponentsOperator node);
        public abstract void VisitGraphWhereNodesOperator(GraphWhereNodesOperator node);
        public abstract void VisitGraphWhereEdgesOperator(GraphWhereEdgesOperator node);
        public abstract void VisitMakeGraphTableAndKeyClause(MakeGraphTableAndKeyClause node);
        public abstract void VisitMakeGraphPartitionedByClause(MakeGraphPartitionedByClause node);
        public abstract void VisitGraphToTableOperator(GraphToTableOperator node);
        public abstract void VisitGraphToTableOutputClause(GraphToTableOutputClause node);
        public abstract void VisitGraphToTableAsClause(GraphToTableAsClause node);
        public abstract void VisitGraphMatchOperator(GraphMatchOperator node);
        public abstract void VisitGraphShortestPathsOperator(GraphShortestPathsOperator node);
        public abstract void VisitGraphMatchPattern(GraphMatchPattern node);
        public abstract void VisitGraphMatchPatternNode(GraphMatchPatternNode node);
        public abstract void VisitGraphMatchPatternEdge(GraphMatchPatternEdge node);
        public abstract void VisitGraphMatchPatternEdgeRange(GraphMatchPatternEdgeRange node);
        public abstract void VisitWhereClause(WhereClause node);
        public abstract void VisitProjectClause(ProjectClause node);
        public abstract void VisitNameReferenceList(NameReferenceList node);
        public abstract void VisitRenderWithClause(RenderWithClause node);
        public abstract void VisitPrintOperator(PrintOperator node);
        public abstract void VisitAliasStatement(AliasStatement node);
        public abstract void VisitLetStatement(LetStatement node);
        public abstract void VisitFunctionDeclaration(FunctionDeclaration node);
        public abstract void VisitFunctionParameters(FunctionParameters node);
        public abstract void VisitFunctionParameter(FunctionParameter node);
        public abstract void VisitDefaultValueDeclaration(DefaultValueDeclaration node);
        public abstract void VisitFunctionBody(FunctionBody node);
        public abstract void VisitSchemaTypeExpression(SchemaTypeExpression node);
        public abstract void VisitExpressionStatement(ExpressionStatement node);
        public abstract void VisitMaterializeExpression(MaterializeExpression node);
        public abstract void VisitSetOptionStatement(SetOptionStatement node);
        public abstract void VisitOptionValueClause(OptionValueClause node);
        public abstract void VisitQueryParametersStatement(QueryParametersStatement node);
        public abstract void VisitRestrictStatementWithClause(RestrictStatementWithClause node);
        public abstract void VisitRestrictStatement(RestrictStatement node);
        public abstract void VisitPatternStatement(PatternStatement node);
        public abstract void VisitPatternDeclaration(PatternDeclaration node);
        public abstract void VisitPatternPathParameter(PatternPathParameter node);
        public abstract void VisitPatternMatch(PatternMatch node);
        public abstract void VisitPatternPathValue(PatternPathValue node);
        public abstract void VisitDataScopeExpression(DataScopeExpression node);
        public abstract void VisitDataTableExpression(DataTableExpression node);
        public abstract void VisitRowSchema(RowSchema node);
        public abstract void VisitEvaluateRowSchema(EvaluateRowSchema node);
        public abstract void VisitExternalDataExpression(ExternalDataExpression node);
        public abstract void VisitContextualDataTableExpression(ContextualDataTableExpression node);
        public abstract void VisitExternalDataWithClause(ExternalDataWithClause node);
        public abstract void VisitInlineExternalTableKindClause(InlineExternalTableKindClause node);
        public abstract void VisitInlineExternalTableDataFormatClause(InlineExternalTableDataFormatClause node);
        public abstract void VisitDateTimePattern(DateTimePattern node);
        public abstract void VisitInlineExternalTablePathFormatPartitionColumnReference(InlineExternalTablePathFormatPartitionColumnReference node);
        public abstract void VisitInlineExternalTablePathFormatClause(InlineExternalTablePathFormatClause node);
        public abstract void VisitPartitionColumnDeclaration(PartitionColumnDeclaration node);
        public abstract void VisitInlineExternalTablePartitionClause(InlineExternalTablePartitionClause node);
        public abstract void VisitInlineExternalTableConnectionStringsClause(InlineExternalTableConnectionStringsClause node);
        public abstract void VisitInlineExternalTableExpression(InlineExternalTableExpression node);
        public abstract void VisitJoinOperator(JoinOperator node);
        public abstract void VisitLookupOperator(LookupOperator node);
        public abstract void VisitJoinOnClause(JoinOnClause node);
        public abstract void VisitJoinWhereClause(JoinWhereClause node);
        public abstract void VisitScanOperator(ScanOperator node);
        public abstract void VisitAssertSchemaOperator(AssertSchemaOperator node);
        public abstract void VisitScanDeclareClause(ScanDeclareClause node);
        public abstract void VisitScanOrderByClause(ScanOrderByClause node);
        public abstract void VisitScanPartitionByClause(ScanPartitionByClause node);
        public abstract void VisitScanStepOutput(ScanStepOutput node);
        public abstract void VisitScanStep(ScanStep node);
        public abstract void VisitScanComputationClause(ScanComputationClause node);
        public abstract void VisitScanAssignment(ScanAssignment node);
        public abstract void VisitPartitionByOperator(PartitionByOperator node);
        public abstract void VisitPartitionByIdClause(PartitionByIdClause node);
        public abstract void VisitCommandWithValueClause(CommandWithValueClause node);
        public abstract void VisitCommandWithPropertyListClause(CommandWithPropertyListClause node);
        public abstract void VisitUnknownCommand(UnknownCommand node);
        public abstract void VisitCustomCommand(CustomCommand node);
        public abstract void VisitPartialCommand(PartialCommand node);
        public abstract void VisitCommandAndSkippedTokens(CommandAndSkippedTokens node);
        public abstract void VisitBadCommand(BadCommand node);
        public abstract void VisitCommandBlock(CommandBlock node);
    }
    public partial class DefaultSyntaxVisitor : SyntaxVisitor
    {
        protected abstract void DefaultVisit(SyntaxNode node);
        
        public override void VisitDirectiveBlock(DirectiveBlock node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitDirective(Directive node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitSkippedTokens(SkippedTokens node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitQueryBlock(QueryBlock node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitTypeOfLiteralExpression(TypeOfLiteralExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitBadQueryOperator(BadQueryOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitCompoundStringLiteralExpression(CompoundStringLiteralExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitTokenName(TokenName node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitBracketedName(BracketedName node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitBracedName(BracedName node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitWildcardedName(WildcardedName node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitBracketedWildcardedName(BracketedWildcardedName node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitNameDeclaration(NameDeclaration node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitNameReference(NameReference node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitLiteralExpression(LiteralExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitStarExpression(StarExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitAtExpression(AtExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitJsonPair(JsonPair node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitJsonObjectExpression(JsonObjectExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitJsonArrayExpression(JsonArrayExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitDynamicExpression(DynamicExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitParenthesizedExpression(ParenthesizedExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitExpressionList(ExpressionList node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitExpressionCouple(ExpressionCouple node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitPrefixUnaryExpression(PrefixUnaryExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitBinaryExpression(BinaryExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitInExpression(InExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitHasAnyExpression(HasAnyExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitHasAllExpression(HasAllExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitBetweenExpression(BetweenExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitFunctionCallExpression(FunctionCallExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitToScalarExpression(ToScalarExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitToTableExpression(ToTableExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitMaterializedViewCombineExpression(MaterializedViewCombineExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitMaterializedViewCombineNameClause(MaterializedViewCombineNameClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitMaterializedViewCombineClause(MaterializedViewCombineClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitSimpleNamedExpression(SimpleNamedExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitRenameList(RenameList node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitCompoundNamedExpression(CompoundNamedExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitBracketedExpression(BracketedExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitPathExpression(PathExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitElementExpression(ElementExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitPipeExpression(PipeExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitRangeOperator(RangeOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitNamedParameter(NamedParameter node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitConsumeOperator(ConsumeOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitCountOperator(CountOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitCountAsIdentifierClause(CountAsIdentifierClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitExecuteAndCacheOperator(ExecuteAndCacheOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitExtendOperator(ExtendOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitFacetOperator(FacetOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitFacetWithOperatorClause(FacetWithOperatorClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitFacetWithExpressionClause(FacetWithExpressionClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitFilterOperator(FilterOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitGetSchemaOperator(GetSchemaOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitFindOperator(FindOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitDataScopeClause(DataScopeClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitTypedColumnReference(TypedColumnReference node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitFindInClause(FindInClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitFindProjectClause(FindProjectClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitPackExpression(PackExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitNameAndTypeDeclaration(NameAndTypeDeclaration node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitPrimitiveTypeExpression(PrimitiveTypeExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitSearchOperator(SearchOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitForkOperator(ForkOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitNameEqualsClause(NameEqualsClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitForkExpression(ForkExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitMakeSeriesOperator(MakeSeriesOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitMakeSeriesExpression(MakeSeriesExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitDefaultExpressionClause(DefaultExpressionClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitMakeSeriesOnClause(MakeSeriesOnClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitMakeSeriesFromClause(MakeSeriesFromClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitMakeSeriesToClause(MakeSeriesToClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitMakeSeriesStepClause(MakeSeriesStepClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitMakeSeriesInRangeClause(MakeSeriesInRangeClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitMakeSeriesFromToStepClause(MakeSeriesFromToStepClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitMakeSeriesByClause(MakeSeriesByClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitMvExpandOperator(MvExpandOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitMvExpandExpression(MvExpandExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitMvExpandRowLimitClause(MvExpandRowLimitClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitMvApplyOperator(MvApplyOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitMvApplyExpression(MvApplyExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitMvApplyRowLimitClause(MvApplyRowLimitClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitMvApplyContextIdClause(MvApplyContextIdClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitMvApplySubqueryExpression(MvApplySubqueryExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitToTypeOfClause(ToTypeOfClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitEvaluateSchemaClause(EvaluateSchemaClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitEvaluateOperator(EvaluateOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitParseOperator(ParseOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitParseWhereOperator(ParseWhereOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitParseKvWithClause(ParseKvWithClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitParseKvOperator(ParseKvOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitPartitionOperator(PartitionOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitPartitionQuery(PartitionQuery node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitPartitionScope(PartitionScope node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitPartitionSubquery(PartitionSubquery node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitProjectOperator(ProjectOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitProjectAwayOperator(ProjectAwayOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitProjectByNamesOperator(ProjectByNamesOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitProjectKeepOperator(ProjectKeepOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitProjectRenameOperator(ProjectRenameOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitProjectReorderOperator(ProjectReorderOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitSampleOperator(SampleOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitSampleDistinctOperator(SampleDistinctOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitEntityGroup(EntityGroup node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitReduceByOperator(ReduceByOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitReduceByWithClause(ReduceByWithClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitSummarizeOperator(SummarizeOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitMacroExpandScopeReferenceName(MacroExpandScopeReferenceName node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitMacroExpandOperator(MacroExpandOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitSummarizeByClause(SummarizeByClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitDistinctOperator(DistinctOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitTakeOperator(TakeOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitSortOperator(SortOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitOrderedExpression(OrderedExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitOrderingClause(OrderingClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitOrderingNullsClause(OrderingNullsClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitTopHittersOperator(TopHittersOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitTopHittersByClause(TopHittersByClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitTopOperator(TopOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitTopNestedOperator(TopNestedOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitTopNestedClause(TopNestedClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitTopNestedWithOthersClause(TopNestedWithOthersClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitUnionOperator(UnionOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitAsOperator(AsOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitSerializeOperator(SerializeOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitInvokeOperator(InvokeOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitRenderOperator(RenderOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitMakeGraphOperator(MakeGraphOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitMakeGraphWithTablesAndKeysClause(MakeGraphWithTablesAndKeysClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitMakeGraphWithImplicitIdClause(MakeGraphWithImplicitIdClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitGraphMarkComponentsOperator(GraphMarkComponentsOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitGraphWhereNodesOperator(GraphWhereNodesOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitGraphWhereEdgesOperator(GraphWhereEdgesOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitMakeGraphTableAndKeyClause(MakeGraphTableAndKeyClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitMakeGraphPartitionedByClause(MakeGraphPartitionedByClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitGraphToTableOperator(GraphToTableOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitGraphToTableOutputClause(GraphToTableOutputClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitGraphToTableAsClause(GraphToTableAsClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitGraphMatchOperator(GraphMatchOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitGraphShortestPathsOperator(GraphShortestPathsOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitGraphMatchPattern(GraphMatchPattern node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitGraphMatchPatternNode(GraphMatchPatternNode node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitGraphMatchPatternEdge(GraphMatchPatternEdge node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitGraphMatchPatternEdgeRange(GraphMatchPatternEdgeRange node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitWhereClause(WhereClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitProjectClause(ProjectClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitNameReferenceList(NameReferenceList node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitRenderWithClause(RenderWithClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitPrintOperator(PrintOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitAliasStatement(AliasStatement node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitLetStatement(LetStatement node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitFunctionDeclaration(FunctionDeclaration node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitFunctionParameters(FunctionParameters node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitFunctionParameter(FunctionParameter node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitDefaultValueDeclaration(DefaultValueDeclaration node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitFunctionBody(FunctionBody node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitSchemaTypeExpression(SchemaTypeExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitExpressionStatement(ExpressionStatement node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitMaterializeExpression(MaterializeExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitSetOptionStatement(SetOptionStatement node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitOptionValueClause(OptionValueClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitQueryParametersStatement(QueryParametersStatement node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitRestrictStatementWithClause(RestrictStatementWithClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitRestrictStatement(RestrictStatement node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitPatternStatement(PatternStatement node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitPatternDeclaration(PatternDeclaration node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitPatternPathParameter(PatternPathParameter node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitPatternMatch(PatternMatch node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitPatternPathValue(PatternPathValue node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitDataScopeExpression(DataScopeExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitDataTableExpression(DataTableExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitRowSchema(RowSchema node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitEvaluateRowSchema(EvaluateRowSchema node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitExternalDataExpression(ExternalDataExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitContextualDataTableExpression(ContextualDataTableExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitExternalDataWithClause(ExternalDataWithClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitInlineExternalTableKindClause(InlineExternalTableKindClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitInlineExternalTableDataFormatClause(InlineExternalTableDataFormatClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitDateTimePattern(DateTimePattern node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitInlineExternalTablePathFormatPartitionColumnReference(InlineExternalTablePathFormatPartitionColumnReference node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitInlineExternalTablePathFormatClause(InlineExternalTablePathFormatClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitPartitionColumnDeclaration(PartitionColumnDeclaration node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitInlineExternalTablePartitionClause(InlineExternalTablePartitionClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitInlineExternalTableConnectionStringsClause(InlineExternalTableConnectionStringsClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitInlineExternalTableExpression(InlineExternalTableExpression node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitJoinOperator(JoinOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitLookupOperator(LookupOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitJoinOnClause(JoinOnClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitJoinWhereClause(JoinWhereClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitScanOperator(ScanOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitAssertSchemaOperator(AssertSchemaOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitScanDeclareClause(ScanDeclareClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitScanOrderByClause(ScanOrderByClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitScanPartitionByClause(ScanPartitionByClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitScanStepOutput(ScanStepOutput node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitScanStep(ScanStep node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitScanComputationClause(ScanComputationClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitScanAssignment(ScanAssignment node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitPartitionByOperator(PartitionByOperator node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitPartitionByIdClause(PartitionByIdClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitCommandWithValueClause(CommandWithValueClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitCommandWithPropertyListClause(CommandWithPropertyListClause node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitUnknownCommand(UnknownCommand node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitCustomCommand(CustomCommand node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitPartialCommand(PartialCommand node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitCommandAndSkippedTokens(CommandAndSkippedTokens node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitBadCommand(BadCommand node)
        {
            this.DefaultVisit(node);
        }
        public override void VisitCommandBlock(CommandBlock node)
        {
            this.DefaultVisit(node);
        }
    }
    #endregion /* SyntaxVisitor */
    
    #region SyntaxVisitor<TResult>
    public partial class SyntaxVisitor<TResult>
    {
        public abstract TResult VisitDirectiveBlock(DirectiveBlock node);
        public abstract TResult VisitDirective(Directive node);
        public abstract TResult VisitSkippedTokens(SkippedTokens node);
        public abstract TResult VisitQueryBlock(QueryBlock node);
        public abstract TResult VisitTypeOfLiteralExpression(TypeOfLiteralExpression node);
        public abstract TResult VisitBadQueryOperator(BadQueryOperator node);
        public abstract TResult VisitCompoundStringLiteralExpression(CompoundStringLiteralExpression node);
        public abstract TResult VisitTokenName(TokenName node);
        public abstract TResult VisitBracketedName(BracketedName node);
        public abstract TResult VisitBracedName(BracedName node);
        public abstract TResult VisitWildcardedName(WildcardedName node);
        public abstract TResult VisitBracketedWildcardedName(BracketedWildcardedName node);
        public abstract TResult VisitNameDeclaration(NameDeclaration node);
        public abstract TResult VisitNameReference(NameReference node);
        public abstract TResult VisitLiteralExpression(LiteralExpression node);
        public abstract TResult VisitStarExpression(StarExpression node);
        public abstract TResult VisitAtExpression(AtExpression node);
        public abstract TResult VisitJsonPair(JsonPair node);
        public abstract TResult VisitJsonObjectExpression(JsonObjectExpression node);
        public abstract TResult VisitJsonArrayExpression(JsonArrayExpression node);
        public abstract TResult VisitDynamicExpression(DynamicExpression node);
        public abstract TResult VisitParenthesizedExpression(ParenthesizedExpression node);
        public abstract TResult VisitExpressionList(ExpressionList node);
        public abstract TResult VisitExpressionCouple(ExpressionCouple node);
        public abstract TResult VisitPrefixUnaryExpression(PrefixUnaryExpression node);
        public abstract TResult VisitBinaryExpression(BinaryExpression node);
        public abstract TResult VisitInExpression(InExpression node);
        public abstract TResult VisitHasAnyExpression(HasAnyExpression node);
        public abstract TResult VisitHasAllExpression(HasAllExpression node);
        public abstract TResult VisitBetweenExpression(BetweenExpression node);
        public abstract TResult VisitFunctionCallExpression(FunctionCallExpression node);
        public abstract TResult VisitToScalarExpression(ToScalarExpression node);
        public abstract TResult VisitToTableExpression(ToTableExpression node);
        public abstract TResult VisitMaterializedViewCombineExpression(MaterializedViewCombineExpression node);
        public abstract TResult VisitMaterializedViewCombineNameClause(MaterializedViewCombineNameClause node);
        public abstract TResult VisitMaterializedViewCombineClause(MaterializedViewCombineClause node);
        public abstract TResult VisitSimpleNamedExpression(SimpleNamedExpression node);
        public abstract TResult VisitRenameList(RenameList node);
        public abstract TResult VisitCompoundNamedExpression(CompoundNamedExpression node);
        public abstract TResult VisitBracketedExpression(BracketedExpression node);
        public abstract TResult VisitPathExpression(PathExpression node);
        public abstract TResult VisitElementExpression(ElementExpression node);
        public abstract TResult VisitPipeExpression(PipeExpression node);
        public abstract TResult VisitRangeOperator(RangeOperator node);
        public abstract TResult VisitNamedParameter(NamedParameter node);
        public abstract TResult VisitConsumeOperator(ConsumeOperator node);
        public abstract TResult VisitCountOperator(CountOperator node);
        public abstract TResult VisitCountAsIdentifierClause(CountAsIdentifierClause node);
        public abstract TResult VisitExecuteAndCacheOperator(ExecuteAndCacheOperator node);
        public abstract TResult VisitExtendOperator(ExtendOperator node);
        public abstract TResult VisitFacetOperator(FacetOperator node);
        public abstract TResult VisitFacetWithOperatorClause(FacetWithOperatorClause node);
        public abstract TResult VisitFacetWithExpressionClause(FacetWithExpressionClause node);
        public abstract TResult VisitFilterOperator(FilterOperator node);
        public abstract TResult VisitGetSchemaOperator(GetSchemaOperator node);
        public abstract TResult VisitFindOperator(FindOperator node);
        public abstract TResult VisitDataScopeClause(DataScopeClause node);
        public abstract TResult VisitTypedColumnReference(TypedColumnReference node);
        public abstract TResult VisitFindInClause(FindInClause node);
        public abstract TResult VisitFindProjectClause(FindProjectClause node);
        public abstract TResult VisitPackExpression(PackExpression node);
        public abstract TResult VisitNameAndTypeDeclaration(NameAndTypeDeclaration node);
        public abstract TResult VisitPrimitiveTypeExpression(PrimitiveTypeExpression node);
        public abstract TResult VisitSearchOperator(SearchOperator node);
        public abstract TResult VisitForkOperator(ForkOperator node);
        public abstract TResult VisitNameEqualsClause(NameEqualsClause node);
        public abstract TResult VisitForkExpression(ForkExpression node);
        public abstract TResult VisitMakeSeriesOperator(MakeSeriesOperator node);
        public abstract TResult VisitMakeSeriesExpression(MakeSeriesExpression node);
        public abstract TResult VisitDefaultExpressionClause(DefaultExpressionClause node);
        public abstract TResult VisitMakeSeriesOnClause(MakeSeriesOnClause node);
        public abstract TResult VisitMakeSeriesFromClause(MakeSeriesFromClause node);
        public abstract TResult VisitMakeSeriesToClause(MakeSeriesToClause node);
        public abstract TResult VisitMakeSeriesStepClause(MakeSeriesStepClause node);
        public abstract TResult VisitMakeSeriesInRangeClause(MakeSeriesInRangeClause node);
        public abstract TResult VisitMakeSeriesFromToStepClause(MakeSeriesFromToStepClause node);
        public abstract TResult VisitMakeSeriesByClause(MakeSeriesByClause node);
        public abstract TResult VisitMvExpandOperator(MvExpandOperator node);
        public abstract TResult VisitMvExpandExpression(MvExpandExpression node);
        public abstract TResult VisitMvExpandRowLimitClause(MvExpandRowLimitClause node);
        public abstract TResult VisitMvApplyOperator(MvApplyOperator node);
        public abstract TResult VisitMvApplyExpression(MvApplyExpression node);
        public abstract TResult VisitMvApplyRowLimitClause(MvApplyRowLimitClause node);
        public abstract TResult VisitMvApplyContextIdClause(MvApplyContextIdClause node);
        public abstract TResult VisitMvApplySubqueryExpression(MvApplySubqueryExpression node);
        public abstract TResult VisitToTypeOfClause(ToTypeOfClause node);
        public abstract TResult VisitEvaluateSchemaClause(EvaluateSchemaClause node);
        public abstract TResult VisitEvaluateOperator(EvaluateOperator node);
        public abstract TResult VisitParseOperator(ParseOperator node);
        public abstract TResult VisitParseWhereOperator(ParseWhereOperator node);
        public abstract TResult VisitParseKvWithClause(ParseKvWithClause node);
        public abstract TResult VisitParseKvOperator(ParseKvOperator node);
        public abstract TResult VisitPartitionOperator(PartitionOperator node);
        public abstract TResult VisitPartitionQuery(PartitionQuery node);
        public abstract TResult VisitPartitionScope(PartitionScope node);
        public abstract TResult VisitPartitionSubquery(PartitionSubquery node);
        public abstract TResult VisitProjectOperator(ProjectOperator node);
        public abstract TResult VisitProjectAwayOperator(ProjectAwayOperator node);
        public abstract TResult VisitProjectByNamesOperator(ProjectByNamesOperator node);
        public abstract TResult VisitProjectKeepOperator(ProjectKeepOperator node);
        public abstract TResult VisitProjectRenameOperator(ProjectRenameOperator node);
        public abstract TResult VisitProjectReorderOperator(ProjectReorderOperator node);
        public abstract TResult VisitSampleOperator(SampleOperator node);
        public abstract TResult VisitSampleDistinctOperator(SampleDistinctOperator node);
        public abstract TResult VisitEntityGroup(EntityGroup node);
        public abstract TResult VisitReduceByOperator(ReduceByOperator node);
        public abstract TResult VisitReduceByWithClause(ReduceByWithClause node);
        public abstract TResult VisitSummarizeOperator(SummarizeOperator node);
        public abstract TResult VisitMacroExpandScopeReferenceName(MacroExpandScopeReferenceName node);
        public abstract TResult VisitMacroExpandOperator(MacroExpandOperator node);
        public abstract TResult VisitSummarizeByClause(SummarizeByClause node);
        public abstract TResult VisitDistinctOperator(DistinctOperator node);
        public abstract TResult VisitTakeOperator(TakeOperator node);
        public abstract TResult VisitSortOperator(SortOperator node);
        public abstract TResult VisitOrderedExpression(OrderedExpression node);
        public abstract TResult VisitOrderingClause(OrderingClause node);
        public abstract TResult VisitOrderingNullsClause(OrderingNullsClause node);
        public abstract TResult VisitTopHittersOperator(TopHittersOperator node);
        public abstract TResult VisitTopHittersByClause(TopHittersByClause node);
        public abstract TResult VisitTopOperator(TopOperator node);
        public abstract TResult VisitTopNestedOperator(TopNestedOperator node);
        public abstract TResult VisitTopNestedClause(TopNestedClause node);
        public abstract TResult VisitTopNestedWithOthersClause(TopNestedWithOthersClause node);
        public abstract TResult VisitUnionOperator(UnionOperator node);
        public abstract TResult VisitAsOperator(AsOperator node);
        public abstract TResult VisitSerializeOperator(SerializeOperator node);
        public abstract TResult VisitInvokeOperator(InvokeOperator node);
        public abstract TResult VisitRenderOperator(RenderOperator node);
        public abstract TResult VisitMakeGraphOperator(MakeGraphOperator node);
        public abstract TResult VisitMakeGraphWithTablesAndKeysClause(MakeGraphWithTablesAndKeysClause node);
        public abstract TResult VisitMakeGraphWithImplicitIdClause(MakeGraphWithImplicitIdClause node);
        public abstract TResult VisitGraphMarkComponentsOperator(GraphMarkComponentsOperator node);
        public abstract TResult VisitGraphWhereNodesOperator(GraphWhereNodesOperator node);
        public abstract TResult VisitGraphWhereEdgesOperator(GraphWhereEdgesOperator node);
        public abstract TResult VisitMakeGraphTableAndKeyClause(MakeGraphTableAndKeyClause node);
        public abstract TResult VisitMakeGraphPartitionedByClause(MakeGraphPartitionedByClause node);
        public abstract TResult VisitGraphToTableOperator(GraphToTableOperator node);
        public abstract TResult VisitGraphToTableOutputClause(GraphToTableOutputClause node);
        public abstract TResult VisitGraphToTableAsClause(GraphToTableAsClause node);
        public abstract TResult VisitGraphMatchOperator(GraphMatchOperator node);
        public abstract TResult VisitGraphShortestPathsOperator(GraphShortestPathsOperator node);
        public abstract TResult VisitGraphMatchPattern(GraphMatchPattern node);
        public abstract TResult VisitGraphMatchPatternNode(GraphMatchPatternNode node);
        public abstract TResult VisitGraphMatchPatternEdge(GraphMatchPatternEdge node);
        public abstract TResult VisitGraphMatchPatternEdgeRange(GraphMatchPatternEdgeRange node);
        public abstract TResult VisitWhereClause(WhereClause node);
        public abstract TResult VisitProjectClause(ProjectClause node);
        public abstract TResult VisitNameReferenceList(NameReferenceList node);
        public abstract TResult VisitRenderWithClause(RenderWithClause node);
        public abstract TResult VisitPrintOperator(PrintOperator node);
        public abstract TResult VisitAliasStatement(AliasStatement node);
        public abstract TResult VisitLetStatement(LetStatement node);
        public abstract TResult VisitFunctionDeclaration(FunctionDeclaration node);
        public abstract TResult VisitFunctionParameters(FunctionParameters node);
        public abstract TResult VisitFunctionParameter(FunctionParameter node);
        public abstract TResult VisitDefaultValueDeclaration(DefaultValueDeclaration node);
        public abstract TResult VisitFunctionBody(FunctionBody node);
        public abstract TResult VisitSchemaTypeExpression(SchemaTypeExpression node);
        public abstract TResult VisitExpressionStatement(ExpressionStatement node);
        public abstract TResult VisitMaterializeExpression(MaterializeExpression node);
        public abstract TResult VisitSetOptionStatement(SetOptionStatement node);
        public abstract TResult VisitOptionValueClause(OptionValueClause node);
        public abstract TResult VisitQueryParametersStatement(QueryParametersStatement node);
        public abstract TResult VisitRestrictStatementWithClause(RestrictStatementWithClause node);
        public abstract TResult VisitRestrictStatement(RestrictStatement node);
        public abstract TResult VisitPatternStatement(PatternStatement node);
        public abstract TResult VisitPatternDeclaration(PatternDeclaration node);
        public abstract TResult VisitPatternPathParameter(PatternPathParameter node);
        public abstract TResult VisitPatternMatch(PatternMatch node);
        public abstract TResult VisitPatternPathValue(PatternPathValue node);
        public abstract TResult VisitDataScopeExpression(DataScopeExpression node);
        public abstract TResult VisitDataTableExpression(DataTableExpression node);
        public abstract TResult VisitRowSchema(RowSchema node);
        public abstract TResult VisitEvaluateRowSchema(EvaluateRowSchema node);
        public abstract TResult VisitExternalDataExpression(ExternalDataExpression node);
        public abstract TResult VisitContextualDataTableExpression(ContextualDataTableExpression node);
        public abstract TResult VisitExternalDataWithClause(ExternalDataWithClause node);
        public abstract TResult VisitInlineExternalTableKindClause(InlineExternalTableKindClause node);
        public abstract TResult VisitInlineExternalTableDataFormatClause(InlineExternalTableDataFormatClause node);
        public abstract TResult VisitDateTimePattern(DateTimePattern node);
        public abstract TResult VisitInlineExternalTablePathFormatPartitionColumnReference(InlineExternalTablePathFormatPartitionColumnReference node);
        public abstract TResult VisitInlineExternalTablePathFormatClause(InlineExternalTablePathFormatClause node);
        public abstract TResult VisitPartitionColumnDeclaration(PartitionColumnDeclaration node);
        public abstract TResult VisitInlineExternalTablePartitionClause(InlineExternalTablePartitionClause node);
        public abstract TResult VisitInlineExternalTableConnectionStringsClause(InlineExternalTableConnectionStringsClause node);
        public abstract TResult VisitInlineExternalTableExpression(InlineExternalTableExpression node);
        public abstract TResult VisitJoinOperator(JoinOperator node);
        public abstract TResult VisitLookupOperator(LookupOperator node);
        public abstract TResult VisitJoinOnClause(JoinOnClause node);
        public abstract TResult VisitJoinWhereClause(JoinWhereClause node);
        public abstract TResult VisitScanOperator(ScanOperator node);
        public abstract TResult VisitAssertSchemaOperator(AssertSchemaOperator node);
        public abstract TResult VisitScanDeclareClause(ScanDeclareClause node);
        public abstract TResult VisitScanOrderByClause(ScanOrderByClause node);
        public abstract TResult VisitScanPartitionByClause(ScanPartitionByClause node);
        public abstract TResult VisitScanStepOutput(ScanStepOutput node);
        public abstract TResult VisitScanStep(ScanStep node);
        public abstract TResult VisitScanComputationClause(ScanComputationClause node);
        public abstract TResult VisitScanAssignment(ScanAssignment node);
        public abstract TResult VisitPartitionByOperator(PartitionByOperator node);
        public abstract TResult VisitPartitionByIdClause(PartitionByIdClause node);
        public abstract TResult VisitCommandWithValueClause(CommandWithValueClause node);
        public abstract TResult VisitCommandWithPropertyListClause(CommandWithPropertyListClause node);
        public abstract TResult VisitUnknownCommand(UnknownCommand node);
        public abstract TResult VisitCustomCommand(CustomCommand node);
        public abstract TResult VisitPartialCommand(PartialCommand node);
        public abstract TResult VisitCommandAndSkippedTokens(CommandAndSkippedTokens node);
        public abstract TResult VisitBadCommand(BadCommand node);
        public abstract TResult VisitCommandBlock(CommandBlock node);
    }
    public partial class DefaultSyntaxVisitor<TResult> : SyntaxVisitor<TResult>
    {
        protected abstract TResult DefaultVisit(SyntaxNode node);
        
        public override TResult VisitDirectiveBlock(DirectiveBlock node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitDirective(Directive node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitSkippedTokens(SkippedTokens node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitQueryBlock(QueryBlock node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitTypeOfLiteralExpression(TypeOfLiteralExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitBadQueryOperator(BadQueryOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitCompoundStringLiteralExpression(CompoundStringLiteralExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitTokenName(TokenName node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitBracketedName(BracketedName node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitBracedName(BracedName node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitWildcardedName(WildcardedName node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitBracketedWildcardedName(BracketedWildcardedName node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitNameDeclaration(NameDeclaration node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitNameReference(NameReference node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitLiteralExpression(LiteralExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitStarExpression(StarExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitAtExpression(AtExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitJsonPair(JsonPair node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitJsonObjectExpression(JsonObjectExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitJsonArrayExpression(JsonArrayExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitDynamicExpression(DynamicExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitParenthesizedExpression(ParenthesizedExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitExpressionList(ExpressionList node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitExpressionCouple(ExpressionCouple node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitPrefixUnaryExpression(PrefixUnaryExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitBinaryExpression(BinaryExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitInExpression(InExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitHasAnyExpression(HasAnyExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitHasAllExpression(HasAllExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitBetweenExpression(BetweenExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitFunctionCallExpression(FunctionCallExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitToScalarExpression(ToScalarExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitToTableExpression(ToTableExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitMaterializedViewCombineExpression(MaterializedViewCombineExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitMaterializedViewCombineNameClause(MaterializedViewCombineNameClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitMaterializedViewCombineClause(MaterializedViewCombineClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitSimpleNamedExpression(SimpleNamedExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitRenameList(RenameList node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitCompoundNamedExpression(CompoundNamedExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitBracketedExpression(BracketedExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitPathExpression(PathExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitElementExpression(ElementExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitPipeExpression(PipeExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitRangeOperator(RangeOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitNamedParameter(NamedParameter node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitConsumeOperator(ConsumeOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitCountOperator(CountOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitCountAsIdentifierClause(CountAsIdentifierClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitExecuteAndCacheOperator(ExecuteAndCacheOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitExtendOperator(ExtendOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitFacetOperator(FacetOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitFacetWithOperatorClause(FacetWithOperatorClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitFacetWithExpressionClause(FacetWithExpressionClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitFilterOperator(FilterOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitGetSchemaOperator(GetSchemaOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitFindOperator(FindOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitDataScopeClause(DataScopeClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitTypedColumnReference(TypedColumnReference node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitFindInClause(FindInClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitFindProjectClause(FindProjectClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitPackExpression(PackExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitNameAndTypeDeclaration(NameAndTypeDeclaration node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitPrimitiveTypeExpression(PrimitiveTypeExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitSearchOperator(SearchOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitForkOperator(ForkOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitNameEqualsClause(NameEqualsClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitForkExpression(ForkExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitMakeSeriesOperator(MakeSeriesOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitMakeSeriesExpression(MakeSeriesExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitDefaultExpressionClause(DefaultExpressionClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitMakeSeriesOnClause(MakeSeriesOnClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitMakeSeriesFromClause(MakeSeriesFromClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitMakeSeriesToClause(MakeSeriesToClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitMakeSeriesStepClause(MakeSeriesStepClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitMakeSeriesInRangeClause(MakeSeriesInRangeClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitMakeSeriesFromToStepClause(MakeSeriesFromToStepClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitMakeSeriesByClause(MakeSeriesByClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitMvExpandOperator(MvExpandOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitMvExpandExpression(MvExpandExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitMvExpandRowLimitClause(MvExpandRowLimitClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitMvApplyOperator(MvApplyOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitMvApplyExpression(MvApplyExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitMvApplyRowLimitClause(MvApplyRowLimitClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitMvApplyContextIdClause(MvApplyContextIdClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitMvApplySubqueryExpression(MvApplySubqueryExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitToTypeOfClause(ToTypeOfClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitEvaluateSchemaClause(EvaluateSchemaClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitEvaluateOperator(EvaluateOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitParseOperator(ParseOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitParseWhereOperator(ParseWhereOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitParseKvWithClause(ParseKvWithClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitParseKvOperator(ParseKvOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitPartitionOperator(PartitionOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitPartitionQuery(PartitionQuery node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitPartitionScope(PartitionScope node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitPartitionSubquery(PartitionSubquery node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitProjectOperator(ProjectOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitProjectAwayOperator(ProjectAwayOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitProjectByNamesOperator(ProjectByNamesOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitProjectKeepOperator(ProjectKeepOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitProjectRenameOperator(ProjectRenameOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitProjectReorderOperator(ProjectReorderOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitSampleOperator(SampleOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitSampleDistinctOperator(SampleDistinctOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitEntityGroup(EntityGroup node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitReduceByOperator(ReduceByOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitReduceByWithClause(ReduceByWithClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitSummarizeOperator(SummarizeOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitMacroExpandScopeReferenceName(MacroExpandScopeReferenceName node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitMacroExpandOperator(MacroExpandOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitSummarizeByClause(SummarizeByClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitDistinctOperator(DistinctOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitTakeOperator(TakeOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitSortOperator(SortOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitOrderedExpression(OrderedExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitOrderingClause(OrderingClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitOrderingNullsClause(OrderingNullsClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitTopHittersOperator(TopHittersOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitTopHittersByClause(TopHittersByClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitTopOperator(TopOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitTopNestedOperator(TopNestedOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitTopNestedClause(TopNestedClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitTopNestedWithOthersClause(TopNestedWithOthersClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitUnionOperator(UnionOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitAsOperator(AsOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitSerializeOperator(SerializeOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitInvokeOperator(InvokeOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitRenderOperator(RenderOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitMakeGraphOperator(MakeGraphOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitMakeGraphWithTablesAndKeysClause(MakeGraphWithTablesAndKeysClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitMakeGraphWithImplicitIdClause(MakeGraphWithImplicitIdClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitGraphMarkComponentsOperator(GraphMarkComponentsOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitGraphWhereNodesOperator(GraphWhereNodesOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitGraphWhereEdgesOperator(GraphWhereEdgesOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitMakeGraphTableAndKeyClause(MakeGraphTableAndKeyClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitMakeGraphPartitionedByClause(MakeGraphPartitionedByClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitGraphToTableOperator(GraphToTableOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitGraphToTableOutputClause(GraphToTableOutputClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitGraphToTableAsClause(GraphToTableAsClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitGraphMatchOperator(GraphMatchOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitGraphShortestPathsOperator(GraphShortestPathsOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitGraphMatchPattern(GraphMatchPattern node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitGraphMatchPatternNode(GraphMatchPatternNode node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitGraphMatchPatternEdge(GraphMatchPatternEdge node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitGraphMatchPatternEdgeRange(GraphMatchPatternEdgeRange node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitWhereClause(WhereClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitProjectClause(ProjectClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitNameReferenceList(NameReferenceList node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitRenderWithClause(RenderWithClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitPrintOperator(PrintOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitAliasStatement(AliasStatement node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitLetStatement(LetStatement node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitFunctionDeclaration(FunctionDeclaration node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitFunctionParameters(FunctionParameters node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitFunctionParameter(FunctionParameter node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitDefaultValueDeclaration(DefaultValueDeclaration node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitFunctionBody(FunctionBody node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitSchemaTypeExpression(SchemaTypeExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitExpressionStatement(ExpressionStatement node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitMaterializeExpression(MaterializeExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitSetOptionStatement(SetOptionStatement node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitOptionValueClause(OptionValueClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitQueryParametersStatement(QueryParametersStatement node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitRestrictStatementWithClause(RestrictStatementWithClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitRestrictStatement(RestrictStatement node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitPatternStatement(PatternStatement node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitPatternDeclaration(PatternDeclaration node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitPatternPathParameter(PatternPathParameter node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitPatternMatch(PatternMatch node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitPatternPathValue(PatternPathValue node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitDataScopeExpression(DataScopeExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitDataTableExpression(DataTableExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitRowSchema(RowSchema node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitEvaluateRowSchema(EvaluateRowSchema node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitExternalDataExpression(ExternalDataExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitContextualDataTableExpression(ContextualDataTableExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitExternalDataWithClause(ExternalDataWithClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitInlineExternalTableKindClause(InlineExternalTableKindClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitInlineExternalTableDataFormatClause(InlineExternalTableDataFormatClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitDateTimePattern(DateTimePattern node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitInlineExternalTablePathFormatPartitionColumnReference(InlineExternalTablePathFormatPartitionColumnReference node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitInlineExternalTablePathFormatClause(InlineExternalTablePathFormatClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitPartitionColumnDeclaration(PartitionColumnDeclaration node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitInlineExternalTablePartitionClause(InlineExternalTablePartitionClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitInlineExternalTableConnectionStringsClause(InlineExternalTableConnectionStringsClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitInlineExternalTableExpression(InlineExternalTableExpression node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitJoinOperator(JoinOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitLookupOperator(LookupOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitJoinOnClause(JoinOnClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitJoinWhereClause(JoinWhereClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitScanOperator(ScanOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitAssertSchemaOperator(AssertSchemaOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitScanDeclareClause(ScanDeclareClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitScanOrderByClause(ScanOrderByClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitScanPartitionByClause(ScanPartitionByClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitScanStepOutput(ScanStepOutput node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitScanStep(ScanStep node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitScanComputationClause(ScanComputationClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitScanAssignment(ScanAssignment node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitPartitionByOperator(PartitionByOperator node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitPartitionByIdClause(PartitionByIdClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitCommandWithValueClause(CommandWithValueClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitCommandWithPropertyListClause(CommandWithPropertyListClause node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitUnknownCommand(UnknownCommand node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitCustomCommand(CustomCommand node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitPartialCommand(PartialCommand node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitCommandAndSkippedTokens(CommandAndSkippedTokens node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitBadCommand(BadCommand node)
        {
            return this.DefaultVisit(node);
        }
        public override TResult VisitCommandBlock(CommandBlock node)
        {
            return this.DefaultVisit(node);
        }
    }
    #endregion /* SyntaxVisitor<TResult> */
    #endregion /* Visitors */
}

