using System.Collections.Generic;
using System.Text;

namespace Kusto.Language.Symbols
{
    using Kusto.Language;
    using Syntax;
    using System;
    using Utils;

    /// <summary>
    /// The symbol for a function.
    /// </summary>
    public sealed class FunctionSymbol : TypeSymbol
    {
        public override SymbolKind Kind => SymbolKind.Function;

        /// <summary>
        /// A function can have one or more signatures.
        /// </summary>
        public IReadOnlyList<Signature> Signatures { get; }

        /// <summary>
        /// The description of the function.
        /// </summary>
        public string Description { get; }

        /// <summary>
        /// How the name of the result of this function is determined.
        /// </summary>
        public ResultNameKind ResultNameKind { get; }

        /// <summary>
        /// The prefix to column names generated by this function.
        /// </summary>
        public string ResultNamePrefix { get; }

        /// <summary>
        /// The name of an alternative function to use instead of this function
        /// if this function is obsolete/deprecated.
        /// </summary>
        public string Alternative { get; }

        /// <summary>
        /// True if this function is considered obsolete/deprecated.
        /// </summary>
        public bool IsObsolete => Alternative != null;

        /// <summary>
        /// The name of an alternative more optimized function to use
        /// instead of this function when possible.
        /// </summary>
        public string OptimizedAlternative { get; }

        /// <summary>
        /// A function that determines when this function is available in a given context.
        /// </summary>
        public CustomAvailability CustomAvailability { get; }

        [Flags]
        private enum FunctionFlags
        {
            None     = 0b0000_0000,
            Hidden   = 0b0000_0001,
            Foldable = 0b0000_0010,
            View     = 0b0000_0100
        }

        /// <summary>
        /// Function internal state bit flags.
        /// </summary>
        private readonly FunctionFlags _flags;

        /// <summary>
        /// If true, the symbol is hidden from Intellisense.
        /// </summary>
        public override bool IsHidden => (_flags & FunctionFlags.Hidden) != 0 || base.IsHidden;

        /// <summary>
        /// If true this function is considered a constant when all its arguments are constants.
        /// </summary>
        public bool IsConstantFoldable => (_flags & FunctionFlags.Foldable) != 0;

        /// <summary>
        /// If true, this function is considered a view.
        /// Views are local functions that can be accessed using the table() function.
        /// </summary>
        public bool IsView => (_flags & FunctionFlags.View) != 0;

        private FunctionSymbol(
            string name, 
            IEnumerable<Signature> signatures, 
            FunctionFlags flags,
            ResultNameKind resultNameKind, 
            string resultNamePrefix,
            string description,
            string alternative,
            string optimizedAlternative,
            CustomAvailability fnAvailability)
            : base(name)
        {
            this.Signatures = signatures.ToReadOnly().CheckArgumentNullOrEmptyOrElementNull(nameof(signatures));
            this.Description = description ?? "";

            foreach (var signature in this.Signatures)
            {
                signature.Symbol = this;
            }

            _flags = flags;
            this.ResultNameKind = resultNameKind;
            this.ResultNamePrefix = resultNamePrefix;
            this.Alternative = alternative;
            this.OptimizedAlternative = optimizedAlternative;
            CustomAvailability = fnAvailability;
        }

        public FunctionSymbol(string name, IEnumerable<Signature> signatures, string description = null)
            : this(
                  name, 
                  signatures, 
                  flags: FunctionFlags.None, 
                  resultNameKind: ResultNameKind.Default, 
                  resultNamePrefix: null, 
                  description: description, 
                  alternative: null, 
                  optimizedAlternative: null,
                  fnAvailability: null)
        {
        }

        public FunctionSymbol(string name, params Signature[] signatures)
            : this(name, (IEnumerable<Signature>)signatures)
        {
        }

        public FunctionSymbol(string name, TypeSymbol returnType, IReadOnlyList<Parameter> parameters, string description = null)
            : this(name, new[] { new Signature(returnType, parameters) }, description)
        {
        }

        public FunctionSymbol(string name, TypeSymbol returnType, params Parameter[] parameters)
            : this(name, new[] { new Signature(returnType, parameters) })
        {
        }

        public FunctionSymbol(string name, ReturnTypeKind returnTypeKind, IReadOnlyList<Parameter> parameters)
            : this(name, new[] { new Signature(returnTypeKind, parameters) })
        {
        }

        public FunctionSymbol(string name, ReturnTypeKind returnTypeKind, params Parameter[] parameters)
            : this(name, new[] { new Signature(returnTypeKind, parameters) })
        {
        }

        public FunctionSymbol(string name, CustomReturnType customReturnType, Tabularity tabularity, IReadOnlyList<Parameter> parameters)
            : this(name, new[] { new Signature(customReturnType, tabularity, parameters) })
        {
        }

        public FunctionSymbol(string name, CustomReturnType customReturnType, Tabularity tabularity, params Parameter[] parameters)
            : this(name, new[] { new Signature(customReturnType, tabularity, parameters) })
        {
        }

        public FunctionSymbol(string name, string body, Tabularity tabularity, IReadOnlyList<Parameter> parameters, string description = null)
            : this(name, new[] { new Signature(body, tabularity, parameters) }, description)
        {
        }

        public FunctionSymbol(string name, string body, Tabularity tabularity, params Parameter[] parameters)
            : this(name, new[] { new Signature(body, tabularity, parameters) })
        {
        }

        public FunctionSymbol(string name, string body, IReadOnlyList<Parameter> parameters, string description = null)
            : this(name, new[] { new Signature(body, Tabularity.Unspecified, parameters) }, description)
        {
        }

        public FunctionSymbol(string name, string body, params Parameter[] parameters)
            : this(name, new[] { new Signature(body, Tabularity.Unspecified, parameters) })
        {
        }

        public FunctionSymbol(string name, string parameterList, string body, string description = null)
            : this(name, new[] { new Signature(body, Tabularity.Unspecified, Parameter.ParseList(parameterList)) }, description)
        {
        }

        public FunctionSymbol(string name, string parameterList, string body, Tabularity tabularity, string description = null)
                    : this(name, new[] { new Signature(body, tabularity, Parameter.ParseList(parameterList)) }, description)
        {
        }

        public FunctionSymbol(string name, FunctionBody declaration, IReadOnlyList<Parameter> parameters)
            : this(name, new[] { new Signature(declaration, parameters) })
        {
        }

        public FunctionSymbol(string name, FunctionBody declaration, params Parameter[] parameters)
            : this(name, new[] { new Signature(declaration, parameters) })
        {
        }

        /// <summary>
        /// Constructs a new <see cref="FunctionSymbol"/> if one of the arguments differs from the 
        /// existing corresponding property value, or returns this instance if there are no differences.
        /// </summary>
        private FunctionSymbol With(
            Optional<string> name = default,
            Optional<IEnumerable<Signature>> signatures = default,
            Optional<FunctionFlags> flags = default,
            Optional<ResultNameKind> resultNameKind = default,
            Optional<string> resultNamePrefix = default,
            Optional<string> description = default,
            Optional<string> alternative = default,
            Optional<string> optimizedAlternative = default,
            Optional<CustomAvailability> fnAvailability = default)
        {
            var newName = name.HasValue ? name.Value : this.Name;
            var newSignatures = signatures.HasValue ? signatures.Value : this.Signatures;
            var newFlags = flags.HasValue ? flags.Value : _flags;
            var newResultNameKind = resultNameKind.HasValue ? resultNameKind.Value : this.ResultNameKind;
            var newResultNamePrefix = resultNamePrefix.HasValue ? resultNamePrefix.Value : this.ResultNamePrefix;
            var newDescription = description.HasValue ? description.Value : this.Description;
            var newAlternative = alternative.HasValue ? alternative.Value : this.Alternative;
            var newOptimizedAlternative = optimizedAlternative.HasValue ? optimizedAlternative.Value : this.OptimizedAlternative;
            var newFnAvailability = fnAvailability.HasValue ? fnAvailability.Value : CustomAvailability;

            if (newName != this.Name
                || newSignatures != this.Signatures
                || newFlags != this._flags
                || newResultNameKind != this.ResultNameKind
                || newResultNamePrefix != this.ResultNamePrefix
                || newDescription != this.Description
                || newAlternative != this.Alternative
                || newOptimizedAlternative != this.OptimizedAlternative
                || newFnAvailability != CustomAvailability)
            {
                return new FunctionSymbol(
                    newName,
                    newSignatures,
                    newFlags,
                    newResultNameKind,
                    newResultNamePrefix,
                    newDescription,
                    newAlternative,
                    newOptimizedAlternative,
                    newFnAvailability);
            }
            else
            {
                return this;
            }
        }

        /// <summary>
        /// Creates a new <see cref="FunctionSymbol"/> that is hidden from completion lists.
        /// </summary>
        public FunctionSymbol Hide()
        {
            return WithIsHidden(true);
        }

        /// <summary>
        /// Creates a new <see cref="FunctionSymbol"/> with the <see cref="IsHidden"/> property set to the specified value.
        /// </summary>
        public FunctionSymbol WithIsHidden(bool isHidden)
        {
            return With(flags: 
                isHidden 
                    ? _flags | FunctionFlags.Hidden
                    : _flags & ~FunctionFlags.Hidden);
        }

        /// <summary>
        /// Creates a new <see cref="FunctionSymbol"/> that is a constant if all its arguments are constant.
        /// </summary>
        public FunctionSymbol ConstantFoldable()
        {
            return WithIsConstantFoldable(true);
        }

        /// <summary>
        /// Creates a new <see cref="FunctionSymbol"/> with the <see cref="IsConstantFoldable"/> property set to the specified value.
        /// </summary>
        public FunctionSymbol WithIsConstantFoldable(bool isConstantFoldable)
        {
            return With(flags: 
                isConstantFoldable
                    ? _flags | FunctionFlags.Foldable
                    : _flags & ~FunctionFlags.Foldable);
        }

        /// <summary>
        /// Creates a new <see cref="FunctionFlags"/> with the <see cref="IsView"/> property set to the specified value.
        /// </summary>
        public FunctionSymbol WithIsView(bool isView)
        {
            return With(flags:
                isView
                    ? _flags | FunctionFlags.View
                    : _flags & ~FunctionFlags.View);
        }

        /// <summary>
        /// Creates a new <see cref="FunctionSymbol"/> with the <see cref="ResultNamePrefix"/> property set to the specified value.
        /// </summary>
        public FunctionSymbol WithResultNamePrefix(string resultNamePrefix)
        {
            return With(resultNamePrefix: resultNamePrefix);
        }

        /// <summary>
        /// Creates a new <see cref="FunctionSymbol"/> with the <see cref="ResultNameKind"/> property set to the specified value.
        /// </summary>
        public FunctionSymbol WithResultNameKind(ResultNameKind kind)
        {
            return With(resultNameKind: kind);
        }

        /// <summary>
        /// Creates a new <see cref="FunctionSymbol"/> with the <see cref="Description"/> property set to the specified value.
        /// </summary>
        public FunctionSymbol WithDescription(string description)
        {
            return With(description: description);
        }

        /// <summary>
        /// Creates a new <see cref="FunctionSymbol"/> that is considered obsolete/deprecated.
        /// </summary>
        public FunctionSymbol Obsolete(string alternative)
        {
            return WithIsObsolete(true, alternative).Hide();
        }

        /// <summary>
        /// Creates a new <see cref="FunctionSymbol"/> with the <see cref="IsObsolete"/> property set to the specified value.
        /// </summary>
        public FunctionSymbol WithIsObsolete(bool isObsolete, string alternative = null)
        {
            return With(alternative: isObsolete ? alternative ?? "" : null);
        }

        /// <summary>
        /// Creates a new <see cref="FunctionSymbol"/> that is considered to be less optimized
        /// than the alternative function.
        /// </summary>
        public FunctionSymbol WithOptimizedAlternative(string alternative)
        {
            return With(optimizedAlternative: alternative);
        }

        /// <summary>
        /// Creates a new <see cref="FunctionSymbol"/> that has a custom function determining whether or 
        /// not the function is available in a given context.
        /// </summary>
        public FunctionSymbol WithCustomAvailability(CustomAvailability fnAvailability)
        {
            return With(fnAvailability: fnAvailability);
        }

        /// <summary>
        /// The tabularity of the function.
        /// </summary>
        public override Tabularity Tabularity => this.Signatures[0].Tabularity;

        /// <summary>
        /// Gets the return type for the function as best as can be determined without specific call site arguments.
        /// </summary>
        public TypeSymbol GetReturnType(GlobalState globals)
        {
            return this.Signatures[0].GetReturnType(globals);
        }

        /// <summary>
        /// The minimum number of arguments that this function requires.
        /// </summary>
        public int MinArgumentCount
        {
            get
            {
                var min = -1;

                foreach (var s in this.Signatures)
                {
                    min = (min == -1)
                        ? s.MinArgumentCount
                        : Math.Min(min, s.MinArgumentCount);
                }

                return min;
            }
        }

        /// <summary>
        /// The maximum number of arguments this function can take.
        /// </summary>
        public int MaxArgumentCount
        {
            get
            {
                var max = -1;

                foreach (var s in this.Signatures)
                {
                    max = (max == -1)
                        ? s.MaxArgumentCount
                        : Math.Max(max, s.MaxArgumentCount);
                }

                return max;
            }
        }

    }
}